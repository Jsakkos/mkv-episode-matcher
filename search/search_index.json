{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"MKV Episode Matcher","text":"<p>Automatically match and rename your MKV TV episodes using advanced speech recognition and subtitle matching.</p>"},{"location":"#key-features","title":"\u2728 Key Features","text":"<ul> <li>\ud83c\udf10 Modern Web Interface: Premium React-based UI with glassmorphism design and dark mode</li> <li>\ud83e\udd16 Advanced Speech Recognition: NVIDIA Parakeet ASR for highly accurate episode identification</li> <li>\ud83c\udfaf Intelligent Matching: Multi-segment analysis with confidence scoring and fallback strategies</li> <li>\u2b07\ufe0f Smart Subtitle Integration: Automatic subtitle downloads from OpenSubtitles with local caching</li> <li>\u2728 Bulk Processing: Handle entire libraries with automatic series/season detection</li> <li>\ud83d\udcca Real-time Progress: WebSocket-powered progress tracking with live updates</li> <li>\u26a1 Performance Optimized: Caching, background model loading, and efficient processing</li> <li>\ud83d\udc33 Docker Ready: Easy deployment via Docker or local execution</li> </ul>"},{"location":"#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.10-3.12</li> <li>FFmpeg installed and available in system PATH</li> <li>TMDb API key (optional, for episode matching)</li> <li>OpenSubtitles.com account (required for subtitle downloads)</li> </ul>"},{"location":"#quick-start","title":"\ud83d\ude80 Quick Start","text":""},{"location":"#1-install-mkv-episode-matcher","title":"1. Install MKV Episode Matcher","text":"<p>Option A: Using uv (Recommended) <pre><code># Install with CUDA support for GPU acceleration\nuv sync --extra cu128\n\n# Or basic installation\nuv sync\n</code></pre></p> <p>Option B: Using pip <pre><code>pip install mkv-episode-matcher\n</code></pre></p>"},{"location":"#2-launch-the-application","title":"2. Launch the Application","text":"<p>\ud83c\udf10 Web interface (Recommended) Launches the modern web interface in your default browser: <pre><code>uv run python -m mkv_episode_matcher\n</code></pre> Access the UI at <code>http://localhost:8001</code></p> <p>\ud83d\udcbb CLI Mode For automation and advanced users: <pre><code>python -m mkv_episode_matcher match \"/path/to/your/show\"\n</code></pre></p> <p>\u2699\ufe0f Configuration Configuration is now managed directly through the web interface or via config files.</p>"},{"location":"#3-build-standalone-executable","title":"3. Build Standalone Executable","text":"<p>You can build a self-contained executable that bundles the backend and frontend:</p> <pre><code>uv run pyinstaller mkv_match.spec\n# Output in dist/mkv-match/\n</code></pre>"},{"location":"#web-interface-features","title":"\ud83d\udda5\ufe0f Web Interface Features","text":"<p>The new React-based interface provides:</p> <ul> <li>\ud83c\udfa8 Premium Design: Modern aesthetics with glassmorphism and smooth animations</li> <li>\ud83d\udcc2 Visual File Browser: Intuitive navigation of your local file system</li> <li>\u23f1\ufe0f Live Status: Real-time job tracking via WebSockets</li> <li>\ud83d\udcf1 Responsive: Works identically on local machine or remote server access</li> </ul> <p>Required API Keys: - OpenSubtitles API Key: Required for subtitle downloads (Get one here) - TMDb API Key: Optional, for enhanced episode metadata (Get one here)</p> <p>OpenSubtitles Setup: - Username and password (recommended for better rate limits) - API key from the OpenSubtitles developer console</p>"},{"location":"#directory-structure","title":"Directory Structure","text":"<p>MKV Episode Matcher expects your TV shows to be organized as follows:</p> <pre><code>Show Name/\n\u251c\u2500\u2500 Season 1/\n\u2502   \u251c\u2500\u2500 episode1.mkv\n\u2502   \u251c\u2500\u2500 episode2.mkv\n\u251c\u2500\u2500 Season 2/\n\u2502   \u251c\u2500\u2500 episode1.mkv\n\u2502   \u2514\u2500\u2500 episode2.mkv\n</code></pre>"},{"location":"#reference-subtitle-file-structure","title":"Reference Subtitle File Structure","text":"<p>Subtitle files that are not automatically downloaded using the <code>--get-subs</code> flag should be named as follows:</p> <pre><code>~/.mkv-episode-matcher/cache/data/Show Name/\n\u251c\u2500\u2500 Show Name - S01E01.srt\n\u251c\u2500\u2500 Show Name - S01E02.srt\n\u2514\u2500\u2500 ...\n</code></pre> <p>On Windows, the cache directory is located at <code>C:\\Users\\{username}\\.mkv-episode-matcher\\cache\\data\\</code></p> <p>Reference subtitle files should follow this naming pattern: <code>{show_name} - S{season:02d}E{episode:02d}.srt</code></p>"},{"location":"#contributing","title":"Contributing","text":"<ol> <li>Fork the repository</li> <li>Create a feature branch (<code>git checkout -b feature/amazing-feature</code>)</li> <li>Commit your changes (<code>git commit -m 'Add amazing feature'</code>)</li> <li>Push to the branch (<code>git push origin feature/amazing-feature</code>)</li> <li>Open a Pull Request</li> </ol>"},{"location":"#license","title":"License","text":"<p>Distributed under the MIT License. See <code>LICENSE</code> for more information.</p>"},{"location":"#acknowledgments","title":"Acknowledgments","text":"<ul> <li>TMDb for their excellent API</li> <li>OpenSubtitles for subtitle integration</li> <li>All contributors who have helped improve this project</li> </ul>"},{"location":"#documentation","title":"Documentation","text":"<p>Full documentation is available at https://jsakkos.github.io/mkv-episode-matcher/</p>"},{"location":"#changelog","title":"Changelog","text":"<p>See CHANGELOG.md for a detailed list of changes.</p>"},{"location":"CHANGELOG/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"CHANGELOG/#110-2026-01-11-polish-release","title":"[1.1.0] - 2026-01-11 - Polish Release \u2728","text":""},{"location":"CHANGELOG/#uiux-improvements","title":"\ud83d\udda5\ufe0f UI/UX Improvements","text":"<ul> <li>Complete Redesign: New glassmorphism-inspired UI with modern color palette and improved aesthetics</li> <li>Enhanced Workflow: Clearer 4-step process (Folder Selection -&gt; Scan -&gt; Review -&gt; Match)</li> <li>Component Refactoring: Cleaner code structure with explicit Sidebar and Layout components</li> <li>System Status Indicator: Prominent indicator for backend system and model loading status</li> </ul>"},{"location":"CHANGELOG/#backend-optimizations","title":"\u26a1 Backend Optimizations","text":"<ul> <li>Singleton Model Loading: Fixed issue where Parakeet model was loaded multiple times</li> <li>Background Loading: Model initialization now happens in background on startup</li> <li>Status Endpoint: New <code>/system/status</code> endpoint for frontend health checks</li> <li>Performance: Significant reduction in resource usage during repeated scans</li> </ul>"},{"location":"CHANGELOG/#fixes-updates","title":"\ud83d\udee0\ufe0f Fixes &amp; Updates","text":"<ul> <li>Dependency Updates: Relaxed Python version constraints</li> <li>CLI improvements: Better error handling and help output</li> <li>Documentation: Updated CLI and README documentation</li> </ul>"},{"location":"CHANGELOG/#added-desktop-gui","title":"\ud83d\udda5\ufe0f Added - Desktop GUI","text":"<ul> <li>Complete Flet-based desktop application with cross-platform support</li> <li>Theme-adaptive interface that follows system light/dark mode</li> <li>Real-time progress tracking with \"Processing file X of Y\" indicators</li> <li>Background model loading with status indicators to prevent UI freezing</li> <li>Built-in configuration dialog accessible via settings icon</li> <li>Dry run preview mode allowing users to preview rename operations</li> <li>Visual folder picker for easy directory selection</li> <li>Color-coded results display with detailed match information and confidence scores</li> <li>Responsive progress bars and status indicators</li> <li>Version display and model loading status in app header</li> </ul>"},{"location":"CHANGELOG/#enhanced-asr-and-matching-engine","title":"\ud83e\udd16 Enhanced - ASR and Matching Engine","text":"<ul> <li>Complete rewrite of matching engine (V2) with improved architecture</li> <li>NVIDIA Parakeet ASR integration replacing OpenAI Whisper for better accuracy</li> <li>Multi-segment analysis with fallback strategies to handle empty transcription segments</li> <li>Enhanced caching system for performance optimization</li> <li>Intelligent checkpoint selection with primary and fallback locations</li> <li>Improved confidence scoring and voting logic</li> <li>Better error handling for silent/music-only video segments</li> </ul>"},{"location":"CHANGELOG/#improved-core-processing","title":"\ud83d\udcca Improved - Core Processing","text":"<ul> <li>Automatic series and season detection from directory structure</li> <li>Enhanced subtitle provider system with local caching and OpenSubtitles integration</li> <li>Optimized file processing workflow with progress callbacks</li> <li>Smart skip logic for already processed files with S##E## patterns</li> <li>Better failure reporting with season information for user guidance</li> <li>Comprehensive error handling with user-friendly messages</li> </ul>"},{"location":"CHANGELOG/#performance-optimizations","title":"\u26a1 Performance Optimizations","text":"<ul> <li>Model singleton pattern to avoid repeated ASR model loading</li> <li>Memory caching for subtitle content and metadata</li> <li>Background task processing for non-blocking operations  </li> <li>Efficient file scanning with recursive directory support</li> <li>LRU caching for video duration and metadata</li> </ul>"},{"location":"CHANGELOG/#technical-improvements","title":"\ud83d\udee0\ufe0f Technical Improvements","text":"<ul> <li>Complete code restructuring with core/, ui/, and providers/ modules</li> <li>Pydantic models for type safety and validation</li> <li>Modern async/await patterns for GUI responsiveness</li> <li>Enhanced logging with structured debug information</li> <li>Improved configuration management with centralized config system</li> <li>Better path handling using pathlib throughout</li> </ul>"},{"location":"CHANGELOG/#user-experience","title":"\ud83c\udfa8 User Experience","text":"<ul> <li>Comprehensive onboarding process for first-time setup</li> <li>Interactive configuration with validation </li> <li>Rich console output with color coding and progress indicators</li> <li>Detailed match results with confidence percentages</li> <li>Preview functionality to test matches before applying changes</li> <li>Better error messages with actionable guidance</li> </ul>"},{"location":"CHANGELOG/#deployment-ready","title":"\ud83d\ude80 Deployment Ready","text":"<ul> <li>Flet build configuration for Windows, macOS, and Linux executables</li> <li>GitHub Actions ready for automated builds and releases</li> <li>Comprehensive packaging with all required dependencies</li> <li>Cross-platform compatibility testing</li> </ul>"},{"location":"CHANGELOG/#developer-experience","title":"\ud83d\udd27 Developer Experience","text":"<ul> <li>Modular architecture with clear separation of concerns</li> <li>Comprehensive type hints throughout the codebase</li> <li>Enhanced test coverage with pytest and mocking</li> <li>Ruff formatting and linting configuration</li> <li>Documentation updates reflecting new architecture</li> </ul>"},{"location":"CHANGELOG/#093-2025-07-07","title":"[0.9.3] - 2025-07-07","text":""},{"location":"CHANGELOG/#added","title":"Added","text":"<ul> <li>Onboarding flag (<code>--onboard</code>) and interactive onboarding sequence for first-time setup and configuration updates</li> <li>Onboarding prompts for TMDb API key, OpenSubtitles API key, Consumer Name, Username, Password, and Show Directory</li> <li>Existing config values are shown as defaults during onboarding and can be accepted or overwritten</li> <li>Documentation updated to reflect onboarding requirements and workflow in README and docs</li> </ul>"},{"location":"CHANGELOG/#changed","title":"Changed","text":"<ul> <li>Improved configuration experience for new and returning users</li> <li>Quick Start and Configuration documentation now reference onboarding and required credentials</li> </ul>"},{"location":"CHANGELOG/#090-2025-06-01","title":"[0.9.0] - 2025-06-01","text":""},{"location":"CHANGELOG/#changed_1","title":"Changed","text":"<ul> <li>Replaced all <code>os.path</code> calls with <code>pathlib.Path</code> for improved path handling</li> <li>Fixed issues with trailing slashes in directory paths</li> <li>Updated <code>check_filename</code> to handle both string paths and Path objects</li> <li>Modernized file and directory operations to use pathlib API</li> </ul>"},{"location":"CHANGELOG/#enhanced","title":"Enhanced","text":"<ul> <li>Improved robustness of path manipulation operations</li> <li>Better handling of different path formats across operating systems</li> <li>More consistent behavior with paths containing trailing slashes</li> </ul>"},{"location":"CHANGELOG/#fixed","title":"Fixed","text":"<ul> <li>Fixed bug where paths with trailing slashes would result in empty show names</li> <li>Fixed incorrect handling of paths in subtitle downloads and match operations</li> </ul>"},{"location":"CHANGELOG/#070-2025-03-05","title":"0.7.0 - 2025-03-05","text":""},{"location":"CHANGELOG/#added_1","title":"Added","text":"<ul> <li>Rich UI with color-coded output and progress indicators</li> <li>Interactive season selection interface</li> <li>Visual confirmation panels for operations</li> <li>GPU support check command</li> <li>Masked API key display for improved security</li> <li>Verbose output option for detailed logging</li> </ul>"},{"location":"CHANGELOG/#changed_2","title":"Changed","text":"<ul> <li>Enhanced CLI interface with better visual feedback</li> <li>Improved error messages with color coding</li> <li>Updated documentation to reflect new UI features</li> </ul>"},{"location":"CHANGELOG/#060-2025-03-02","title":"0.6.0 - 2025-03-02","text":""},{"location":"CHANGELOG/#added_2","title":"Added","text":"<ul> <li>Comprehensive documentation including installation, configuration, and CLI guides</li> <li>Quick start guide with common usage examples</li> <li>Tips and tricks documentation with best practices</li> <li>Detailed changelog structure</li> </ul>"},{"location":"CHANGELOG/#changed_3","title":"Changed","text":"<ul> <li>Improved project metadata and description</li> <li>Updated version number in setup.cfg</li> </ul>"},{"location":"CHANGELOG/#removed","title":"Removed","text":"<ul> <li>Removed OCR support and Tesseract dependency</li> <li>Removed unused code</li> </ul>"},{"location":"CHANGELOG/#050-2025-02-23","title":"0.5.0 - 2025-02-23","text":""},{"location":"CHANGELOG/#changed_4","title":"Changed","text":"<ul> <li>Try to use tiny version of OpenAI Whisper for initial matching</li> <li>Fall back to base model if tiny model fails</li> <li>Progressive matching in 30s intervals (was 300s)</li> </ul>"},{"location":"CHANGELOG/#removed_1","title":"Removed","text":"<ul> <li>Removed unused code</li> </ul>"},{"location":"changelog/","title":"Changelog","text":"<p>For a complete list of changes, see CHANGELOG.md in the repository root.</p>"},{"location":"changelog/#latest-changes","title":"Latest Changes","text":""},{"location":"changelog/#060-2025-02-24","title":"0.6.0 - 2025-02-24","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>Comprehensive documentation including installation, configuration, and CLI guides</li> <li>Quick start guide with common usage examples</li> <li>Tips and tricks documentation with best practices</li> <li>Detailed changelog structure</li> </ul>"},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li>Improved project metadata and description</li> <li>Updated version number in setup.cfg</li> </ul>"},{"location":"changelog/#removed","title":"Removed","text":"<ul> <li>Removed OCR support and Tesseract dependency</li> <li>Removed unused code</li> </ul>"},{"location":"changelog/#050-2025-02-23","title":"0.5.0 - 2025-02-23","text":""},{"location":"changelog/#changed_1","title":"Changed","text":"<ul> <li>Try to use tiny version of OpenAI Whisper for initial matching</li> <li>Fall back to base model if tiny model fails</li> <li>Progressive matching in 30s intervals (was 300s)</li> </ul>"},{"location":"changelog/#removed_1","title":"Removed","text":"<ul> <li>Removed unused code</li> </ul> <p>For older versions and complete changelog history, please visit our GitHub releases page.</p>"},{"location":"cli/","title":"Command Line Interface","text":"<p>The MKV Episode Matcher CLI features a rich, user-friendly interface with color-coded output and progress indicators.</p>"},{"location":"cli/#basic-usage","title":"Basic Usage","text":""},{"location":"cli/#interactive-configuration","title":"Interactive Configuration","text":"<pre><code># First-time setup wizard\nmkv-match config\n\n# Show current configuration\nmkv-match config --show\n\n# Set specific values\nmkv-match config --tmdb-api-key \"your_key\" --opensub-api-key \"your_key\"\n</code></pre>"},{"location":"cli/#processing-files-and-directories","title":"Processing Files and Directories","text":"<pre><code># Process a single MKV file\nmkv-match match \"/path/to/episode.mkv\"\n\n# Process an entire series folder\nmkv-match match \"/path/to/Show/Season 1/\"\n\n# Process entire library with subtitle downloads\nmkv-match match \"/path/to/library/\" --get-subs\n</code></pre>"},{"location":"cli/#gui-mode","title":"GUI Mode","text":"<pre><code># Launch desktop application\nmkv-match gui\n</code></pre>"},{"location":"cli/#core-commands","title":"Core Commands","text":"Command Description <code>config</code> Manage configuration settings <code>match</code> Process and match MKV files <code>gui</code> Launch desktop graphical interface"},{"location":"cli/#match-command-options","title":"Match Command Options","text":"Option Description Default <code>path</code> File or directory to process Required <code>--season</code> Season number to process Auto-detect <code>--dry-run</code> Test without making changes False <code>--get-subs</code> Download subtitles False <code>--confidence</code> Minimum confidence threshold 0.8 <code>--output-dir</code> Copy files to directory None <code>--json</code> JSON output for automation False <code>--verbose</code> Verbose logging output False"},{"location":"cli/#configuration-options","title":"Configuration Options","text":"Option Description Example <code>--tmdb-api-key</code> TMDb API key <code>--tmdb-api-key \"key\"</code> <code>--opensub-api-key</code> OpenSubtitles API key <code>--opensub-api-key \"key\"</code> <code>--opensub-username</code> OpenSubtitles username <code>--opensub-username \"user\"</code> <code>--opensub-password</code> OpenSubtitles password <code>--opensub-password \"pass\"</code> <code>--cache-dir</code> Cache directory path <code>--cache-dir \"/custom\"</code> <code>--confidence</code> Confidence threshold (0.0-1.0) <code>--confidence 0.85</code> <code>--show</code> Show current configuration <code>--show</code>"},{"location":"cli/#examples","title":"Examples","text":""},{"location":"cli/#first-time-setup","title":"First-Time Setup","text":"<pre><code># Interactive configuration\nmkv-match config\n\n# Or set values directly\nmkv-match config \\\n  --tmdb-api-key \"your_tmdb_key\" \\\n  --opensub-api-key \"your_opensub_key\" \\\n  --opensub-username \"your_username\" \\\n  --opensub-password \"your_password\"\n</code></pre>"},{"location":"cli/#basic-processing","title":"Basic Processing","text":"<pre><code># Process with dry run\nmkv-match match \"/path/to/Show/Season 1/\" --dry-run\n\n# Process and download subtitles\nmkv-match match \"/path/to/Show/Season 1/\" --get-subs\n\n# Process specific season only\nmkv-match match \"/path/to/Show/\" --season 1\n</code></pre>"},{"location":"cli/#advanced-processing","title":"Advanced Processing","text":"<pre><code># Copy to output directory instead of renaming\nmkv-match match \"/path/to/show/\" --output-dir \"/path/to/renamed/\"\n\n# JSON output for automation\nmkv-match match \"/path/to/library/\" --json --output-dir \"/processed/\"\n\n# High confidence matching with verbose output\nmkv-match match \"/path/to/show/\" --confidence 0.9 --verbose\n</code></pre>"},{"location":"cli/#batch-processing","title":"Batch Processing","text":"<pre><code># Process entire library efficiently (recommended)\nmkv-match match \"/path/to/library/\" --get-subs\n\n# Process multiple shows with consistent settings\nfor show in /path/to/library/*/; do\n  mkv-match match \"$show\" --get-subs --confidence 0.85\ndone\n</code></pre>"},{"location":"cli/#logging","title":"Logging","text":"<p>Logs are stored in: <pre><code>~/.mkv-episode-matcher/logs/\n\u251c\u2500\u2500 stdout.log\n\u2514\u2500\u2500 stderr.log\n</code></pre></p>"},{"location":"cli/#tips","title":"Tips","text":"<ol> <li>Always use quotes around paths</li> <li>Use dry-run first to test</li> <li>Check logs for details</li> <li>Use full paths for reliability</li> <li>Avoid using a trailing slash in paths</li> </ol>"},{"location":"configuration/","title":"Configuration Guide","text":"<p>MKV Episode Matcher v1.0.0 supports both interactive configuration through the GUI and CLI, as well as manual JSON configuration files.</p>"},{"location":"configuration/#configuration-file","title":"Configuration File","text":"<p>MKV Episode Matcher uses a JSON configuration file located at:</p> <ul> <li>Windows: <code>%USERPROFILE%\\.mkv-episode-matcher\\config.json</code></li> <li>Linux/Mac: <code>~/.mkv-episode-matcher/config.json</code></li> </ul>"},{"location":"configuration/#configuration-methods","title":"Configuration Methods","text":""},{"location":"configuration/#gui-configuration-recommended","title":"\ud83d\udda5\ufe0f GUI Configuration (Recommended)","text":"<p>The easiest way to configure the application:</p> <ol> <li>Launch the desktop app: <code>mkv-match gui</code></li> <li>Click the settings (\u2699\ufe0f) icon in the header</li> <li>Fill in your API keys and preferences</li> <li>Save the configuration</li> </ol> <p>The GUI provides: - Visual input validation - Secure password fields - Real-time configuration testing - Theme-adaptive settings dialog</p>"},{"location":"configuration/#cli-configuration","title":"\ud83d\udcbb CLI Configuration","text":"<p>Interactive configuration wizard:</p> <pre><code># Interactive setup\nmkv-match config\n\n# Set specific values\nmkv-match config --tmdb-api-key \"your_key\" --opensub-api-key \"your_key\"\n\n# Show current configuration\nmkv-match config --show\n</code></pre>"},{"location":"configuration/#manual-configuration","title":"\u270f\ufe0f Manual Configuration","text":"<p>Example configuration file (<code>config.json</code>):</p> <pre><code>{\n  \"tmdb_api_key\": \"your_tmdb_api_key\",\n  \"open_subtitles_api_key\": \"your_opensubs_key\",\n  \"open_subtitles_user_agent\": \"mkv-episode-matcher/1.0.0\",\n  \"open_subtitles_username\": \"your_username\",\n  \"open_subtitles_password\": \"your_password\",\n  \"cache_dir\": \"~/.mkv-episode-matcher/cache\",\n  \"min_confidence\": 0.8,\n  \"asr_provider\": \"parakeet\",\n  \"sub_provider\": \"opensubtitles\"\n}\n</code></pre>"},{"location":"configuration/#configuration-options","title":"Configuration Options","text":"Setting Description Default Required <code>tmdb_api_key</code> TMDb API key None No <code>open_subtitles_api_key</code> OpenSubtitles API key None Yes* <code>open_subtitles_user_agent</code> User agent for API requests <code>mkv-episode-matcher/1.0.0</code> No <code>open_subtitles_username</code> OpenSubtitles username None No\u2020 <code>open_subtitles_password</code> OpenSubtitles password None No\u2020 <code>cache_dir</code> Cache directory path <code>~/.mkv-episode-matcher/cache</code> No <code>min_confidence</code> Minimum confidence threshold (0-1) 0.8 No <code>asr_provider</code> Speech recognition provider <code>parakeet</code> No <code>sub_provider</code> Subtitle provider <code>opensubtitles</code> No <p>* Required if using subtitle download functionality \u2020 Recommended for better rate limits</p>"},{"location":"configuration/#api-keys-setup","title":"API Keys Setup","text":""},{"location":"configuration/#tmdb-api-key-optional","title":"\ud83c\udfac TMDb API Key (Optional)","text":"<p>TMDb integration provides enhanced episode metadata:</p> <ol> <li>Visit TMDb API Settings</li> <li>Create a new API key</li> <li>Add it to your configuration</li> </ol> <p>Features enabled: - Enhanced show identification - Episode titles and metadata - Season information validation</p>"},{"location":"configuration/#opensubtitles-api-key-required-for-subtitles","title":"\ud83d\udce5 OpenSubtitles API Key (Required for subtitles)","text":"<p>OpenSubtitles integration provides subtitle downloads:</p> <ol> <li>Visit OpenSubtitles Developers</li> <li>Create an account and register an application</li> <li>Get your API key</li> <li>Add credentials to configuration</li> </ol> <p>Username/Password Benefits: - Higher API rate limits - Better download quotas - Priority support</p>"},{"location":"configuration/#advanced-settings","title":"Advanced Settings","text":""},{"location":"configuration/#asr-provider-configuration","title":"ASR Provider Configuration","text":"<pre><code>{\n  \"asr_provider\": \"parakeet\",\n  \"asr_model\": \"nvidia/parakeet-tdt-1.1b\",\n  \"asr_device\": \"auto\"\n}\n</code></pre> <p>Available providers: - <code>parakeet</code>: NVIDIA Parakeet (default, most accurate) - <code>whisper</code>: OpenAI Whisper (fallback)</p>"},{"location":"configuration/#cache-configuration","title":"Cache Configuration","text":"<pre><code>{\n  \"cache_dir\": \"/custom/cache/path\",\n  \"cache_max_memory_mb\": 512,\n  \"cache_max_items\": 100\n}\n</code></pre> <p>Cache features: - Bounded memory usage (512MB default) - LRU eviction strategy - Persistent model caching</p>"},{"location":"configuration/#network-configuration","title":"Network Configuration","text":"<pre><code>{\n  \"network_timeout\": 30,\n  \"network_retries\": 3,\n  \"backoff_factor\": 2.0\n}\n</code></pre> <p>Network resilience: - Automatic retries with exponential backoff - Configurable timeouts - Connection error handling</p>"},{"location":"configuration/#configuration-validation","title":"Configuration Validation","text":"<p>The application validates configuration on startup:</p> <p>\u2705 Valid Configuration: - All required keys present - API keys have correct format - Paths are accessible - Values within valid ranges</p> <p>\u274c Common Issues: - Missing OpenSubtitles API key when using <code>--get-subs</code> - Invalid cache directory permissions - Confidence threshold outside 0.0-1.0 range</p>"},{"location":"configuration/#environment-variables","title":"Environment Variables","text":"<p>Override configuration with environment variables:</p> <pre><code>export MKV_TMDB_API_KEY=\"your_key\"\nexport MKV_OPENSUB_API_KEY=\"your_key\"\nexport MKV_CACHE_DIR=\"/custom/cache\"\nexport MKV_CONFIDENCE=0.85\n\nmkv-match match \"/path/to/show/\"\n</code></pre>"},{"location":"configuration/#troubleshooting","title":"Troubleshooting","text":""},{"location":"configuration/#configuration-not-found","title":"Configuration Not Found","text":"<p>If configuration is missing: 1. Run <code>mkv-match config</code> to create it 2. Or use GUI settings to initialize 3. Check file permissions in <code>~/.mkv-episode-matcher/</code></p>"},{"location":"configuration/#api-key-issues","title":"API Key Issues","text":"<p>For API authentication problems: 1. Verify keys in your provider dashboards 2. Check network connectivity 3. Review rate limiting messages in logs</p>"},{"location":"configuration/#permission-errors","title":"Permission Errors","text":"<p>For cache directory issues: 1. Ensure write permissions to cache directory 2. Try custom cache directory: <code>--cache-dir \"/writable/path\"</code> 3. Check disk space availability</p>"},{"location":"installation/","title":"Installation Guide","text":"<p>MKV Episode Matcher v1.0.0 offers multiple installation options including standalone executables, package managers, and development setups.</p>"},{"location":"installation/#quick-installation-options","title":"\ud83d\ude80 Quick Installation Options","text":""},{"location":"installation/#1-standalone-executables-easiest","title":"1. Standalone Executables (Easiest)","text":"<p>Download ready-to-run applications with everything included:</p> <p>Windows: <pre><code># Download and extract\nInvoke-WebRequest -Uri \"https://github.com/Jsakkos/mkv-episode-matcher/releases/latest/download/MKVEpisodeMatcher-windows.zip\" -OutFile \"mkv-matcher.zip\"\nExpand-Archive \"mkv-matcher.zip\"\ncd mkv-matcher\n./MKVEpisodeMatcher.exe\n</code></pre></p> <p>macOS: <pre><code># Download and extract\ncurl -L \"https://github.com/Jsakkos/mkv-episode-matcher/releases/latest/download/MKVEpisodeMatcher-macos.zip\" -o mkv-matcher.zip\nunzip mkv-matcher.zip\nopen MKVEpisodeMatcher.app\n</code></pre></p> <p>Linux: <pre><code># Download AppImage\nwget \"https://github.com/Jsakkos/mkv-episode-matcher/releases/latest/download/mkv-episode-matcher-linux.AppImage\"\nchmod +x mkv-episode-matcher-linux.AppImage\n./mkv-episode-matcher-linux.AppImage\n</code></pre></p>"},{"location":"installation/#2-package-installation","title":"2. Package Installation","text":"<p>Using uv (Recommended): <pre><code># Basic installation\nuv sync\n\n# With CUDA GPU support (Windows/Linux only)\nuv sync --extra cu128\n\n# With development tools\nuv sync --group dev\n</code></pre></p> <p>Using pip: <pre><code># Basic installation\npip install mkv-episode-matcher\n\n# For GPU acceleration (after basic install)\npip install torch --index-url https://download.pytorch.org/whl/cu128\n</code></pre></p>"},{"location":"installation/#prerequisites","title":"Prerequisites","text":""},{"location":"installation/#required-system-dependencies","title":"Required System Dependencies","text":"<p>FFmpeg (Required for audio extraction):</p> <ul> <li> <p>Windows: Download from FFmpeg website or use package manager:   <pre><code>winget install FFmpeg.FFmpeg\n# or\nchoco install ffmpeg\n</code></pre></p> </li> <li> <p>macOS:    <pre><code>brew install ffmpeg\n</code></pre></p> </li> <li> <p>Linux:    <pre><code># Ubuntu/Debian\nsudo apt install ffmpeg\n\n# RHEL/CentOS/Fedora\nsudo dnf install ffmpeg\n\n# Arch Linux\nsudo pacman -S ffmpeg\n</code></pre></p> </li> </ul> <p>Verification: <pre><code>ffmpeg -version\n</code></pre></p>"},{"location":"installation/#python-requirements-package-installation-only","title":"Python Requirements (Package Installation Only)","text":"<ul> <li>Python 3.10-3.12</li> <li>pip or uv package manager</li> </ul>"},{"location":"installation/#installation-methods","title":"Installation Methods","text":""},{"location":"installation/#method-1-uv-package-manager-recommended","title":"Method 1: uv Package Manager (Recommended)","text":"<p>Install uv: <pre><code># macOS/Linux\ncurl -LsSf https://astral.sh/uv/install.sh | sh\n\n# Windows\npowershell -c \"irm https://astral.sh/uv/install.ps1 | iex\"\n</code></pre></p> <p>Install MKV Episode Matcher: <pre><code># Clone repository\ngit clone https://github.com/Jsakkos/mkv-episode-matcher.git\ncd mkv-episode-matcher\n\n# Basic installation\nuv sync\n\n# With CUDA support (GPU acceleration)\nuv sync --extra cu128\n\n# Launch application\nuv run mkv-match gui\n</code></pre></p>"},{"location":"installation/#method-2-pip-installation","title":"Method 2: pip Installation","text":"<pre><code># Install from PyPI\npip install mkv-episode-matcher\n\n# Launch GUI\nmkv-match gui\n\n# Or launch CLI\nmkv-match config\n</code></pre>"},{"location":"installation/#method-3-development-installation","title":"Method 3: Development Installation","text":"<pre><code># Clone repository\ngit clone https://github.com/Jsakkos/mkv-episode-matcher.git\ncd mkv-episode-matcher\n\n# Install uv if not already installed\npip install uv\n\n# Install with development dependencies\nuv sync --group dev\n\n# Run tests\nuv run pytest\n\n# Launch application\nuv run mkv-match gui\n</code></pre>"},{"location":"installation/#gpu-acceleration-setup","title":"GPU Acceleration Setup","text":""},{"location":"installation/#nvidia-cuda-support","title":"NVIDIA CUDA Support","text":"<p>Windows/Linux with CUDA GPU: <pre><code># Install with CUDA support\nuv sync --extra cu128\n\n# Verify GPU detection\nuv run python -c \"import torch; print(f'CUDA available: {torch.cuda.is_available()}')\"\n</code></pre></p> <p>Requirements: - NVIDIA GPU with CUDA Compute Capability 6.0+ - CUDA Toolkit 12.8 or compatible - At least 4GB VRAM recommended</p> <p>Benefits: - 5-10x faster speech recognition - Better handling of large audio files - Parallel processing capabilities</p>"},{"location":"installation/#cpu-only-installation","title":"CPU-Only Installation","text":"<p>For systems without CUDA support, the CPU installation works with: - Intel/AMD processors - Apple Silicon (M1/M2/M3) - ARM processors</p> <p>Performance will be slower but fully functional.</p>"},{"location":"installation/#configuration-setup","title":"Configuration Setup","text":""},{"location":"installation/#first-time-configuration","title":"First-Time Configuration","text":"<p>GUI Method (Easiest): 1. Launch: <code>mkv-match gui</code> or run executable 2. Click the settings (\u2699\ufe0f) gear icon 3. Enter your API keys and preferences 4. Save configuration</p> <p>CLI Method: <pre><code># Interactive setup\nmkv-match config\n\n# Direct configuration\nmkv-match config \\\n  --tmdb-api-key \"your_tmdb_key\" \\\n  --opensub-api-key \"your_opensub_key\"\n</code></pre></p>"},{"location":"installation/#required-api-keys","title":"Required API Keys","text":"<p>OpenSubtitles API Key (Required for subtitle downloads): 1. Visit OpenSubtitles Developers 2. Create account and register application 3. Copy API key to configuration</p> <p>TMDb API Key (Optional, for enhanced metadata): 1. Visit TMDb API Settings 2. Request API key 3. Add to configuration</p>"},{"location":"installation/#system-requirements","title":"System Requirements","text":"Component Minimum Recommended OS Windows 10, macOS 12, Ubuntu 20.04 Windows 11, macOS 13+, Ubuntu 22.04+ Python 3.10 3.12 RAM 4GB 8GB+ Storage 2GB 5GB+ (for model cache) GPU Optional NVIDIA GTX 1060+ with 4GB+ VRAM"},{"location":"installation/#verification","title":"Verification","text":"<p>Test Installation: <pre><code># Check version\nmkv-match --version\n\n# Test configuration\nmkv-match config --show\n\n# Test GPU (if applicable)\nuv run python -c \"\nimport torch\nprint(f'PyTorch: {torch.__version__}')\nprint(f'CUDA Available: {torch.cuda.is_available()}')\nif torch.cuda.is_available():\n    print(f'CUDA Device: {torch.cuda.get_device_name()}\")\n\"\n</code></pre></p> <p>Test Basic Functionality: <pre><code># Launch GUI (should open desktop application)\nmkv-match gui\n\n# Test CLI help\nmkv-match --help\n</code></pre></p>"},{"location":"installation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"installation/#common-installation-issues","title":"Common Installation Issues","text":"<p>FFmpeg Not Found: <pre><code># Test FFmpeg installation\nffmpeg -version\n\n# If missing, install per platform instructions above\n</code></pre></p> <p>Python Version Issues: <pre><code># Check Python version\npython --version\n\n# Install compatible version if needed\n</code></pre></p> <p>CUDA Installation Problems: <pre><code># Check CUDA toolkit\nnvcc --version\n\n# Reinstall PyTorch with correct CUDA version\npip uninstall torch torchvision torchaudio\npip install torch --index-url https://download.pytorch.org/whl/cu128\n</code></pre></p> <p>Permission Errors: <pre><code># On Linux/macOS, try with user directory\npip install --user mkv-episode-matcher\n\n# Or use virtual environment\npython -m venv mkv-env\nsource mkv-env/bin/activate  # Linux/macOS\n# mkv-env\\Scripts\\activate   # Windows\npip install mkv-episode-matcher\n</code></pre></p>"},{"location":"installation/#platform-specific-issues","title":"Platform-Specific Issues","text":"<p>macOS Issues: - Apple Silicon: Use native ARM64 Python, not x86_64 - Rosetta: May work but performance will be reduced - Security: May need to allow unsigned applications</p> <p>Windows Issues: - Antivirus: Some AV software may flag executables - PATH: Ensure FFmpeg is in system PATH - PowerShell: Use PowerShell 5.1+ for best compatibility</p> <p>Linux Issues: - Dependencies: Install system packages for audio libraries - AppImage: May need to install FUSE for older systems - Permissions: Ensure execute permissions on binaries</p>"},{"location":"installation/#getting-help","title":"Getting Help","text":"<p>If you encounter issues:</p> <ol> <li>Check Logs: Look in <code>~/.mkv-episode-matcher/logs/</code></li> <li>Update Dependencies: <code>pip install --upgrade mkv-episode-matcher</code></li> <li>Community Support: GitHub Discussions</li> <li>Bug Reports: GitHub Issues</li> </ol> <p>Include the following in bug reports: - Operating system and version - Python version (<code>python --version</code>) - Installation method used - Full error message and traceback - Log files from <code>~/.mkv-episode-matcher/logs/</code></p>"},{"location":"quickstart/","title":"Quick Start Guide","text":"<p>Get started with MKV Episode Matcher v1.0.0 quickly and efficiently.</p>"},{"location":"quickstart/#choose-your-interface","title":"\ud83d\ude80 Choose Your Interface","text":"<p>MKV Episode Matcher offers two interfaces: a modern desktop GUI and a powerful CLI.</p>"},{"location":"quickstart/#desktop-gui-recommended","title":"\ud83d\udda5\ufe0f Desktop GUI (Recommended)","text":"<p>The easiest way to get started:</p> <pre><code># Launch the desktop application\nmkv-match gui\n</code></pre> <p>Features: - Theme-adaptive interface (follows system dark/light mode) - Real-time progress tracking with \"Processing file X of Y\" - Built-in configuration dialog (click the gear icon) - Dry run preview functionality - Visual folder selection - Color-coded results with confidence scores</p> <p>First Time Setup: 1. Launch the GUI: <code>mkv-match gui</code> 2. Click the settings (\u2699\ufe0f) icon in the header 3. Configure your API keys and preferences 4. Select a library folder and start processing!</p>"},{"location":"quickstart/#command-line-interface","title":"\ud83d\udcbb Command Line Interface","text":"<p>For automation and advanced users:</p>"},{"location":"quickstart/#1-configuration-setup","title":"1. Configuration Setup","text":"<pre><code># Interactive configuration wizard\nmkv-match config\n\n# Set specific configuration values\nmkv-match config --tmdb-api-key \"your_key\" --opensub-api-key \"your_key\"\n</code></pre>"},{"location":"quickstart/#2-basic-matching","title":"2. Basic Matching","text":"<pre><code># Process a single MKV file\nmkv-match match \"/path/to/episode.mkv\"\n\n# Process an entire series folder\nmkv-match match \"/path/to/Show/Season 1/\"\n\n# Process entire library with subtitle downloads\nmkv-match match \"/path/to/library/\" --get-subs\n</code></pre>"},{"location":"quickstart/#3-advanced-options","title":"3. Advanced Options","text":"<pre><code># Dry run with specific season\nmkv-match match \"/path/to/show/\" --season 1 --dry-run\n\n# JSON output for automation\nmkv-match match \"/path/to/show/\" --json\n\n# Copy files instead of renaming\nmkv-match match \"/path/to/show/\" --output-dir \"/path/to/renamed/\"\n</code></pre>"},{"location":"quickstart/#performance-tips","title":"\u26a1 Performance Tips","text":""},{"location":"quickstart/#batch-processing","title":"Batch Processing","text":"<p>Important: Parakeet ASR model takes time to initialize. For best performance:</p> <p>\u2705 DO: Process entire folders/seasons at once <pre><code># Process whole season - model loads once for all files\nmkv-match match \"/path/to/Show/Season 1/\"\n</code></pre></p> <p>\u274c DON'T: Process files one by one <pre><code># Inefficient - model reloads for each file\nmkv-match match \"/path/to/episode1.mkv\"\nmkv-match match \"/path/to/episode2.mkv\"  \n</code></pre></p>"},{"location":"quickstart/#model-loading","title":"Model Loading","text":"<ul> <li>First run takes 30-60 seconds to download and initialize Parakeet</li> <li>Subsequent runs reuse the cached model (much faster)</li> <li>In GUI mode, model loads in background so you can configure while waiting</li> </ul>"},{"location":"quickstart/#key-features","title":"\ud83c\udfaf Key Features","text":""},{"location":"quickstart/#new-in-v100","title":"New in v1.0.0","text":"<ul> <li>Desktop GUI with theme-adaptive interface</li> <li>Enhanced ASR using NVIDIA Parakeet for better accuracy</li> <li>Smart caching with memory limits and LRU eviction</li> <li>Network resilience with automatic retries and timeouts</li> <li>Multi-segment matching with fallback strategies</li> <li>Real-time progress tracking and background processing</li> </ul>"},{"location":"quickstart/#core-features","title":"Core Features","text":"<ul> <li>Intelligent matching with confidence scoring</li> <li>Automatic subtitle downloads from OpenSubtitles</li> <li>Bulk processing of entire libraries</li> <li>Dry run mode for preview operations</li> <li>Cross-platform support (Windows, macOS, Linux)</li> </ul>"},{"location":"quickstart/#directory-structure","title":"\ud83d\udcc1 Directory Structure","text":"<p>Expected TV show organization: <pre><code>Media Library/\n\u251c\u2500\u2500 Show Name/\n\u2502   \u251c\u2500\u2500 Season 1/\n\u2502   \u2502   \u251c\u2500\u2500 episode1.mkv\n\u2502   \u2502   \u251c\u2500\u2500 episode2.mkv\n\u2502   \u2502   \u2514\u2500\u2500 episode3.mkv\n\u2502   \u2514\u2500\u2500 Season 2/\n\u2502       \u251c\u2500\u2500 episode1.mkv\n\u2502       \u2514\u2500\u2500 episode2.mkv\n\u2514\u2500\u2500 Another Show/\n    \u2514\u2500\u2500 Season 1/\n        \u2514\u2500\u2500 episode.mkv\n</code></pre></p>"},{"location":"quickstart/#configuration","title":"\u2699\ufe0f Configuration","text":"<p>Configuration is stored as JSON at <code>~/.mkv-episode-matcher/config.json</code>:</p>"},{"location":"quickstart/#gui-configuration","title":"GUI Configuration","text":"<p>Use the built-in settings dialog (\u2699\ufe0f icon) to configure: - API keys (OpenSubtitles, TMDb) - Cache directory and confidence thresholds - ASR and subtitle provider settings</p>"},{"location":"quickstart/#cli-configuration","title":"CLI Configuration","text":"<pre><code># Interactive wizard\nmkv-match config\n\n# Show current configuration\nmkv-match config --show\n\n# Set specific values\nmkv-match config --confidence 0.8 --cache-dir \"/custom/cache\"\n</code></pre>"},{"location":"quickstart/#common-use-cases","title":"\ud83d\udd27 Common Use Cases","text":""},{"location":"quickstart/#first-time-setup","title":"First Time Setup","text":"<pre><code># Option 1: GUI (easiest)\nmkv-match gui\n\n# Option 2: CLI configuration\nmkv-match config --interactive\n</code></pre>"},{"location":"quickstart/#processing-content","title":"Processing Content","text":"<pre><code># GUI: Select folder and click \"Start Processing\"\nmkv-match gui\n\n# CLI: Process season with subtitle downloads\nmkv-match match \"/path/to/Show/Season 1/\" --get-subs\n\n# CLI: Dry run with specific confidence\nmkv-match match \"/path/to/show/\" --dry-run --confidence 0.8\n</code></pre>"},{"location":"quickstart/#automation","title":"Automation","text":"<pre><code># JSON output for scripts\nmkv-match match \"/path/to/library/\" --json --output-dir \"/processed/\"\n\n# Batch processing with logging\nmkv-match match \"/path/to/library/\" --get-subs --verbose\n</code></pre>"},{"location":"quickstart/#next-steps","title":"\ud83d\udcda Next Steps","text":"<ul> <li>Read Installation Guide for setup details</li> <li>Check CLI Reference for complete command documentation</li> <li>See Tips and Tricks for performance optimization</li> <li>Visit Configuration Guide for advanced settings</li> </ul>"},{"location":"tips/","title":"Tips and Tricks","text":"<p>Essential tips for getting the most out of MKV Episode Matcher v1.0.0.</p>"},{"location":"tips/#best-practices","title":"\ud83c\udfaf Best Practices","text":""},{"location":"tips/#directory-organization","title":"Directory Organization","text":"<p>Organize your files consistently for optimal results: <pre><code>TV Shows/\n\u251c\u2500\u2500 Show Name/\n\u2502   \u251c\u2500\u2500 Season 1/\n\u2502   \u2502   \u251c\u2500\u2500 episode1.mkv\n\u2502   \u2502   \u2514\u2500\u2500 episode2.mkv\n\u2502   \u2514\u2500\u2500 Season 2/\n\u2502       \u251c\u2500\u2500 episode1.mkv\n\u2502       \u2514\u2500\u2500 episode2.mkv\n</code></pre></p> <p>Supported patterns: - <code>Show Name/Season X/</code> - Standard Plex structure - <code>Show Name/S01/</code> - Short season format - <code>Show Name/Series 1/</code> - BBC/UK format</p>"},{"location":"tips/#performance-optimization","title":"\u26a1 Performance Optimization","text":""},{"location":"tips/#batch-processing-critical","title":"\ud83d\udd25 Batch Processing (CRITICAL)","text":"<p>DO THIS: Process entire folders at once <pre><code># \u2705 EFFICIENT: Model loads once for entire season\nmkv-match match \"/path/to/Show/Season 1/\"\n\n# \u2705 EVEN BETTER: Process entire show\nmkv-match match \"/path/to/Show/\"\n\n# \u2705 BEST: Process library with subtitles\nmkv-match match \"/path/to/library/\" --get-subs\n</code></pre></p> <p>DON'T DO THIS: Process files individually <pre><code># \u274c INEFFICIENT: Parakeet model reloads for each file (30-60s each)\nmkv-match match \"/path/to/episode1.mkv\"\nmkv-match match \"/path/to/episode2.mkv\"\nmkv-match match \"/path/to/episode3.mkv\"\n</code></pre></p> <p>Why batch processing matters: - Parakeet ASR model takes 30-60 seconds to initialize - Single initialization can process entire season - 10x faster for multi-file operations - Better memory management with bounded caching</p>"},{"location":"tips/#gpu-vs-cpu-performance","title":"GPU vs CPU Performance","text":"<p>GPU Acceleration (Recommended): <pre><code># Install with CUDA support\nuv sync --extra cu128\n\n# Verify GPU detection\nuv run python -c \"import torch; print(f'CUDA: {torch.cuda.is_available()}')\"\n</code></pre></p> <p>Performance comparison: - GPU: 5-10x faster processing - CPU: Fully functional but slower - Apple Silicon: Good CPU performance on M1/M2/M3</p>"},{"location":"tips/#model-caching","title":"Model Caching","text":"<p>The application automatically caches: - ASR models (persistent across runs) - Audio chunks (temporary during processing) - Subtitle content (session-based) - Video metadata (LRU cache)</p> <p>Cache management: <pre><code># Check cache statistics\nmkv-match config --show\n\n# Clear cache if needed\nrm -rf ~/.mkv-episode-matcher/cache/\n</code></pre></p>"},{"location":"tips/#accuracy-tuning","title":"\ud83c\udf9a\ufe0f Accuracy Tuning","text":""},{"location":"tips/#confidence-threshold","title":"Confidence Threshold","text":"<pre><code># Default: 0.8 (80% confidence)\nmkv-match match \"/path/to/show/\" --confidence 0.8\n\n# Conservative (fewer false positives)\nmkv-match match \"/path/to/show/\" --confidence 0.9\n\n# Aggressive (catch more matches, may have false positives)\nmkv-match match \"/path/to/show/\" --confidence 0.7\n</code></pre> <p>Guidelines: - Start with 0.8 (default) - Increase if getting false matches - Decrease if missing obvious matches - Range: 0.0-1.0</p>"},{"location":"tips/#multi-segment-analysis","title":"Multi-Segment Analysis","text":"<p>v1.0.0 uses enhanced matching strategy: - Primary checkpoints: 15%, 50%, 85% through video - Fallback checkpoints: 25%, 35%, 65%, 75% - Smart termination: Stops at first confident match - Empty segment handling: Automatic fallback to additional segments</p>"},{"location":"tips/#interface-tips","title":"\ud83d\udda5\ufe0f Interface Tips","text":""},{"location":"tips/#gui-mode-best-practices","title":"GUI Mode Best Practices","text":"<p>First-Time Setup: 1. Launch: <code>mkv-match gui</code> 2. Configure settings (\u2699\ufe0f icon) before processing 3. Test with dry run on small folder first 4. Use folder picker for easy navigation</p> <p>Efficient Workflow: 1. Configure API keys once 2. Select library/show folder 3. Enable \"Get Subtitles\" for automatic downloads 4. Use dry run to preview changes 5. Process entire library in one operation</p>"},{"location":"tips/#cli-mode-best-practices","title":"CLI Mode Best Practices","text":"<p>Interactive Configuration: <pre><code># One-time setup\nmkv-match config\n\n# Verify configuration  \nmkv-match config --show\n</code></pre></p> <p>Production Usage: <pre><code># Process with progress tracking\nmkv-match match \"/path/to/library/\" --get-subs --verbose\n\n# JSON output for automation\nmkv-match match \"/path/to/library/\" --json &gt; results.json\n\n# Copy instead of rename\nmkv-match match \"/path/to/show/\" --output-dir \"/processed/\"\n</code></pre></p>"},{"location":"tips/#advanced-usage","title":"\ud83d\udd27 Advanced Usage","text":""},{"location":"tips/#testing-and-validation","title":"Testing and Validation","text":"<p>Always dry run first: <pre><code># Preview changes without modifying files\nmkv-match match \"/path/to/show/\" --dry-run\n</code></pre></p> <p>Staged processing: <pre><code># Test on single season first\nmkv-match match \"/path/to/Show/Season 1/\" --dry-run\n\n# Process season after validation\nmkv-match match \"/path/to/Show/Season 1/\" --get-subs\n\n# Scale to full show\nmkv-match match \"/path/to/Show/\" --get-subs\n</code></pre></p>"},{"location":"tips/#automation-and-scripting","title":"Automation and Scripting","text":"<p>Batch processing multiple shows: <pre><code>#!/bin/bash\nfor show in \"/media/TV Shows\"/*/; do\n    echo \"Processing: $show\"\n    mkv-match match \"$show\" --get-subs --confidence 0.85\ndone\n</code></pre></p> <p>JSON output for integration: <pre><code># Process and capture results\nmkv-match match \"/path/to/show/\" --json &gt; results.json\n\n# Parse results with jq\njq '.[] | select(.confidence &gt; 0.9)' results.json\n</code></pre></p>"},{"location":"tips/#debug-and-logging","title":"Debug and Logging","text":"<p>Verbose output: <pre><code># Detailed processing information\nmkv-match match \"/path/to/show/\" --verbose\n\n# Debug mode (even more detail)\nmkv-match match \"/path/to/show/\" --verbose --confidence 0.7\n</code></pre></p> <p>Log locations: <pre><code>~/.mkv-episode-matcher/\n\u251c\u2500\u2500 logs/\n\u2502   \u251c\u2500\u2500 application.log    # General operations\n\u2502   \u2514\u2500\u2500 errors.log         # Error details\n\u251c\u2500\u2500 cache/                 # Model and data cache\n\u2514\u2500\u2500 config.json           # User configuration\n</code></pre></p>"},{"location":"tips/#troubleshooting","title":"\ud83d\udea8 Troubleshooting","text":""},{"location":"tips/#common-issues-and-solutions","title":"Common Issues and Solutions","text":""},{"location":"tips/#performance-issues","title":"Performance Issues","text":"<p>Slow Processing: 1. \u2705 Use batch processing (process folders, not individual files) 2. \u2705 Enable GPU acceleration if available 3. \u2705 Ensure sufficient RAM (8GB+ recommended) 4. \u2705 Check disk space (5GB+ for model cache)</p> <p>Model Loading Delays: - First run takes longer (downloads models) - Subsequent runs are faster (cached models) - GPU significantly faster than CPU</p>"},{"location":"tips/#matching-issues","title":"Matching Issues","text":"<p>No Matches Found: 1. Check subtitle availability: <code>--get-subs</code> 2. Lower confidence threshold: <code>--confidence 0.7</code> 3. Verify file structure matches expected pattern 4. Review logs for specific error details</p> <p>False Matches: 1. Increase confidence threshold: <code>--confidence 0.9</code> 2. Check subtitle quality/language 3. Verify show name detection 4. Use dry run to validate before processing</p> <p>Already Processed Files: - Files with S##E## patterns are automatically skipped - Use <code>--force</code> flag to reprocess if needed - Check logs for skip notifications</p>"},{"location":"tips/#configuration-problems","title":"Configuration Problems","text":"<p>API Key Issues: <pre><code># Test OpenSubtitles connection\nmkv-match config --opensub-api-key \"test_key\"\n\n# Verify TMDb connectivity\nmkv-match config --tmdb-api-key \"test_key\"\n</code></pre></p> <p>Permission Errors: <pre><code># Check file permissions\nls -la \"/path/to/videos/\"\n\n# Fix ownership if needed\nsudo chown -R $USER:$GROUP \"/path/to/videos/\"\n</code></pre></p> <p>Cache Issues: <pre><code># Clear cache and restart\nrm -rf ~/.mkv-episode-matcher/cache/\nmkv-match config --show\n</code></pre></p>"},{"location":"tips/#performance-benchmarks","title":"Performance Benchmarks","text":"<p>Typical processing times (per episode):</p> Setup Audio Extraction Speech Recognition Matching Total CPU (Intel i7) 10-15s 60-90s 2-5s ~80-110s GPU (RTX 3060) 10-15s 8-15s 2-5s ~20-35s Apple M2 Pro 8-12s 25-40s 2-5s ~35-55s <p>Optimization impact: - Batch processing: 10x improvement (avoids model reloads) - GPU acceleration: 5-8x faster speech recognition - Caching: Near-instant for repeated operations</p>"},{"location":"tips/#getting-help","title":"Getting Help","text":"<p>Before reporting issues: 1. Check existing documentation and FAQ 2. Review log files for error details 3. Test with verbose output enabled 4. Try different confidence thresholds</p> <p>Bug reports should include: - Operating system and version - GPU info (if using CUDA) - Full command and flags used - Complete error message/traceback - Relevant log file contents - Sample file names (anonymized)</p> <p>Community resources: - GitHub Discussions for questions - GitHub Issues for bugs - Documentation for guides</p>"},{"location":"api/","title":"API Reference","text":"<p>This section contains the automatically generated API documentation for MKV Episode Matcher.</p>"},{"location":"api/#core-modules","title":"Core Modules","text":""},{"location":"api/#mkv_episode_matcher.__main__","title":"mkv_episode_matcher.__main__","text":""},{"location":"api/#mkv_episode_matcher.__main__-functions","title":"Functions","text":""},{"location":"api/#mkv_episode_matcher.__main__.main","title":"main","text":"<pre><code>main()\n</code></pre> <p>Entry point for the application.</p> Source code in <code>mkv_episode_matcher/__main__.py</code> <pre><code>def main():\n    \"\"\"Entry point for the application.\"\"\"\n    # Start browser in background\n    if \"--no-browser\" not in sys.argv:\n        threading.Thread(target=open_browser, daemon=True).start()\n\n    # Run server\n    uvicorn.run(app, host=\"0.0.0.0\", port=8001)\n</code></pre>"},{"location":"api/#mkv_episode_matcher.cli","title":"mkv_episode_matcher.cli","text":"<p>Unified CLI Interface for MKV Episode Matcher V2</p> <p>This module provides a single, intuitive command-line interface that handles all use cases with intelligent auto-detection and minimal configuration.</p>"},{"location":"api/#mkv_episode_matcher.cli-functions","title":"Functions","text":""},{"location":"api/#mkv_episode_matcher.cli.print_banner","title":"print_banner","text":"<pre><code>print_banner()\n</code></pre> <p>Print application banner.</p> Source code in <code>mkv_episode_matcher/cli.py</code> <pre><code>def print_banner():\n    \"\"\"Print application banner.\"\"\"\n    banner = Text(\"MKV Episode Matcher\", style=\"bold blue\")\n    console.print(\n        Panel(banner, subtitle=\"Intelligent episode matching with zero-config setup\")\n    )\n</code></pre>"},{"location":"api/#mkv_episode_matcher.cli.match","title":"match","text":"<pre><code>match(\n    path=typer.Argument(\n        ...,\n        help=\"Path to MKV file, series folder, or entire library\",\n        exists=True,\n    ),\n    season=typer.Option(\n        None,\n        \"--season\",\n        \"-s\",\n        help=\"Override season number for all files\",\n    ),\n    recursive=typer.Option(\n        True,\n        \"--recursive/--no-recursive\",\n        \"-r/-nr\",\n        help=\"Search recursively in directories\",\n    ),\n    dry_run=typer.Option(\n        False,\n        \"--dry-run\",\n        \"-d\",\n        help=\"Preview changes without renaming files\",\n    ),\n    output_dir=typer.Option(\n        None,\n        \"--output-dir\",\n        \"-o\",\n        help=\"Copy renamed files to this directory instead of renaming in place\",\n    ),\n    json_output=typer.Option(\n        False,\n        \"--json\",\n        help=\"Output results in JSON format for automation\",\n    ),\n    confidence_threshold=typer.Option(\n        None,\n        \"--confidence\",\n        \"-c\",\n        min=0.0,\n        max=1.0,\n        help=\"Minimum confidence score for matches (0.0-1.0)\",\n    ),\n    download_subs=typer.Option(\n        True,\n        \"--download-subs/--no-download-subs\",\n        help=\"Automatically download subtitles if not found locally\",\n    ),\n    tmdb_id=typer.Option(\n        None,\n        \"--tmdb-id\",\n        help=\"Manually specify the TMDB Show ID (e.g. 549 for Law &amp; Order)\",\n    ),\n    log_level=typer.Option(\n        \"INFO\",\n        \"--log-level\",\n        \"-l\",\n        help=\"Set logging level (DEBUG, INFO, WARNING, ERROR, CRITICAL)\",\n        case_sensitive=False,\n    ),\n)\n</code></pre> <p>Process MKV files with intelligent episode matching.</p> <p>Automatically detects whether you're processing: \u2022 A single file \u2022 A series folder \u2022 An entire library</p> <p>Examples:</p> <pre><code># Process a single file\nmkv-match episode.mkv\n\n# Process a series season\nmkv-match \"/media/Breaking Bad/Season 1/\"\n\n# Process entire library\nmkv-match /media/tv-shows/ --recursive\n\n# Dry run with custom output\nmkv-match episode.mkv --dry-run --output-dir ./renamed/\n\n# Automation mode\nmkv-match show/ --json --confidence 0.8\n</code></pre> Source code in <code>mkv_episode_matcher/cli.py</code> <pre><code>@app.command()\ndef match(\n    path: Path = typer.Argument(\n        ..., help=\"Path to MKV file, series folder, or entire library\", exists=True\n    ),\n    # Core options\n    season: int | None = typer.Option(\n        None, \"--season\", \"-s\", help=\"Override season number for all files\"\n    ),\n    recursive: bool = typer.Option(\n        True,\n        \"--recursive/--no-recursive\",\n        \"-r/-nr\",\n        help=\"Search recursively in directories\",\n    ),\n    dry_run: bool = typer.Option(\n        False, \"--dry-run\", \"-d\", help=\"Preview changes without renaming files\"\n    ),\n    # Output options\n    output_dir: Path | None = typer.Option(\n        None,\n        \"--output-dir\",\n        \"-o\",\n        help=\"Copy renamed files to this directory instead of renaming in place\",\n    ),\n    json_output: bool = typer.Option(\n        False, \"--json\", help=\"Output results in JSON format for automation\"\n    ),\n    # Quality options\n    confidence_threshold: float | None = typer.Option(\n        None,\n        \"--confidence\",\n        \"-c\",\n        min=0.0,\n        max=1.0,\n        help=\"Minimum confidence score for matches (0.0-1.0)\",\n    ),\n    # Subtitle options\n    download_subs: bool = typer.Option(\n        True,\n        \"--download-subs/--no-download-subs\",\n        help=\"Automatically download subtitles if not found locally\",\n    ),\n    # TMDB options\n    tmdb_id: int | None = typer.Option(\n        None,\n        \"--tmdb-id\",\n        help=\"Manually specify the TMDB Show ID (e.g. 549 for Law &amp; Order)\",\n    ),\n    # Logging options\n    log_level: str = typer.Option(\n        \"INFO\",\n        \"--log-level\",\n        \"-l\",\n        help=\"Set logging level (DEBUG, INFO, WARNING, ERROR, CRITICAL)\",\n        case_sensitive=False,\n    ),\n):\n    \"\"\"\n    Process MKV files with intelligent episode matching.\n\n    Automatically detects whether you're processing:\n    \u2022 A single file\n    \u2022 A series folder\n    \u2022 An entire library\n\n    Examples:\n\n        # Process a single file\n        mkv-match episode.mkv\n\n        # Process a series season\n        mkv-match \"/media/Breaking Bad/Season 1/\"\n\n        # Process entire library\n        mkv-match /media/tv-shows/ --recursive\n\n        # Dry run with custom output\n        mkv-match episode.mkv --dry-run --output-dir ./renamed/\n\n        # Automation mode\n        mkv-match show/ --json --confidence 0.8\n    \"\"\"\n\n    # Configure logging level\n    log_level = log_level.upper()\n    valid_levels = [\"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\", \"CRITICAL\"]\n    if log_level not in valid_levels:\n        console.print(f\"[red]Invalid log level: {log_level}. Must be one of {', '.join(valid_levels)}[/red]\")\n        sys.exit(1)\n\n    logger.remove()\n    logger.add(sys.stderr, level=log_level)\n\n    if not json_output:\n        print_banner()\n\n    # Load configuration\n    try:\n        cm = get_config_manager()\n        config = cm.load()\n\n        # Override config with CLI options\n        if confidence_threshold is not None:\n            config.min_confidence = confidence_threshold\n\n        if not download_subs:\n            config.sub_provider = \"local\"\n\n    except Exception as e:\n        if json_output:\n            print(json.dumps({\"error\": f\"Configuration error: {e}\"}))\n        else:\n            console.print(f\"[red]Configuration error: {e}[/red]\")\n        sys.exit(1)\n\n    # Initialize engine\n    try:\n        engine = MatchEngineV2(config)\n    except Exception as e:\n        if json_output:\n            print(json.dumps({\"error\": f\"Engine initialization failed: {e}\"}))\n        else:\n            console.print(f\"[red]Failed to initialize engine: {e}[/red]\")\n        sys.exit(1)\n\n    # Detect processing mode\n    if path.is_file():\n        mode = \"single_file\"\n    elif path.is_dir():\n        # Count MKV files to determine if it's a series or library\n        mkv_count = len(list(path.rglob(\"*.mkv\") if recursive else path.glob(\"*.mkv\")))\n        if mkv_count == 0:\n            if json_output:\n                print(json.dumps({\"error\": \"No MKV files found\"}))\n            else:\n                console.print(\"[yellow]No MKV files found[/yellow]\")\n            sys.exit(0)\n        elif mkv_count &lt;= 30:  # Arbitrary threshold\n            mode = \"series_folder\"\n        else:\n            mode = \"library\"\n    else:\n        if json_output:\n            print(json.dumps({\"error\": \"Invalid path\"}))\n        else:\n            console.print(\"[red]Invalid path[/red]\")\n        sys.exit(1)\n\n    if not json_output:\n        mode_descriptions = {\n            \"single_file\": \"Processing single file\",\n            \"series_folder\": \"Processing series folder\",\n            \"library\": \"Processing entire library\",\n        }\n        console.print(f\"[blue]{mode_descriptions[mode]}[/blue]: {path}\")\n\n        if dry_run:\n            console.print(\"[yellow]DRY RUN MODE - No files will be renamed[/yellow]\")\n\n    # Process files\n    try:\n        results, failures = engine.process_path(\n            path=path,\n            season_override=season,\n            recursive=recursive,\n            dry_run=dry_run,\n            output_dir=output_dir,\n            json_output=json_output,\n            confidence_threshold=confidence_threshold,\n            tmdb_id=tmdb_id,\n        )\n\n        # Output results\n        if json_output:\n            output_data = {\n                \"mode\": mode,\n                \"path\": str(path),\n                \"total_matches\": len(results),\n                \"total_failures\": len(failures),\n                \"dry_run\": dry_run,\n                \"results\": json.loads(engine.export_results(results)),\n                \"failures\": [\n                    {\n                        \"original_file\": str(f.original_file),\n                        \"reason\": f.reason,\n                        \"confidence\": f.confidence,\n                    }\n                    for f in failures\n                ],\n            }\n            print(json.dumps(output_data, indent=2))\n        else:\n            # Rich console summary\n            if results or failures:\n                _display_comprehensive_summary(\n                    results, failures, dry_run, output_dir, console\n                )\n            else:\n                console.print(\"[yellow]No MKV files processed[/yellow]\")\n\n    except Exception as e:\n        if json_output:\n            print(json.dumps({\"error\": f\"Processing failed: {e}\"}))\n        else:\n            console.print(f\"[red]Processing failed: {e}[/red]\")\n        sys.exit(1)\n</code></pre>"},{"location":"api/#mkv_episode_matcher.cli.config","title":"config","text":"<pre><code>config(\n    show_cache_dir=typer.Option(\n        False,\n        \"--show-cache-dir\",\n        help=\"Show current cache directory location\",\n    ),\n    reset=typer.Option(\n        False,\n        \"--reset\",\n        help=\"Reset configuration to defaults\",\n    ),\n)\n</code></pre> <p>Configure MKV Episode Matcher settings.</p> <p>Most settings are auto-configured, but you can customize: \u2022 Cache directory location \u2022 Default confidence thresholds \u2022 ASR model preferences</p> Source code in <code>mkv_episode_matcher/cli.py</code> <pre><code>@app.command()\ndef config(\n    show_cache_dir: bool = typer.Option(\n        False, \"--show-cache-dir\", help=\"Show current cache directory location\"\n    ),\n    reset: bool = typer.Option(\n        False, \"--reset\", help=\"Reset configuration to defaults\"\n    ),\n):\n    \"\"\"\n    Configure MKV Episode Matcher settings.\n\n    Most settings are auto-configured, but you can customize:\n    \u2022 Cache directory location\n    \u2022 Default confidence thresholds\n    \u2022 ASR model preferences\n    \"\"\"\n\n    cm = get_config_manager()\n\n    if show_cache_dir:\n        config = cm.load()\n        console.print(f\"Cache directory: [blue]{config.cache_dir}[/blue]\")\n        return\n\n    if reset:\n        config = Config()  # Default config\n        cm.save(config)\n        console.print(\"[green]Configuration reset to defaults[/green]\")\n        return\n\n    # Interactive configuration\n    console.print(Panel(\"MKV Episode Matcher Configuration\"))\n\n    config = cm.load()\n\n    # Cache directory\n    current_cache = str(config.cache_dir)\n    new_cache = typer.prompt(\n        \"Cache directory\", default=current_cache, show_default=True\n    )\n    if new_cache != current_cache:\n        config.cache_dir = Path(new_cache)\n\n    # Confidence threshold\n    current_confidence = config.min_confidence\n    new_confidence = typer.prompt(\n        \"Minimum confidence threshold (0.0-1.0)\",\n        type=float,\n        default=current_confidence,\n        show_default=True,\n    )\n    if 0.0 &lt;= new_confidence &lt;= 1.0:\n        config.min_confidence = new_confidence\n\n    # ASR provider\n    current_asr = config.asr_provider\n    new_asr = typer.prompt(\n        \"ASR provider (parakeet)\",\n        default=current_asr,\n        show_default=True,\n    )\n    if new_asr in [\"parakeet\"]:\n        config.asr_provider = new_asr\n\n    # Subtitle provider\n    current_sub = config.sub_provider\n    new_sub = typer.prompt(\n        \"Subtitle provider (local/opensubtitles)\",\n        default=current_sub,\n        show_default=True,\n    )\n    if new_sub in [\"local\", \"opensubtitles\"]:\n        config.sub_provider = new_sub\n\n    # OpenSubtitles config\n    if config.sub_provider == \"opensubtitles\":\n        console.print(\"\\n[bold]OpenSubtitles Configuration:[/bold]\")\n\n        current_api = config.open_subtitles_api_key or \"\"\n        new_api = typer.prompt(\"API Key\", default=current_api, show_default=True)\n        if new_api.strip():\n            config.open_subtitles_api_key = new_api.strip()\n\n        current_user = config.open_subtitles_username or \"\"\n        new_user = typer.prompt(\"Username\", default=current_user, show_default=True)\n        if new_user.strip():\n            config.open_subtitles_username = new_user.strip()\n\n        current_pass = config.open_subtitles_password or \"\"\n        new_pass = typer.prompt(\n            \"Password\", default=current_pass, show_default=False, hide_input=True\n        )\n        if new_pass.strip():\n            config.open_subtitles_password = new_pass.strip()\n\n    # TMDB API key (optional)\n    current_tmdb = config.tmdb_api_key or \"\"\n    new_tmdb = typer.prompt(\n        \"TMDb API key (optional, for episode titles)\",\n        default=current_tmdb,\n        show_default=False,\n    )\n    if new_tmdb.strip():\n        config.tmdb_api_key = new_tmdb.strip()\n\n    # Save configuration\n    cm.save(config)\n    console.print(\"[green]Configuration saved successfully[/green]\")\n</code></pre>"},{"location":"api/#mkv_episode_matcher.cli.info","title":"info","text":"<pre><code>info()\n</code></pre> <p>Show system information and available models.</p> Source code in <code>mkv_episode_matcher/cli.py</code> <pre><code>@app.command()\ndef info():\n    \"\"\"\n    Show system information and available models.\n    \"\"\"\n    console.print(Panel(\"MKV Episode Matcher - System Information\"))\n\n    try:\n        from mkv_episode_matcher.asr_models import list_available_models\n\n        models = list_available_models()\n\n        console.print(\"\\n[bold]Available ASR Models:[/bold]\")\n        for model_type, info in models.items():\n            if info.get(\"available\"):\n                status = \"[green]Available[/green]\"\n                model_list = \", \".join(info.get(\"models\", [])[:3])  # Show first 3\n                console.print(f\"  {model_type}: {status}\")\n                console.print(f\"    Models: {model_list}\")\n            else:\n                status = \"[red]Not available[/red]\"\n                error = info.get(\"error\", \"Unknown error\")\n                console.print(f\"  {model_type}: {status} ({error})\")\n\n    except Exception as e:\n        console.print(f\"[red]Error checking models: {e}[/red]\")\n\n    # Configuration info\n    try:\n        cm = get_config_manager()\n        config = cm.load()\n\n        console.print(\"\\n[bold]Current Configuration:[/bold]\")\n        console.print(f\"  Cache directory: {config.cache_dir}\")\n        console.print(f\"  ASR provider: {config.asr_provider}\")\n        console.print(f\"  Subtitle provider: {config.sub_provider}\")\n        console.print(f\"  Confidence threshold: {config.min_confidence}\")\n\n    except Exception as e:\n        console.print(f\"[red]Error loading config: {e}[/red]\")\n</code></pre>"},{"location":"api/#mkv_episode_matcher.cli.version","title":"version","text":"<pre><code>version()\n</code></pre> <p>Show version information.</p> Source code in <code>mkv_episode_matcher/cli.py</code> <pre><code>@app.command()\ndef version():\n    \"\"\"Show version information.\"\"\"\n    try:\n        import mkv_episode_matcher\n\n        version = mkv_episode_matcher.__version__\n    except AttributeError:\n        version = \"unknown\"\n\n    console.print(f\"MKV Episode Matcher v{version}\")\n</code></pre>"},{"location":"api/#mkv_episode_matcher.cli.gui","title":"gui","text":"<pre><code>gui()\n</code></pre> <p>Launch the GUI application.</p> Source code in <code>mkv_episode_matcher/cli.py</code> <pre><code>@app.command()\ndef gui():\n    \"\"\"Launch the GUI application.\"\"\"\n    from mkv_episode_matcher.ui.gui import main\n\n    main()\n</code></pre>"},{"location":"api/#mkv_episode_matcher.episode_identification","title":"mkv_episode_matcher.episode_identification","text":""},{"location":"api/#mkv_episode_matcher.episode_identification-classes","title":"Classes","text":""},{"location":"api/#mkv_episode_matcher.episode_identification.SubtitleCache","title":"SubtitleCache","text":"<pre><code>SubtitleCache()\n</code></pre> <p>Cache for storing parsed subtitle data to avoid repeated loading and parsing.</p> Source code in <code>mkv_episode_matcher/episode_identification.py</code> <pre><code>def __init__(self):\n    self.subtitles = {}  # {file_path: parsed_content}\n    self.chunk_cache = {}  # {(file_path, chunk_idx): text}\n</code></pre>"},{"location":"api/#mkv_episode_matcher.episode_identification.SubtitleCache-functions","title":"Functions","text":""},{"location":"api/#mkv_episode_matcher.episode_identification.SubtitleCache.get_subtitle_content","title":"get_subtitle_content","text":"<pre><code>get_subtitle_content(srt_file)\n</code></pre> <p>Get the full content of a subtitle file, loading it only once.</p> Source code in <code>mkv_episode_matcher/episode_identification.py</code> <pre><code>def get_subtitle_content(self, srt_file):\n    \"\"\"Get the full content of a subtitle file, loading it only once.\"\"\"\n    srt_file = str(srt_file)\n    if srt_file not in self.subtitles:\n        reader = SubtitleReader()\n        self.subtitles[srt_file] = reader.read_srt_file(srt_file)\n    return self.subtitles[srt_file]\n</code></pre>"},{"location":"api/#mkv_episode_matcher.episode_identification.SubtitleCache.get_chunk","title":"get_chunk","text":"<pre><code>get_chunk(srt_file, chunk_idx, chunk_start, chunk_end)\n</code></pre> <p>Get a specific time chunk from a subtitle file, with caching.</p> Source code in <code>mkv_episode_matcher/episode_identification.py</code> <pre><code>def get_chunk(self, srt_file, chunk_idx, chunk_start, chunk_end):\n    \"\"\"Get a specific time chunk from a subtitle file, with caching.\"\"\"\n    srt_file = str(srt_file)\n    cache_key = (srt_file, chunk_idx)\n\n    if cache_key not in self.chunk_cache:\n        content = self.get_subtitle_content(srt_file)\n        reader = SubtitleReader()\n        text_lines = reader.extract_subtitle_chunk(content, chunk_start, chunk_end)\n        self.chunk_cache[cache_key] = \" \".join(text_lines)\n\n    return self.chunk_cache[cache_key]\n</code></pre>"},{"location":"api/#mkv_episode_matcher.episode_identification.EpisodeMatcher","title":"EpisodeMatcher","text":"<pre><code>EpisodeMatcher(\n    cache_dir, show_name, min_confidence=0.6, device=None\n)\n</code></pre> Source code in <code>mkv_episode_matcher/episode_identification.py</code> <pre><code>def __init__(self, cache_dir, show_name, min_confidence=0.6, device=None):\n    self.cache_dir = Path(cache_dir)\n    self.min_confidence = min_confidence\n    self.show_name = show_name\n    self.chunk_duration = 30\n    self.skip_initial_duration = 300\n    self.device = device or (\"cuda\" if torch.cuda.is_available() else \"cpu\")\n    self.temp_dir = Path(tempfile.gettempdir()) / \"whisper_chunks\"\n    self.temp_dir.mkdir(exist_ok=True)\n    # Initialize subtitle cache\n    self.subtitle_cache = SubtitleCache()\n    # Cache for extracted audio chunks\n    self.audio_chunks = {}\n    # Store reference files to avoid repeated glob operations\n    self.reference_files_cache = {}\n</code></pre>"},{"location":"api/#mkv_episode_matcher.episode_identification.EpisodeMatcher-functions","title":"Functions","text":""},{"location":"api/#mkv_episode_matcher.episode_identification.EpisodeMatcher.extract_audio_chunk","title":"extract_audio_chunk","text":"<pre><code>extract_audio_chunk(mkv_file, start_time)\n</code></pre> <p>Extract a chunk of audio from MKV file with caching.</p> Source code in <code>mkv_episode_matcher/episode_identification.py</code> <pre><code>def extract_audio_chunk(self, mkv_file, start_time):\n    \"\"\"Extract a chunk of audio from MKV file with caching.\"\"\"\n    cache_key = (str(mkv_file), start_time)\n\n    if cache_key in self.audio_chunks:\n        return self.audio_chunks[cache_key]\n\n    chunk_path = self.temp_dir / f\"chunk_{start_time}.wav\"\n    if not chunk_path.exists():\n        cmd = [\n            \"ffmpeg\",\n            \"-ss\",\n            str(start_time),\n            \"-t\",\n            str(self.chunk_duration),\n            \"-i\",\n            str(mkv_file),\n            \"-vn\",  # Disable video\n            \"-sn\",  # Disable subtitles\n            \"-dn\",  # Disable data streams\n            \"-acodec\",\n            \"pcm_s16le\",\n            \"-ar\",\n            \"16000\",\n            \"-ac\",\n            \"1\",\n            \"-y\",  # Overwrite output files without asking\n            str(chunk_path),\n        ]\n\n        try:\n            logger.debug(\n                f\"Extracting audio chunk from {mkv_file} at {start_time}s using FFmpeg\"\n            )\n            result = subprocess.run(cmd, capture_output=True, text=True, timeout=30)\n\n            if result.returncode != 0:\n                error_msg = f\"FFmpeg failed with return code {result.returncode}\"\n                if result.stderr:\n                    error_msg += f\". Error: {result.stderr.strip()}\"\n                logger.error(error_msg)\n                logger.debug(f\"FFmpeg command: {' '.join(cmd)}\")\n                raise RuntimeError(error_msg)\n\n            # Check if the output file was actually created and has content\n            if not chunk_path.exists():\n                error_msg = f\"FFmpeg completed but output file was not created: {chunk_path}\"\n                logger.error(error_msg)\n                raise RuntimeError(error_msg)\n\n            # Check if the file has meaningful content (at least 1KB)\n            if chunk_path.stat().st_size &lt; 1024:\n                error_msg = f\"Generated audio chunk is too small ({chunk_path.stat().st_size} bytes), likely corrupted\"\n                logger.warning(error_msg)\n                # Don't raise an error for small files, but log the warning\n\n            logger.debug(\n                f\"Successfully extracted {chunk_path.stat().st_size} byte audio chunk\"\n            )\n\n        except subprocess.TimeoutExpired as e:\n            error_msg = f\"FFmpeg timed out after 30 seconds while extracting audio from {mkv_file}\"\n            logger.error(error_msg)\n            raise RuntimeError(error_msg) from e\n\n        except Exception as e:\n            error_msg = f\"Failed to extract audio chunk from {mkv_file} at {start_time}s: {str(e)}\"\n            logger.error(error_msg)\n            # Clean up partial file if it exists\n            if chunk_path.exists():\n                try:\n                    chunk_path.unlink()\n                except Exception as cleanup_error:\n                    logger.warning(\n                        f\"Failed to clean up partial file {chunk_path}: {cleanup_error}\"\n                    )\n            raise RuntimeError(error_msg) from e\n\n    chunk_path_str = str(chunk_path)\n    self.audio_chunks[cache_key] = chunk_path_str\n    return chunk_path_str\n</code></pre>"},{"location":"api/#mkv_episode_matcher.episode_identification.EpisodeMatcher.load_reference_chunk","title":"load_reference_chunk","text":"<pre><code>load_reference_chunk(srt_file, chunk_idx)\n</code></pre> <p>Load reference subtitles for a specific time chunk with caching.</p> PARAMETER DESCRIPTION <code>srt_file</code> <p>Path to the SRT file</p> <p> TYPE: <code>str or Path</code> </p> <code>chunk_idx</code> <p>Index of the chunk to load</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>str</code> <p>Combined text from the subtitle chunk</p> Source code in <code>mkv_episode_matcher/episode_identification.py</code> <pre><code>def load_reference_chunk(self, srt_file, chunk_idx):\n    \"\"\"\n    Load reference subtitles for a specific time chunk with caching.\n\n    Args:\n        srt_file (str or Path): Path to the SRT file\n        chunk_idx (int): Index of the chunk to load\n\n    Returns:\n        str: Combined text from the subtitle chunk\n    \"\"\"\n    try:\n        # Apply the same offset as in _try_match_with_model\n        chunk_start = self.skip_initial_duration + (chunk_idx * self.chunk_duration)\n        chunk_end = chunk_start + self.chunk_duration\n\n        return self.subtitle_cache.get_chunk(\n            srt_file, chunk_idx, chunk_start, chunk_end\n        )\n\n    except Exception as e:\n        logger.error(f\"Error loading reference chunk from {srt_file}: {e}\")\n        return \"\"\n</code></pre>"},{"location":"api/#mkv_episode_matcher.episode_identification.EpisodeMatcher.get_reference_files","title":"get_reference_files","text":"<pre><code>get_reference_files(season_number)\n</code></pre> <p>Get reference subtitle files with caching.</p> Source code in <code>mkv_episode_matcher/episode_identification.py</code> <pre><code>def get_reference_files(self, season_number):\n    \"\"\"Get reference subtitle files with caching.\"\"\"\n    cache_key = (self.show_name, season_number)\n    logger.debug(f\"Reference cache key: {cache_key}\")\n\n    if cache_key in self.reference_files_cache:\n        logger.debug(\"Returning cached reference files\")\n        return self.reference_files_cache[cache_key]\n\n    reference_dir = self.cache_dir / \"data\" / self.show_name\n    patterns = [\n        f\"S{season_number:02d}E\",\n        f\"S{season_number}E\",\n        f\"{season_number:02d}x\",\n        f\"{season_number}x\",\n    ]\n\n    reference_files = []\n    for pattern in patterns:\n        # Use case-insensitive file extension matching by checking both .srt and .SRT\n        srt_files = list(reference_dir.glob(\"*.srt\")) + list(\n            reference_dir.glob(\"*.SRT\")\n        )\n        files = [\n            f\n            for f in srt_files\n            if re.search(f\"{pattern}\\\\d+\", f.name, re.IGNORECASE)\n        ]\n        reference_files.extend(files)\n\n    # Remove duplicates while preserving order\n    reference_files = list(dict.fromkeys(reference_files))\n    logger.debug(\n        f\"Found {len(reference_files)} reference files for season {season_number}\"\n    )\n    self.reference_files_cache[cache_key] = reference_files\n    return reference_files\n</code></pre>"},{"location":"api/#mkv_episode_matcher.episode_identification.EpisodeMatcher.identify_episode","title":"identify_episode","text":"<pre><code>identify_episode(video_file, temp_dir, season_number)\n</code></pre> <p>Progressive episode identification with faster initial attempt.</p> Source code in <code>mkv_episode_matcher/episode_identification.py</code> <pre><code>def identify_episode(self, video_file, temp_dir, season_number):\n    \"\"\"Progressive episode identification with faster initial attempt.\"\"\"\n    try:\n        # Get reference files first with caching\n        reference_files = self.get_reference_files(season_number)\n\n        if not reference_files:\n            logger.error(f\"No reference files found for season {season_number}\")\n            return None\n\n        # Cache video duration\n        try:\n            duration = get_video_duration(video_file)\n        except Exception as e:\n            logger.error(f\"Failed to get video duration for {video_file}: {e}\")\n            return None\n\n        # Try with Parakeet CTC model\n        logger.info(\"Attempting match with Parakeet CTC model...\")\n        try:\n            match = self._try_match_with_model(\n                video_file,\n                {\n                    \"type\": \"parakeet\",\n                    \"name\": \"nvidia/parakeet-ctc-0.6b\",\n                    \"device\": self.device,\n                },\n                min(duration, 600),  # Allow up to 10 minutes\n                reference_files,\n            )\n            if match:\n                logger.info(\n                    f\"Successfully matched with Parakeet CTC model at {match['matched_at']}s (confidence: {match['confidence']:.2f})\"\n                )\n                return match\n        except Exception as e:\n            logger.warning(f\"Parakeet CTC model failed: {e}\")\n\n        logger.info(\n            \"Speech recognition match failed - no models were able to process this file\"\n        )\n        return None\n\n    except Exception as e:\n        logger.error(\n            f\"Unexpected error during episode identification for {video_file}: {e}\"\n        )\n        return None\n\n    finally:\n        # Cleanup temp files - keep this limited to only files we know we created\n        for chunk_info in self.audio_chunks.values():\n            try:\n                Path(chunk_info).unlink(missing_ok=True)\n            except Exception as e:\n                logger.warning(f\"Failed to delete temp file {chunk_info}: {e}\")\n</code></pre>"},{"location":"api/#mkv_episode_matcher.episode_identification.SubtitleReader","title":"SubtitleReader","text":"<p>Helper class for reading and parsing subtitle files.</p>"},{"location":"api/#mkv_episode_matcher.episode_identification.SubtitleReader-functions","title":"Functions","text":""},{"location":"api/#mkv_episode_matcher.episode_identification.SubtitleReader.parse_timestamp","title":"parse_timestamp  <code>staticmethod</code>","text":"<pre><code>parse_timestamp(timestamp)\n</code></pre> <p>Parse SRT timestamp into seconds.</p> Source code in <code>mkv_episode_matcher/episode_identification.py</code> <pre><code>@staticmethod\ndef parse_timestamp(timestamp):\n    \"\"\"Parse SRT timestamp into seconds.\"\"\"\n    hours, minutes, seconds = timestamp.replace(\",\", \".\").split(\":\")\n    return float(hours) * 3600 + float(minutes) * 60 + float(seconds)\n</code></pre>"},{"location":"api/#mkv_episode_matcher.episode_identification.SubtitleReader.read_srt_file","title":"read_srt_file  <code>staticmethod</code>","text":"<pre><code>read_srt_file(file_path)\n</code></pre> <p>Read an SRT file and return its contents with robust encoding handling.</p> PARAMETER DESCRIPTION <code>file_path</code> <p>Path to the SRT file</p> <p> TYPE: <code>str or Path</code> </p> RETURNS DESCRIPTION <code>str</code> <p>Contents of the SRT file</p> Source code in <code>mkv_episode_matcher/episode_identification.py</code> <pre><code>@staticmethod\ndef read_srt_file(file_path):\n    \"\"\"\n    Read an SRT file and return its contents with robust encoding handling.\n\n    Args:\n        file_path (str or Path): Path to the SRT file\n\n    Returns:\n        str: Contents of the SRT file\n    \"\"\"\n    return read_file_with_fallback(file_path)\n</code></pre>"},{"location":"api/#mkv_episode_matcher.episode_identification.SubtitleReader.extract_subtitle_chunk","title":"extract_subtitle_chunk  <code>staticmethod</code>","text":"<pre><code>extract_subtitle_chunk(content, start_time, end_time)\n</code></pre> <p>Extract subtitle text for a specific time window.</p> PARAMETER DESCRIPTION <code>content</code> <p>Full SRT file content</p> <p> TYPE: <code>str</code> </p> <code>start_time</code> <p>Chunk start time in seconds</p> <p> TYPE: <code>float</code> </p> <code>end_time</code> <p>Chunk end time in seconds</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>list</code> <p>List of subtitle texts within the time window</p> Source code in <code>mkv_episode_matcher/episode_identification.py</code> <pre><code>@staticmethod\ndef extract_subtitle_chunk(content, start_time, end_time):\n    \"\"\"\n    Extract subtitle text for a specific time window.\n\n    Args:\n        content (str): Full SRT file content\n        start_time (float): Chunk start time in seconds\n        end_time (float): Chunk end time in seconds\n\n    Returns:\n        list: List of subtitle texts within the time window\n    \"\"\"\n    text_lines = []\n\n    for block in content.strip().split(\"\\n\\n\"):\n        lines = block.split(\"\\n\")\n        if len(lines) &lt; 3 or \"--&gt;\" not in lines[1]:\n            continue\n\n        try:\n            timestamp = lines[1]\n            time_parts = timestamp.split(\" --&gt; \")\n            start_stamp = time_parts[0].strip()\n            end_stamp = time_parts[1].strip()\n\n            subtitle_start = SubtitleReader.parse_timestamp(start_stamp)\n            subtitle_end = SubtitleReader.parse_timestamp(end_stamp)\n\n            # Check if this subtitle overlaps with our chunk\n            if subtitle_end &gt;= start_time and subtitle_start &lt;= end_time:\n                text = \" \".join(lines[2:])\n                text_lines.append(text)\n\n        except (IndexError, ValueError) as e:\n            logger.warning(f\"Error parsing subtitle block: {e}\")\n            continue\n\n    return text_lines\n</code></pre>"},{"location":"api/#mkv_episode_matcher.episode_identification-functions","title":"Functions","text":""},{"location":"api/#mkv_episode_matcher.episode_identification.get_video_duration","title":"get_video_duration  <code>cached</code>","text":"<pre><code>get_video_duration(video_file)\n</code></pre> <p>Get video duration with caching and error handling.</p> Source code in <code>mkv_episode_matcher/episode_identification.py</code> <pre><code>@lru_cache(maxsize=100)\ndef get_video_duration(video_file):\n    \"\"\"Get video duration with caching and error handling.\"\"\"\n    try:\n        logger.debug(f\"Getting duration for video file: {video_file}\")\n        result = subprocess.run(\n            [\n                \"ffprobe\",\n                \"-v\",\n                \"error\",\n                \"-show_entries\",\n                \"format=duration\",\n                \"-of\",\n                \"default=noprint_wrappers=1:nokey=1\",\n                str(video_file),\n            ],\n            capture_output=True,\n            text=True,\n            timeout=10,\n        )\n\n        if result.returncode != 0:\n            error_msg = f\"ffprobe failed with return code {result.returncode}\"\n            if result.stderr:\n                error_msg += f\". Error: {result.stderr.strip()}\"\n            logger.error(error_msg)\n            raise RuntimeError(error_msg)\n\n        duration_str = result.stdout.strip()\n        if not duration_str:\n            raise RuntimeError(\"ffprobe returned empty duration\")\n\n        duration = float(duration_str)\n        if duration &lt;= 0:\n            raise RuntimeError(f\"Invalid duration: {duration}\")\n\n        result_duration = int(np.ceil(duration))\n        logger.debug(f\"Video duration: {result_duration} seconds\")\n        return result_duration\n\n    except subprocess.TimeoutExpired as e:\n        error_msg = f\"ffprobe timed out while getting duration for {video_file}\"\n        logger.error(error_msg)\n        raise RuntimeError(error_msg) from e\n    except ValueError as e:\n        error_msg = (\n            f\"Failed to parse duration from ffprobe output for {video_file}: {e}\"\n        )\n        logger.error(error_msg)\n        raise RuntimeError(error_msg) from e\n    except Exception as e:\n        error_msg = f\"Unexpected error getting video duration for {video_file}: {e}\"\n        logger.error(error_msg)\n        raise RuntimeError(error_msg) from e\n</code></pre>"},{"location":"api/#mkv_episode_matcher.episode_identification.detect_file_encoding","title":"detect_file_encoding","text":"<pre><code>detect_file_encoding(file_path)\n</code></pre> <p>Detect the encoding of a file using chardet.</p> PARAMETER DESCRIPTION <code>file_path</code> <p>Path to the file</p> <p> TYPE: <code>str or Path</code> </p> RETURNS DESCRIPTION <code>str</code> <p>Detected encoding, defaults to 'utf-8' if detection fails</p> Source code in <code>mkv_episode_matcher/episode_identification.py</code> <pre><code>def detect_file_encoding(file_path):\n    \"\"\"\n    Detect the encoding of a file using chardet.\n\n    Args:\n        file_path (str or Path): Path to the file\n\n    Returns:\n        str: Detected encoding, defaults to 'utf-8' if detection fails\n    \"\"\"\n    try:\n        with open(file_path, \"rb\") as f:\n            raw_data = f.read(\n                min(1024 * 1024, Path(file_path).stat().st_size)\n            )  # Read up to 1MB\n        result = chardet.detect(raw_data)\n        encoding = result[\"encoding\"]\n        confidence = result[\"confidence\"]\n\n        logger.debug(\n            f\"Detected encoding {encoding} with {confidence:.2%} confidence for {file_path}\"\n        )\n        return encoding if encoding else \"utf-8\"\n    except Exception as e:\n        logger.warning(f\"Error detecting encoding for {file_path}: {e}\")\n        return \"utf-8\"\n</code></pre>"},{"location":"api/#mkv_episode_matcher.episode_identification.read_file_with_fallback","title":"read_file_with_fallback  <code>cached</code>","text":"<pre><code>read_file_with_fallback(file_path, encodings=None)\n</code></pre> <p>Read a file trying multiple encodings in order of preference.</p> PARAMETER DESCRIPTION <code>file_path</code> <p>Path to the file</p> <p> TYPE: <code>str or Path</code> </p> <code>encodings</code> <p>List of encodings to try, defaults to common subtitle encodings</p> <p> TYPE: <code>list</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>str</code> <p>File contents</p> RAISES DESCRIPTION <code>ValueError</code> <p>If file cannot be read with any encoding</p> Source code in <code>mkv_episode_matcher/episode_identification.py</code> <pre><code>@lru_cache(maxsize=100)\ndef read_file_with_fallback(file_path, encodings=None):\n    \"\"\"\n    Read a file trying multiple encodings in order of preference.\n\n    Args:\n        file_path (str or Path): Path to the file\n        encodings (list): List of encodings to try, defaults to common subtitle encodings\n\n    Returns:\n        str: File contents\n\n    Raises:\n        ValueError: If file cannot be read with any encoding\n    \"\"\"\n    if encodings is None:\n        # First try detected encoding, then fallback to common subtitle encodings\n        detected = detect_file_encoding(file_path)\n        encodings = [detected, \"utf-8\", \"latin-1\", \"cp1252\", \"iso-8859-1\"]\n\n    file_path = Path(file_path)\n    errors = []\n\n    for encoding in encodings:\n        try:\n            with open(file_path, encoding=encoding) as f:\n                content = f.read()\n            logger.debug(f\"Successfully read {file_path} using {encoding} encoding\")\n            return content\n        except UnicodeDecodeError as e:\n            errors.append(f\"{encoding}: {str(e)}\")\n            continue\n\n    error_msg = f\"Failed to read {file_path} with any encoding. Errors:\\n\" + \"\\n\".join(\n        errors\n    )\n    logger.error(error_msg)\n    raise ValueError(error_msg)\n</code></pre>"},{"location":"api/#mkv_episode_matcher.asr_models","title":"mkv_episode_matcher.asr_models","text":"<p>ASR Model Abstraction Layer</p> <p>This module provides a unified interface for different Automatic Speech Recognition models, including OpenAI Whisper and NVIDIA Parakeet models.</p>"},{"location":"api/#mkv_episode_matcher.asr_models-classes","title":"Classes","text":""},{"location":"api/#mkv_episode_matcher.asr_models.ASRModel","title":"ASRModel","text":"<pre><code>ASRModel(model_name, device=None)\n</code></pre> <p>               Bases: <code>ABC</code></p> <p>Abstract base class for ASR models.</p> <p>Initialize ASR model.</p> PARAMETER DESCRIPTION <code>model_name</code> <p>Name/identifier of the model</p> <p> TYPE: <code>str</code> </p> <code>device</code> <p>Device to run on ('cpu', 'cuda', or None for auto-detect)</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> Source code in <code>mkv_episode_matcher/asr_models.py</code> <pre><code>def __init__(self, model_name: str, device: str | None = None):\n    \"\"\"\n    Initialize ASR model.\n\n    Args:\n        model_name: Name/identifier of the model\n        device: Device to run on ('cpu', 'cuda', or None for auto-detect)\n    \"\"\"\n    self.model_name = model_name\n    self.device = device or self._get_default_device()\n    self._model = None\n</code></pre>"},{"location":"api/#mkv_episode_matcher.asr_models.ASRModel-attributes","title":"Attributes","text":""},{"location":"api/#mkv_episode_matcher.asr_models.ASRModel.is_loaded","title":"is_loaded  <code>property</code>","text":"<pre><code>is_loaded\n</code></pre> <p>Check if model is loaded.</p>"},{"location":"api/#mkv_episode_matcher.asr_models.ASRModel-functions","title":"Functions","text":""},{"location":"api/#mkv_episode_matcher.asr_models.ASRModel.load","title":"load  <code>abstractmethod</code>","text":"<pre><code>load()\n</code></pre> <p>Load the model. Should be called before transcription.</p> Source code in <code>mkv_episode_matcher/asr_models.py</code> <pre><code>@abc.abstractmethod\ndef load(self):\n    \"\"\"Load the model. Should be called before transcription.\"\"\"\n    pass\n</code></pre>"},{"location":"api/#mkv_episode_matcher.asr_models.ASRModel.transcribe","title":"transcribe  <code>abstractmethod</code>","text":"<pre><code>transcribe(audio_path)\n</code></pre> <p>Transcribe audio file.</p> PARAMETER DESCRIPTION <code>audio_path</code> <p>Path to audio file</p> <p> TYPE: <code>str | Path</code> </p> RETURNS DESCRIPTION <code>dict</code> <p>Dictionary with at least 'text' key containing transcription</p> Source code in <code>mkv_episode_matcher/asr_models.py</code> <pre><code>@abc.abstractmethod\ndef transcribe(self, audio_path: str | Path) -&gt; dict:\n    \"\"\"\n    Transcribe audio file.\n\n    Args:\n        audio_path: Path to audio file\n\n    Returns:\n        Dictionary with at least 'text' key containing transcription\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/#mkv_episode_matcher.asr_models.ASRModel.calculate_match_score","title":"calculate_match_score","text":"<pre><code>calculate_match_score(transcription, reference)\n</code></pre> <p>Calculate similarity score between transcription and reference.</p> PARAMETER DESCRIPTION <code>transcription</code> <p>Transcribed text</p> <p> TYPE: <code>str</code> </p> <code>reference</code> <p>Reference subtitle text</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>float</code> <p>Float score between 0.0 and 1.0</p> Source code in <code>mkv_episode_matcher/asr_models.py</code> <pre><code>def calculate_match_score(self, transcription: str, reference: str) -&gt; float:\n    \"\"\"\n    Calculate similarity score between transcription and reference.\n\n    Args:\n        transcription: Transcribed text\n        reference: Reference subtitle text\n\n    Returns:\n        Float score between 0.0 and 1.0\n    \"\"\"\n    # Default implementation: Standard weights\n    # Token sort ratio (70%) + Partial ratio (30%)\n    token_weight = 0.7\n    partial_weight = 0.3\n\n    score = (\n        fuzz.token_sort_ratio(transcription, reference) * token_weight\n        + fuzz.partial_ratio(transcription, reference) * partial_weight\n    ) / 100.0\n\n    return score\n</code></pre>"},{"location":"api/#mkv_episode_matcher.asr_models.ASRModel.unload","title":"unload","text":"<pre><code>unload()\n</code></pre> <p>Unload model to free memory.</p> Source code in <code>mkv_episode_matcher/asr_models.py</code> <pre><code>def unload(self):\n    \"\"\"Unload model to free memory.\"\"\"\n    self._model = None\n</code></pre>"},{"location":"api/#mkv_episode_matcher.asr_models.ParakeetTDTModel","title":"ParakeetTDTModel","text":"<pre><code>ParakeetTDTModel(\n    model_name=\"nvidia/parakeet-tdt-0.6b-v2\", device=None\n)\n</code></pre> <p>               Bases: <code>ASRModel</code></p> <p>NVIDIA Parakeet TDT ASR model implementation.</p> <p>WARNING: This model (TDT) uses the Transducer decoder which requires significant GPU resources and may be unstable on some Windows configurations (CUDA errors).</p> <p>Initialize Parakeet TDT model.</p> PARAMETER DESCRIPTION <code>model_name</code> <p>Parakeet model identifier from HuggingFace</p> <p> TYPE: <code>str</code> DEFAULT: <code>'nvidia/parakeet-tdt-0.6b-v2'</code> </p> <code>device</code> <p>Device to run on</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> Source code in <code>mkv_episode_matcher/asr_models.py</code> <pre><code>def __init__(\n    self, model_name: str = \"nvidia/parakeet-tdt-0.6b-v2\", device: str | None = None\n):\n    \"\"\"\n    Initialize Parakeet TDT model.\n\n    Args:\n        model_name: Parakeet model identifier from HuggingFace\n        device: Device to run on\n    \"\"\"\n    super().__init__(model_name, device)\n</code></pre>"},{"location":"api/#mkv_episode_matcher.asr_models.ParakeetTDTModel-attributes","title":"Attributes","text":""},{"location":"api/#mkv_episode_matcher.asr_models.ParakeetTDTModel.is_loaded","title":"is_loaded  <code>property</code>","text":"<pre><code>is_loaded\n</code></pre> <p>Check if model is loaded.</p>"},{"location":"api/#mkv_episode_matcher.asr_models.ParakeetTDTModel-functions","title":"Functions","text":""},{"location":"api/#mkv_episode_matcher.asr_models.ParakeetTDTModel.load","title":"load","text":"<pre><code>load()\n</code></pre> <p>Load Parakeet model with caching.</p> Source code in <code>mkv_episode_matcher/asr_models.py</code> <pre><code>def load(self):\n    \"\"\"Load Parakeet model with caching.\"\"\"\n    if self.is_loaded:\n        return\n\n    cache_key = f\"parakeet_tdt_{self.model_name}_{self.device}\"\n\n    if cache_key in _model_cache:\n        self._model = _model_cache[cache_key]\n        logger.debug(\n            f\"Using cached Parakeet TDT model: {self.model_name} on {self.device}\"\n        )\n        return\n\n    try:\n        # Windows compatibility: Patch signal module before importing NeMo\n        if os.name == \"nt\":  # Windows\n            import signal\n\n            if not hasattr(signal, \"SIGKILL\"):\n                # Add missing signal constants for Windows compatibility\n                signal.SIGKILL = 9\n                signal.SIGTERM = 15\n\n        import nemo.collections.asr as nemo_asr\n\n        # Store original environment variables for restoration\n        original_env = {}\n\n        # Configure environment to suppress NeMo warnings and optimize performance\n        nemo_env_settings = {\n            \"NEMO_DISABLE_TRAINING_LOGS\": \"1\",\n            \"NEMO_DISABLE_HYDRA_LOGS\": \"1\",\n            \"HYDRA_FULL_ERROR\": \"0\",\n            \"PYTHONWARNINGS\": \"ignore::UserWarning\",\n            \"TOKENIZERS_PARALLELISM\": \"false\",  # Avoid tokenizer warnings\n        }\n\n        # Windows compatibility: Add optimizations but avoid signal issues\n        if os.name == \"nt\":  # Windows\n            nemo_env_settings.update({\n                \"OMP_NUM_THREADS\": \"1\",\n                \"MKL_NUM_THREADS\": \"1\",\n                \"NEMO_BYPASS_SIGNALS\": \"1\",  # Bypass NeMo signal handling on Windows\n            })\n\n        for key, value in nemo_env_settings.items():\n            original_env[key] = os.environ.get(key)\n            os.environ[key] = value\n\n        try:\n            # Set device for NeMo\n            if self.device == \"cuda\" and torch.cuda.is_available():\n                # NeMo will automatically use CUDA if available\n                pass\n            elif self.device == \"cpu\":\n                # Force CPU usage - NeMo respects CUDA_VISIBLE_DEVICES=\"\"\n                original_env[\"CUDA_VISIBLE_DEVICES\"] = os.environ.get(\n                    \"CUDA_VISIBLE_DEVICES\"\n                )\n                os.environ[\"CUDA_VISIBLE_DEVICES\"] = \"\"\n\n            # Load model with reduced verbosity\n            self._model = nemo_asr.models.ASRModel.from_pretrained(\n                model_name=self.model_name,\n                strict=False,  # Allow loading with missing keys to reduce warnings\n            )\n\n            # Configure model for optimal inference\n            if hasattr(self._model, \"set_batch_size\"):\n                self._model.set_batch_size(1)  # Optimize for single file processing\n\n            # Fix for Windows: Force num_workers to 0 to avoid multiprocessing errors/locks\n            if hasattr(self._model, \"cfg\"):\n                for ds_config in [\"test_ds\", \"validation_ds\"]:\n                    if ds_config in self._model.cfg:\n                        self._model.cfg[ds_config].num_workers = 0\n\n            if hasattr(self._model, \"eval\"):\n                self._model.eval()  # Set to evaluation mode\n\n        finally:\n            # Restore original environment variables\n            for key, original_value in original_env.items():\n                if original_value is not None:\n                    os.environ[key] = original_value\n                elif key in os.environ:\n                    del os.environ[key]\n\n        _model_cache[cache_key] = self._model\n        logger.info(\n            f\"Loaded Parakeet TDT model: {self.model_name} on {self.device}\"\n        )\n\n    except ImportError as e:\n        raise ImportError(\n            \"NVIDIA NeMo not installed. Run: pip install nemo_toolkit[asr]\"\n        ) from e\n    except Exception as e:\n        logger.error(f\"Failed to load Parakeet TDT model {self.model_name}: {e}\")\n        raise\n</code></pre>"},{"location":"api/#mkv_episode_matcher.asr_models.ParakeetTDTModel.calculate_match_score","title":"calculate_match_score","text":"<pre><code>calculate_match_score(transcription, reference)\n</code></pre> <p>Calculate similarity score with Parakeet-specific weights. Parakeet produces longer, more detailed transcriptions, so we favor partial matches.</p> Source code in <code>mkv_episode_matcher/asr_models.py</code> <pre><code>def calculate_match_score(self, transcription: str, reference: str) -&gt; float:\n    \"\"\"\n    Calculate similarity score with Parakeet-specific weights.\n    Parakeet produces longer, more detailed transcriptions, so we favor partial matches.\n    \"\"\"\n    # Parakeet weights: Boost partial_ratio\n    token_weight = 0.4\n    partial_weight = 0.6\n\n    # Additional boost for very detailed transcriptions\n    length_ratio = len(transcription) / max(len(reference), 1)\n    if length_ratio &gt; 2.0:  # Much longer transcription\n        partial_weight = 0.8\n        token_weight = 0.2\n\n    score = (\n        fuzz.token_sort_ratio(transcription, reference) * token_weight\n        + fuzz.partial_ratio(transcription, reference) * partial_weight\n    ) / 100.0\n\n    return score\n</code></pre>"},{"location":"api/#mkv_episode_matcher.asr_models.ParakeetTDTModel.transcribe","title":"transcribe","text":"<pre><code>transcribe(audio_path)\n</code></pre> <p>Transcribe audio using Parakeet with preprocessing and text normalization.</p> PARAMETER DESCRIPTION <code>audio_path</code> <p>Path to audio file</p> <p> TYPE: <code>str | Path</code> </p> RETURNS DESCRIPTION <code>dict</code> <p>Dictionary with 'text' and 'segments' from Parakeet</p> Source code in <code>mkv_episode_matcher/asr_models.py</code> <pre><code>def transcribe(self, audio_path: str | Path) -&gt; dict:\n    \"\"\"\n    Transcribe audio using Parakeet with preprocessing and text normalization.\n\n    Args:\n        audio_path: Path to audio file\n\n    Returns:\n        Dictionary with 'text' and 'segments' from Parakeet\n    \"\"\"\n    if not self.is_loaded:\n        self.load()\n\n    preprocessed_audio = None\n    try:\n        logger.debug(f\"Starting Parakeet transcription for {audio_path}\")\n\n        # Preprocess audio for optimal Parakeet performance\n        preprocessed_audio = self._preprocess_audio(audio_path)\n\n        # Configure NeMo model settings to reduce warnings\n        old_env_vars = {}\n        try:\n            # Set environment variables to reduce NeMo warnings\n            env_settings = {\n                \"CUDA_LAUNCH_BLOCKING\": \"0\",\n                \"NEMO_DISABLE_TRAINING_LOGS\": \"1\",\n            }\n\n            for key, value in env_settings.items():\n                old_env_vars[key] = os.environ.get(key)\n                os.environ[key] = value\n\n            # Parakeet expects list of file paths\n            result = self._model.transcribe([preprocessed_audio])\n\n        finally:\n            # Restore original environment variables\n            for key, old_value in old_env_vars.items():\n                if old_value is not None:\n                    os.environ[key] = old_value\n                elif key in os.environ:\n                    del os.environ[key]\n\n        logger.debug(f\"Parakeet raw result: {result}, type: {type(result)}\")\n\n        # Extract text from result\n        raw_text = \"\"\n        if isinstance(result, list) and len(result) &gt; 0:\n            if hasattr(result[0], \"text\"):\n                raw_text = result[0].text\n            elif isinstance(result[0], str):\n                raw_text = result[0]\n            else:\n                raw_text = str(result[0])\n        else:\n            logger.warning(f\"Unexpected Parakeet result format: {result}\")\n            raw_text = \"\"\n\n        # Clean and normalize the transcription\n        cleaned_text = self._clean_transcription_text(raw_text)\n\n        logger.debug(f\"Raw transcription: '{raw_text}'\")\n        logger.debug(f\"Cleaned transcription: '{cleaned_text}'\")\n\n        return {\n            \"text\": cleaned_text,\n            \"raw_text\": raw_text,\n            \"segments\": [],\n            \"language\": \"en\",\n        }\n\n    except Exception as e:\n        logger.error(\n            f\"Parakeet transcription failed for {audio_path}: {type(e).__name__}: {e}\"\n        )\n        import traceback\n\n        traceback.print_exc()\n        # Return empty result instead of raising to allow fallback\n        return {\"text\": \"\", \"raw_text\": \"\", \"segments\": [], \"language\": \"en\"}\n    finally:\n        # Clean up preprocessed audio file\n        if preprocessed_audio and preprocessed_audio != str(audio_path):\n            try:\n                Path(preprocessed_audio).unlink(missing_ok=True)\n            except Exception as e:\n                logger.debug(f\"Failed to clean up preprocessed audio: {e}\")\n</code></pre>"},{"location":"api/#mkv_episode_matcher.asr_models.ParakeetTDTModel.unload","title":"unload","text":"<pre><code>unload()\n</code></pre> <p>Unload model to free memory.</p> Source code in <code>mkv_episode_matcher/asr_models.py</code> <pre><code>def unload(self):\n    \"\"\"Unload model to free memory.\"\"\"\n    self._model = None\n</code></pre>"},{"location":"api/#mkv_episode_matcher.asr_models.ParakeetCTCModel","title":"ParakeetCTCModel","text":"<pre><code>ParakeetCTCModel(\n    model_name=\"nvidia/parakeet-ctc-0.6b\", device=None\n)\n</code></pre> <p>               Bases: <code>ParakeetTDTModel</code></p> <p>NVIDIA Parakeet CTC ASR model implementation.</p> <p>This uses the CTC decoder which is more stable and robust on various hardware than the TDT version, though potentially slightly less accurate.</p> <p>Initialize Parakeet CTC model.</p> PARAMETER DESCRIPTION <code>model_name</code> <p>Parakeet model identifier (default: nvidia/parakeet-ctc-0.6b)</p> <p> TYPE: <code>str</code> DEFAULT: <code>'nvidia/parakeet-ctc-0.6b'</code> </p> <code>device</code> <p>Device to run on</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> Source code in <code>mkv_episode_matcher/asr_models.py</code> <pre><code>def __init__(\n    self, model_name: str = \"nvidia/parakeet-ctc-0.6b\", device: str | None = None\n):\n    \"\"\"\n    Initialize Parakeet CTC model.\n\n    Args:\n        model_name: Parakeet model identifier (default: nvidia/parakeet-ctc-0.6b)\n        device: Device to run on\n    \"\"\"\n    # Ensure we use a CTC-compatible model name if not specified\n    # But we trust the user input if provided.\n    super().__init__(model_name, device)\n</code></pre>"},{"location":"api/#mkv_episode_matcher.asr_models.ParakeetCTCModel-attributes","title":"Attributes","text":""},{"location":"api/#mkv_episode_matcher.asr_models.ParakeetCTCModel.is_loaded","title":"is_loaded  <code>property</code>","text":"<pre><code>is_loaded\n</code></pre> <p>Check if model is loaded.</p>"},{"location":"api/#mkv_episode_matcher.asr_models.ParakeetCTCModel-functions","title":"Functions","text":""},{"location":"api/#mkv_episode_matcher.asr_models.ParakeetCTCModel.load","title":"load","text":"<pre><code>load()\n</code></pre> <p>Load Parakeet CTC model with caching.</p> Source code in <code>mkv_episode_matcher/asr_models.py</code> <pre><code>def load(self):\n    \"\"\"Load Parakeet CTC model with caching.\"\"\"\n    # We override load simply to use a different cache key if needed, or we can just reuse parent load\n    # reusing parent load is fine as it uses self.model_name in cache key.\n    # But we need to ensure the logging says CTC.\n    super().load()\n</code></pre>"},{"location":"api/#mkv_episode_matcher.asr_models.ParakeetCTCModel.transcribe","title":"transcribe","text":"<pre><code>transcribe(audio_path)\n</code></pre> <p>Transcribe audio using Parakeet with preprocessing and text normalization.</p> PARAMETER DESCRIPTION <code>audio_path</code> <p>Path to audio file</p> <p> TYPE: <code>str | Path</code> </p> RETURNS DESCRIPTION <code>dict</code> <p>Dictionary with 'text' and 'segments' from Parakeet</p> Source code in <code>mkv_episode_matcher/asr_models.py</code> <pre><code>def transcribe(self, audio_path: str | Path) -&gt; dict:\n    \"\"\"\n    Transcribe audio using Parakeet with preprocessing and text normalization.\n\n    Args:\n        audio_path: Path to audio file\n\n    Returns:\n        Dictionary with 'text' and 'segments' from Parakeet\n    \"\"\"\n    if not self.is_loaded:\n        self.load()\n\n    preprocessed_audio = None\n    try:\n        logger.debug(f\"Starting Parakeet transcription for {audio_path}\")\n\n        # Preprocess audio for optimal Parakeet performance\n        preprocessed_audio = self._preprocess_audio(audio_path)\n\n        # Configure NeMo model settings to reduce warnings\n        old_env_vars = {}\n        try:\n            # Set environment variables to reduce NeMo warnings\n            env_settings = {\n                \"CUDA_LAUNCH_BLOCKING\": \"0\",\n                \"NEMO_DISABLE_TRAINING_LOGS\": \"1\",\n            }\n\n            for key, value in env_settings.items():\n                old_env_vars[key] = os.environ.get(key)\n                os.environ[key] = value\n\n            # Parakeet expects list of file paths\n            result = self._model.transcribe([preprocessed_audio])\n\n        finally:\n            # Restore original environment variables\n            for key, old_value in old_env_vars.items():\n                if old_value is not None:\n                    os.environ[key] = old_value\n                elif key in os.environ:\n                    del os.environ[key]\n\n        logger.debug(f\"Parakeet raw result: {result}, type: {type(result)}\")\n\n        # Extract text from result\n        raw_text = \"\"\n        if isinstance(result, list) and len(result) &gt; 0:\n            if hasattr(result[0], \"text\"):\n                raw_text = result[0].text\n            elif isinstance(result[0], str):\n                raw_text = result[0]\n            else:\n                raw_text = str(result[0])\n        else:\n            logger.warning(f\"Unexpected Parakeet result format: {result}\")\n            raw_text = \"\"\n\n        # Clean and normalize the transcription\n        cleaned_text = self._clean_transcription_text(raw_text)\n\n        logger.debug(f\"Raw transcription: '{raw_text}'\")\n        logger.debug(f\"Cleaned transcription: '{cleaned_text}'\")\n\n        return {\n            \"text\": cleaned_text,\n            \"raw_text\": raw_text,\n            \"segments\": [],\n            \"language\": \"en\",\n        }\n\n    except Exception as e:\n        logger.error(\n            f\"Parakeet transcription failed for {audio_path}: {type(e).__name__}: {e}\"\n        )\n        import traceback\n\n        traceback.print_exc()\n        # Return empty result instead of raising to allow fallback\n        return {\"text\": \"\", \"raw_text\": \"\", \"segments\": [], \"language\": \"en\"}\n    finally:\n        # Clean up preprocessed audio file\n        if preprocessed_audio and preprocessed_audio != str(audio_path):\n            try:\n                Path(preprocessed_audio).unlink(missing_ok=True)\n            except Exception as e:\n                logger.debug(f\"Failed to clean up preprocessed audio: {e}\")\n</code></pre>"},{"location":"api/#mkv_episode_matcher.asr_models.ParakeetCTCModel.calculate_match_score","title":"calculate_match_score","text":"<pre><code>calculate_match_score(transcription, reference)\n</code></pre> <p>Calculate similarity score with Parakeet-specific weights. Parakeet produces longer, more detailed transcriptions, so we favor partial matches.</p> Source code in <code>mkv_episode_matcher/asr_models.py</code> <pre><code>def calculate_match_score(self, transcription: str, reference: str) -&gt; float:\n    \"\"\"\n    Calculate similarity score with Parakeet-specific weights.\n    Parakeet produces longer, more detailed transcriptions, so we favor partial matches.\n    \"\"\"\n    # Parakeet weights: Boost partial_ratio\n    token_weight = 0.4\n    partial_weight = 0.6\n\n    # Additional boost for very detailed transcriptions\n    length_ratio = len(transcription) / max(len(reference), 1)\n    if length_ratio &gt; 2.0:  # Much longer transcription\n        partial_weight = 0.8\n        token_weight = 0.2\n\n    score = (\n        fuzz.token_sort_ratio(transcription, reference) * token_weight\n        + fuzz.partial_ratio(transcription, reference) * partial_weight\n    ) / 100.0\n\n    return score\n</code></pre>"},{"location":"api/#mkv_episode_matcher.asr_models.ParakeetCTCModel.unload","title":"unload","text":"<pre><code>unload()\n</code></pre> <p>Unload model to free memory.</p> Source code in <code>mkv_episode_matcher/asr_models.py</code> <pre><code>def unload(self):\n    \"\"\"Unload model to free memory.\"\"\"\n    self._model = None\n</code></pre>"},{"location":"api/#mkv_episode_matcher.asr_models-functions","title":"Functions","text":""},{"location":"api/#mkv_episode_matcher.asr_models.create_asr_model","title":"create_asr_model","text":"<pre><code>create_asr_model(model_config)\n</code></pre> <p>Factory function to create ASR models from configuration.</p> PARAMETER DESCRIPTION <code>model_config</code> <p>Dictionary with 'type' and 'name' keys</p> <p> TYPE: <code>dict</code> </p> RETURNS DESCRIPTION <code>ASRModel</code> <p>Configured ASRModel instance</p> Example <p>model_config = {\"type\": \"parakeet\", \"name\": \"nvidia/parakeet-ctc-0.6b\"} model = create_asr_model(model_config)</p> Source code in <code>mkv_episode_matcher/asr_models.py</code> <pre><code>def create_asr_model(model_config: dict) -&gt; ASRModel:\n    \"\"\"\n    Factory function to create ASR models from configuration.\n\n    Args:\n        model_config: Dictionary with 'type' and 'name' keys\n\n    Returns:\n        Configured ASRModel instance\n\n    Example:\n        model_config = {\"type\": \"parakeet\", \"name\": \"nvidia/parakeet-ctc-0.6b\"}\n        model = create_asr_model(model_config)\n    \"\"\"\n    model_type = model_config.get(\"type\", \"\").lower()\n    model_name = model_config.get(\"name\", \"\")\n    device = model_config.get(\"device\")\n\n    if model_type == \"parakeet\":\n        # Always use the specific working model\n        if not model_name:\n            model_name = \"nvidia/parakeet-ctc-0.6b\"\n        return ParakeetCTCModel(model_name, device)\n    else:\n        raise ValueError(\n            f\"Unsupported model type: {model_type}. Only 'parakeet' is supported.\"\n        )\n</code></pre>"},{"location":"api/#mkv_episode_matcher.asr_models.get_cached_model","title":"get_cached_model","text":"<pre><code>get_cached_model(model_config)\n</code></pre> <p>Get a cached model instance, creating it if necessary.</p> PARAMETER DESCRIPTION <code>model_config</code> <p>Dictionary with model configuration</p> <p> TYPE: <code>dict</code> </p> RETURNS DESCRIPTION <code>ASRModel</code> <p>ASRModel instance (loaded and ready for use)</p> Source code in <code>mkv_episode_matcher/asr_models.py</code> <pre><code>def get_cached_model(model_config: dict) -&gt; ASRModel:\n    \"\"\"\n    Get a cached model instance, creating it if necessary.\n\n    Args:\n        model_config: Dictionary with model configuration\n\n    Returns:\n        ASRModel instance (loaded and ready for use)\n    \"\"\"\n    cache_key = f\"{model_config.get('type', '')}_{model_config.get('name', '')}_{model_config.get('device', 'auto')}\"\n\n    if cache_key not in _model_cache:\n        model = create_asr_model(model_config)\n        model.load()  # Load immediately for caching\n        _model_cache[cache_key] = model\n\n    return _model_cache[cache_key]\n</code></pre>"},{"location":"api/#mkv_episode_matcher.asr_models.clear_model_cache","title":"clear_model_cache","text":"<pre><code>clear_model_cache()\n</code></pre> <p>Clear all cached models to free memory.</p> Source code in <code>mkv_episode_matcher/asr_models.py</code> <pre><code>def clear_model_cache():\n    \"\"\"Clear all cached models to free memory.\"\"\"\n    global _model_cache\n    for model in _model_cache.values():\n        if hasattr(model, \"unload\"):\n            model.unload()\n    _model_cache.clear()\n    logger.info(\"Cleared ASR model cache\")\n</code></pre>"},{"location":"api/#mkv_episode_matcher.asr_models.list_available_models","title":"list_available_models","text":"<pre><code>list_available_models()\n</code></pre> <p>List available model types and their requirements.</p> RETURNS DESCRIPTION <code>dict</code> <p>Dictionary with model types and their availability status</p> Source code in <code>mkv_episode_matcher/asr_models.py</code> <pre><code>def list_available_models() -&gt; dict:\n    \"\"\"\n    List available model types and their requirements.\n\n    Returns:\n        Dictionary with model types and their availability status\n    \"\"\"\n    availability = {}\n\n    # Check Parakeet availability\n    try:\n        import nemo.collections.asr  # noqa: F401\n\n        availability[\"parakeet\"] = {\n            \"available\": True,\n            \"models\": [\"nvidia/parakeet-ctc-0.6b\"],\n        }\n    except ImportError:\n        availability[\"parakeet\"] = {\n            \"available\": False,\n            \"error\": \"NVIDIA NeMo not installed\",\n        }\n\n    return availability\n</code></pre>"},{"location":"api/#mkv_episode_matcher.subtitle_utils","title":"mkv_episode_matcher.subtitle_utils","text":""},{"location":"api/#mkv_episode_matcher.subtitle_utils-functions","title":"Functions","text":""},{"location":"api/#mkv_episode_matcher.subtitle_utils.generate_subtitle_patterns","title":"generate_subtitle_patterns","text":"<pre><code>generate_subtitle_patterns(series_name, season, episode)\n</code></pre> <p>Generate various common subtitle filename patterns.</p> PARAMETER DESCRIPTION <code>series_name</code> <p>Name of the series</p> <p> TYPE: <code>str</code> </p> <code>season</code> <p>Season number</p> <p> TYPE: <code>int</code> </p> <code>episode</code> <p>Episode number</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>list[str]</code> <p>List[str]: List of possible subtitle filenames</p> Source code in <code>mkv_episode_matcher/subtitle_utils.py</code> <pre><code>def generate_subtitle_patterns(\n    series_name: str, season: int, episode: int\n) -&gt; list[str]:\n    \"\"\"\n    Generate various common subtitle filename patterns.\n\n    Args:\n        series_name (str): Name of the series\n        season (int): Season number\n        episode (int): Episode number\n\n    Returns:\n        List[str]: List of possible subtitle filenames\n    \"\"\"\n    patterns = [\n        # Standard format: \"Show Name - S01E02.srt\"\n        f\"{series_name} - S{season:02d}E{episode:02d}.srt\",\n        # Season x Episode format: \"Show Name - 1x02.srt\"\n        f\"{series_name} - {season}x{episode:02d}.srt\",\n        # Separate season/episode: \"Show Name - Season 1 Episode 02.srt\"\n        f\"{series_name} - Season {season} Episode {episode:02d}.srt\",\n        # Compact format: \"ShowName.S01E02.srt\"\n        f\"{series_name.replace(' ', '')}.S{season:02d}E{episode:02d}.srt\",\n        # Numbered format: \"Show Name 102.srt\"\n        f\"{series_name} {season:01d}{episode:02d}.srt\",\n        # Dot format: \"Show.Name.1x02.srt\"\n        f\"{series_name.replace(' ', '.')}.{season}x{episode:02d}.srt\",\n        # Underscore format: \"Show_Name_S01E02.srt\"\n        f\"{series_name.replace(' ', '_')}_S{season:02d}E{episode:02d}.srt\",\n    ]\n\n    return patterns\n</code></pre>"},{"location":"api/#mkv_episode_matcher.subtitle_utils.find_existing_subtitle","title":"find_existing_subtitle","text":"<pre><code>find_existing_subtitle(\n    series_cache_dir, series_name, season, episode\n)\n</code></pre> <p>Check for existing subtitle files in various naming formats.</p> PARAMETER DESCRIPTION <code>series_cache_dir</code> <p>Directory containing subtitle files</p> <p> TYPE: <code>str</code> </p> <code>series_name</code> <p>Name of the series</p> <p> TYPE: <code>str</code> </p> <code>season</code> <p>Season number</p> <p> TYPE: <code>int</code> </p> <code>episode</code> <p>Episode number</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>str | None</code> <p>Optional[str]: Path to existing subtitle file if found, None otherwise</p> Source code in <code>mkv_episode_matcher/subtitle_utils.py</code> <pre><code>def find_existing_subtitle(\n    series_cache_dir: str, series_name: str, season: int, episode: int\n) -&gt; str | None:\n    \"\"\"\n    Check for existing subtitle files in various naming formats.\n\n    Args:\n        series_cache_dir (str): Directory containing subtitle files\n        series_name (str): Name of the series\n        season (int): Season number\n        episode (int): Episode number\n\n    Returns:\n        Optional[str]: Path to existing subtitle file if found, None otherwise\n    \"\"\"\n    patterns = generate_subtitle_patterns(series_name, season, episode)\n\n    for pattern in patterns:\n        filepath = Path(series_cache_dir) / pattern\n        if filepath.exists():\n            return filepath\n\n    return None\n</code></pre>"},{"location":"api/#mkv_episode_matcher.subtitle_utils.sanitize_filename","title":"sanitize_filename","text":"<pre><code>sanitize_filename(filename)\n</code></pre> <p>Sanitize filename by removing/replacing invalid characters.</p> PARAMETER DESCRIPTION <code>filename</code> <p>Original filename</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>str</code> <p>Sanitized filename</p> <p> TYPE: <code>str</code> </p> Source code in <code>mkv_episode_matcher/subtitle_utils.py</code> <pre><code>def sanitize_filename(filename: str) -&gt; str:\n    \"\"\"\n    Sanitize filename by removing/replacing invalid characters.\n\n    Args:\n        filename (str): Original filename\n\n    Returns:\n        str: Sanitized filename\n    \"\"\"\n    # Replace problematic characters\n    filename = filename.replace(\":\", \" -\")\n    filename = filename.replace(\"/\", \"-\")\n    filename = filename.replace(\"\\\\\", \"-\")\n\n    # Remove any other invalid characters\n    filename = re.sub(r'[&lt;&gt;:\"/\\\\|?*]', \"\", filename)\n\n    return filename.strip()\n</code></pre>"},{"location":"api/#tmdb-client","title":"TMDB Client","text":""},{"location":"api/#mkv_episode_matcher.tmdb_client","title":"mkv_episode_matcher.tmdb_client","text":""},{"location":"api/#mkv_episode_matcher.tmdb_client-classes","title":"Classes","text":""},{"location":"api/#mkv_episode_matcher.tmdb_client.RateLimitedRequest","title":"RateLimitedRequest","text":"<pre><code>RateLimitedRequest(rate_limit=30, period=1)\n</code></pre> <p>A class that represents a rate-limited request object.</p> ATTRIBUTE DESCRIPTION <code>rate_limit</code> <p>Maximum number of requests allowed per period.</p> <p> TYPE: <code>int</code> </p> <code>period</code> <p>Period in seconds.</p> <p> TYPE: <code>int</code> </p> <code>requests_made</code> <p>Counter for requests made.</p> <p> TYPE: <code>int</code> </p> <code>start_time</code> <p>Start time of the current period.</p> <p> TYPE: <code>float</code> </p> <code>lock</code> <p>Lock for synchronization.</p> <p> TYPE: <code>Lock</code> </p> Source code in <code>mkv_episode_matcher/tmdb_client.py</code> <pre><code>def __init__(self, rate_limit=30, period=1):\n    self.rate_limit = rate_limit\n    self.period = period\n    self.requests_made = 0\n    self.start_time = time.time()\n    self.lock = Lock()\n</code></pre>"},{"location":"api/#mkv_episode_matcher.tmdb_client.RateLimitedRequest-functions","title":"Functions","text":""},{"location":"api/#mkv_episode_matcher.tmdb_client.RateLimitedRequest.get","title":"get","text":"<pre><code>get(url)\n</code></pre> <p>Sends a rate-limited GET request to the specified URL.</p> PARAMETER DESCRIPTION <code>url</code> <p>The URL to send the request to.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Response</code> <p>The response object returned by the request.</p> Source code in <code>mkv_episode_matcher/tmdb_client.py</code> <pre><code>def get(self, url):\n    \"\"\"\n    Sends a rate-limited GET request to the specified URL.\n\n    Args:\n        url (str): The URL to send the request to.\n\n    Returns:\n        Response: The response object returned by the request.\n    \"\"\"\n    with self.lock:\n        if self.requests_made &gt;= self.rate_limit:\n            sleep_time = self.period - (time.time() - self.start_time)\n            if sleep_time &gt; 0:\n                time.sleep(sleep_time)\n            self.requests_made = 0\n            self.start_time = time.time()\n\n        self.requests_made += 1\n\n    response = requests.get(url, timeout=30)\n    return response\n</code></pre>"},{"location":"api/#mkv_episode_matcher.tmdb_client-functions","title":"Functions","text":""},{"location":"api/#mkv_episode_matcher.tmdb_client.retry_network_operation","title":"retry_network_operation","text":"<pre><code>retry_network_operation(max_retries=3, base_delay=1.0)\n</code></pre> <p>Decorator for retrying network operations.</p> Source code in <code>mkv_episode_matcher/tmdb_client.py</code> <pre><code>def retry_network_operation(\n    max_retries: int = 3, base_delay: float = 1.0\n) -&gt; Callable[[F], F]:\n    \"\"\"Decorator for retrying network operations.\"\"\"\n\n    def decorator(func: F) -&gt; F:\n        @wraps(func)\n        def wrapper(*args: Any, **kwargs: Any) -&gt; Any:\n            last_exception = None\n            delay = base_delay\n\n            for attempt in range(max_retries + 1):\n                try:\n                    return func(*args, **kwargs)\n                except (requests.RequestException, ConnectionError, TimeoutError) as e:\n                    last_exception = e\n                    if attempt == max_retries:\n                        logger.error(\n                            f\"Max retries ({max_retries}) exceeded for {func.__name__}: {e}\"\n                        )\n                        raise e\n\n                    logger.warning(\n                        f\"Network retry {attempt + 1}/{max_retries + 1} for {func.__name__}: {e}\"\n                    )\n                    time.sleep(delay)\n                    delay = min(delay * 2, 30)  # Cap at 30 seconds\n\n            raise last_exception\n\n        return wrapper  # type: ignore\n\n    return decorator\n</code></pre>"},{"location":"api/#mkv_episode_matcher.tmdb_client.fetch_show_id","title":"fetch_show_id","text":"<pre><code>fetch_show_id(show_name)\n</code></pre> <p>Fetch the TMDb ID for a given show name.</p> PARAMETER DESCRIPTION <code>show_name</code> <p>The name of the show.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>str</code> <p>The TMDb ID of the show, or None if not found.</p> <p> TYPE: <code>str | None</code> </p> Source code in <code>mkv_episode_matcher/tmdb_client.py</code> <pre><code>@retry_network_operation(max_retries=3, base_delay=1.0)\ndef fetch_show_id(show_name: str) -&gt; str | None:\n    \"\"\"\n    Fetch the TMDb ID for a given show name.\n\n    Args:\n        show_name (str): The name of the show.\n\n    Returns:\n        str: The TMDb ID of the show, or None if not found.\n    \"\"\"\n    config = get_config_manager().load()\n    tmdb_api_key = config.tmdb_api_key\n    url = f\"https://api.themoviedb.org/3/search/tv?query={show_name}&amp;api_key={tmdb_api_key}\"\n    response = requests.get(url)\n    if response.status_code == 200:\n        results = response.json().get(\"results\", [])\n        if results:\n            return str(results[0][\"id\"])\n    return None\n</code></pre>"},{"location":"api/#mkv_episode_matcher.tmdb_client.fetch_show_details","title":"fetch_show_details","text":"<pre><code>fetch_show_details(show_id)\n</code></pre> <p>Fetch show details from TMDB by ID.</p> PARAMETER DESCRIPTION <code>show_id</code> <p>The TMDB show ID</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>dict</code> <p>Show details including 'name', 'number_of_seasons', etc.</p> <p> TYPE: <code>dict | None</code> </p> <code>None</code> <p>If request fails or API key not configured</p> <p> TYPE: <code>dict | None</code> </p> Source code in <code>mkv_episode_matcher/tmdb_client.py</code> <pre><code>@retry_network_operation(max_retries=3, base_delay=1.0)\ndef fetch_show_details(show_id: int) -&gt; dict | None:\n    \"\"\"\n    Fetch show details from TMDB by ID.\n\n    Args:\n        show_id: The TMDB show ID\n\n    Returns:\n        dict: Show details including 'name', 'number_of_seasons', etc.\n        None: If request fails or API key not configured\n    \"\"\"\n    config = get_config_manager().load()\n    if not config.tmdb_api_key:\n        logger.warning(\"TMDB API key not configured\")\n        return None\n\n    url = f\"https://api.themoviedb.org/3/tv/{show_id}?api_key={config.tmdb_api_key}\"\n\n    try:\n        response = requests.get(url, timeout=30)\n        response.raise_for_status()\n        return response.json()\n    except requests.exceptions.RequestException as e:\n        logger.error(f\"Failed to fetch show details for ID {show_id}: {e}\")\n        return None\n</code></pre>"},{"location":"api/#mkv_episode_matcher.tmdb_client.fetch_season_details","title":"fetch_season_details","text":"<pre><code>fetch_season_details(show_id, season_number)\n</code></pre> <p>Fetch the total number of episodes for a given show and season from the TMDb API.</p> PARAMETER DESCRIPTION <code>show_id</code> <p>The ID of the show on TMDb.</p> <p> TYPE: <code>str</code> </p> <code>season_number</code> <p>The season number to fetch details for.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>int</code> <p>The total number of episodes in the season, or 0 if the API request failed.</p> <p> TYPE: <code>int</code> </p> Source code in <code>mkv_episode_matcher/tmdb_client.py</code> <pre><code>@retry_network_operation(max_retries=3, base_delay=1.0)\ndef fetch_season_details(show_id: str, season_number: int) -&gt; int:\n    \"\"\"\n    Fetch the total number of episodes for a given show and season from the TMDb API.\n\n    Args:\n        show_id (str): The ID of the show on TMDb.\n        season_number (int): The season number to fetch details for.\n\n    Returns:\n        int: The total number of episodes in the season, or 0 if the API request failed.\n    \"\"\"\n    logger.info(f\"Fetching season details for Season {season_number}...\")\n    config = get_config_manager().load()\n    tmdb_api_key = config.tmdb_api_key\n    url = f\"https://api.themoviedb.org/3/tv/{show_id}/season/{season_number}?api_key={tmdb_api_key}\"\n    try:\n        response = requests.get(url, timeout=30)\n        response.raise_for_status()\n        season_data = response.json()\n        total_episodes = len(season_data.get(\"episodes\", []))\n        return total_episodes\n    except requests.exceptions.RequestException as e:\n        logger.error(f\"Failed to fetch season details for Season {season_number}: {e}\")\n        return 0\n    except KeyError:\n        logger.error(\n            f\"Missing 'episodes' key in response JSON data for Season {season_number}\"\n        )\n        return 0\n</code></pre>"},{"location":"api/#mkv_episode_matcher.tmdb_client.get_number_of_seasons","title":"get_number_of_seasons","text":"<pre><code>get_number_of_seasons(show_id)\n</code></pre> <p>Retrieves the number of seasons for a given TV show from the TMDB API.</p> <p>Parameters: - show_id (int): The ID of the TV show.</p> <p>Returns: - num_seasons (int): The number of seasons for the TV show.</p> <p>Raises: - requests.HTTPError: If there is an error while making the API request.</p> Source code in <code>mkv_episode_matcher/tmdb_client.py</code> <pre><code>@retry_network_operation(max_retries=3, base_delay=1.0)\ndef get_number_of_seasons(show_id: str) -&gt; int:\n    \"\"\"\n    Retrieves the number of seasons for a given TV show from the TMDB API.\n\n    Parameters:\n    - show_id (int): The ID of the TV show.\n\n    Returns:\n    - num_seasons (int): The number of seasons for the TV show.\n\n    Raises:\n    - requests.HTTPError: If there is an error while making the API request.\n    \"\"\"\n    config = get_config_manager().load()\n    tmdb_api_key = config.tmdb_api_key\n    url = f\"https://api.themoviedb.org/3/tv/{show_id}?api_key={tmdb_api_key}\"\n    response = requests.get(url, timeout=30)\n    response.raise_for_status()\n    show_data = response.json()\n    num_seasons = show_data.get(\"number_of_seasons\", 0)\n    logger.info(f\"Found {num_seasons} seasons\")\n    return num_seasons\n</code></pre>"},{"location":"api/#utilities","title":"Utilities","text":""},{"location":"api/#mkv_episode_matcher.utils","title":"mkv_episode_matcher.utils","text":""},{"location":"api/#mkv_episode_matcher.utils-functions","title":"Functions","text":""},{"location":"api/#mkv_episode_matcher.utils.normalize_path","title":"normalize_path","text":"<pre><code>normalize_path(path_str)\n</code></pre> <p>Normalize a path string to handle cross-platform path issues. Properly handles trailing slashes and backslashes in both Windows and Unix paths. Also strips surrounding quotes that might be present in command line arguments.</p> PARAMETER DESCRIPTION <code>path_str</code> <p>The path string to normalize</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <p>pathlib.Path: A normalized Path object</p> Source code in <code>mkv_episode_matcher/utils.py</code> <pre><code>def normalize_path(path_str):\n    \"\"\"\n    Normalize a path string to handle cross-platform path issues.\n    Properly handles trailing slashes and backslashes in both Windows and Unix paths.\n    Also strips surrounding quotes that might be present in command line arguments.\n\n    Args:\n        path_str (str): The path string to normalize\n\n    Returns:\n        pathlib.Path: A normalized Path object\n    \"\"\"\n    # Convert to string if it's a Path object\n    if isinstance(path_str, Path):\n        path_str = str(path_str)\n\n    # Strip surrounding quotes (both single and double)\n    path_str = path_str.strip().strip('\"').strip(\"'\")\n\n    # Remove trailing slashes or backslashes\n    path_str = path_str.rstrip(\"/\").rstrip(\"\\\\\")\n\n    # Handle Windows paths on non-Windows platforms\n    if os.name != \"nt\" and \"\\\\\" in path_str and \":\" in path_str[:2]:\n        # This looks like a Windows path on a non-Windows system\n        # Extract the last component which should be the directory/file name\n        components = path_str.split(\"\\\\\")\n        return Path(components[-1])\n\n    return Path(path_str)\n</code></pre>"},{"location":"api/#mkv_episode_matcher.utils.get_valid_seasons","title":"get_valid_seasons","text":"<pre><code>get_valid_seasons(show_dir)\n</code></pre> <p>Get all season directories that contain MKV files.</p> PARAMETER DESCRIPTION <code>show_dir</code> <p>Base directory for the TV show</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>list</code> <p>List of paths to valid season directories</p> Source code in <code>mkv_episode_matcher/utils.py</code> <pre><code>def get_valid_seasons(show_dir):\n    \"\"\"\n    Get all season directories that contain MKV files.\n\n    Args:\n        show_dir (str): Base directory for the TV show\n\n    Returns:\n        list: List of paths to valid season directories\n    \"\"\"\n    # Get all season directories\n    show_path = normalize_path(show_dir)\n    season_paths = [str(show_path / d.name) for d in show_path.iterdir() if d.is_dir()]\n\n    # Filter seasons to only include those with .mkv files\n    valid_season_paths = []\n    for season_path in season_paths:\n        season_path_obj = Path(season_path)\n        mkv_files = [f for f in season_path_obj.iterdir() if f.name.endswith(\".mkv\")]\n        if mkv_files:\n            valid_season_paths.append(season_path)\n\n    if not valid_season_paths:\n        logger.warning(\n            f\"No seasons with .mkv files found in show '{normalize_path(show_dir).name}'\"\n        )\n    else:\n        logger.info(\n            f\"Found {len(valid_season_paths)} seasons with .mkv files in '{normalize_path(show_dir).name}'\"\n        )\n\n    return valid_season_paths\n</code></pre>"},{"location":"api/#mkv_episode_matcher.utils.check_filename","title":"check_filename","text":"<pre><code>check_filename(filename)\n</code></pre> <p>Check if the filename is in the correct format (S01E02).</p> PARAMETER DESCRIPTION <code>filename</code> <p>The filename to check.</p> <p> TYPE: <code>str or Path</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if the filename matches the expected pattern.</p> Source code in <code>mkv_episode_matcher/utils.py</code> <pre><code>def check_filename(filename):\n    \"\"\"\n    Check if the filename is in the correct format (S01E02).\n\n    Args:\n        filename (str or Path): The filename to check.\n\n    Returns:\n        bool: True if the filename matches the expected pattern.\n    \"\"\"\n    # Convert Path object to string if needed\n    if isinstance(filename, Path):\n        filename = str(filename)\n    # Check if the filename matches the expected format\n    match = re.search(r\".*S\\d+E\\d+\", filename)\n    return bool(match)\n</code></pre>"},{"location":"api/#mkv_episode_matcher.utils.scramble_filename","title":"scramble_filename","text":"<pre><code>scramble_filename(original_file_path, file_number)\n</code></pre> <p>Scrambles the filename of the given file path by adding the series title and file number.</p> PARAMETER DESCRIPTION <code>original_file_path</code> <p>The original file path.</p> <p> TYPE: <code>str</code> </p> <code>file_number</code> <p>The file number to be added to the filename.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <p>None</p> Source code in <code>mkv_episode_matcher/utils.py</code> <pre><code>def scramble_filename(original_file_path, file_number):\n    \"\"\"\n    Scrambles the filename of the given file path by adding the series title and file number.\n\n    Args:\n        original_file_path (str): The original file path.\n        file_number (int): The file number to be added to the filename.\n\n    Returns:\n        None\n    \"\"\"\n    logger.info(f\"Scrambling {original_file_path}\")\n    series_title = normalize_path(original_file_path).parent.parent.name\n    original_file_name = Path(original_file_path).name\n    extension = Path(original_file_path).suffix\n    new_file_name = f\"{series_title} - {file_number:03d}{extension}\"\n    new_file_path = Path(original_file_path).parent / new_file_name\n    if not new_file_path.exists():\n        logger.info(f\"Renaming {original_file_name} -&gt; {new_file_name}\")\n        Path(original_file_path).rename(new_file_path)\n</code></pre>"},{"location":"api/#mkv_episode_matcher.utils.rename_episode_file","title":"rename_episode_file","text":"<pre><code>rename_episode_file(original_file_path, new_filename)\n</code></pre> <p>Rename an episode file with a standardized naming convention.</p> PARAMETER DESCRIPTION <code>original_file_path</code> <p>The original file path of the episode.</p> <p> TYPE: <code>str or Path</code> </p> <code>new_filename</code> <p>The new filename including season/episode info.</p> <p> TYPE: <code>str or Path</code> </p> RETURNS DESCRIPTION <code>Path</code> <p>Path to the renamed file, or None if rename failed.</p> Source code in <code>mkv_episode_matcher/utils.py</code> <pre><code>def rename_episode_file(original_file_path, new_filename):\n    \"\"\"\n    Rename an episode file with a standardized naming convention.\n\n    Args:\n        original_file_path (str or Path): The original file path of the episode.\n        new_filename (str or Path): The new filename including season/episode info.\n\n    Returns:\n        Path: Path to the renamed file, or None if rename failed.\n    \"\"\"\n    original_dir = Path(original_file_path).parent\n    new_file_path = original_dir / new_filename\n\n    # Check if new filepath already exists\n    if new_file_path.exists():\n        logger.warning(f\"File already exists: {new_filename}\")\n\n        # Add numeric suffix if file exists\n        base, ext = Path(new_filename).stem, Path(new_filename).suffix\n        suffix = 2\n        while True:\n            new_filename = f\"{base}_{suffix}{ext}\"\n            new_file_path = original_dir / new_filename\n            if not new_file_path.exists():\n                break\n            suffix += 1\n\n    try:\n        Path(original_file_path).rename(new_file_path)\n        logger.info(f\"Renamed {Path(original_file_path).name} -&gt; {new_filename}\")\n        return new_file_path\n    except OSError as e:\n        logger.error(f\"Failed to rename file: {e}\")\n        return None\n    except FileExistsError as e:\n        logger.error(f\"Failed to rename file: {e}\")\n        return None\n</code></pre>"},{"location":"api/#mkv_episode_matcher.utils.get_subtitles","title":"get_subtitles","text":"<pre><code>get_subtitles(show_id, seasons, config=None, max_retries=3)\n</code></pre> <p>Retrieves and saves subtitles for a given TV show and seasons.</p> PARAMETER DESCRIPTION <code>show_id</code> <p>The ID of the TV show.</p> <p> TYPE: <code>int</code> </p> <code>seasons</code> <p>A set of season numbers for which subtitles should be retrieved.</p> <p> TYPE: <code>Set[int]</code> </p> <code>config</code> <p>Preloaded configuration.</p> <p> TYPE: <code>Config object</code> DEFAULT: <code>None</code> </p> <code>max_retries</code> <p>Number of times to retry subtitle download on OpenSubtitlesException. Defaults to 3.</p> <p> TYPE: <code>int</code> DEFAULT: <code>3</code> </p> Source code in <code>mkv_episode_matcher/utils.py</code> <pre><code>def get_subtitles(show_id, seasons: set[int], config=None, max_retries=3):\n    \"\"\"\n    Retrieves and saves subtitles for a given TV show and seasons.\n\n    Args:\n        show_id (int): The ID of the TV show.\n        seasons (Set[int]): A set of season numbers for which subtitles should be retrieved.\n        config (Config object, optional): Preloaded configuration.\n        max_retries (int, optional): Number of times to retry subtitle download on OpenSubtitlesException. Defaults to 3.\n    \"\"\"\n    if config is None:\n        config = get_config_manager().load()\n    show_dir = config.show_dir\n    series_name = sanitize_filename(normalize_path(show_dir).name)\n    tmdb_api_key = config.tmdb_api_key\n    open_subtitles_api_key = config.open_subtitles_api_key\n    open_subtitles_user_agent = config.open_subtitles_user_agent\n    open_subtitles_username = config.open_subtitles_username\n    open_subtitles_password = config.open_subtitles_password\n\n    if not all([\n        show_dir,\n        tmdb_api_key,\n        open_subtitles_api_key,\n        open_subtitles_user_agent,\n        open_subtitles_username,\n        open_subtitles_password,\n    ]):\n        logger.error(\"Missing configuration settings. Please run the setup script.\")\n        return\n\n    try:\n        subtitles = OpenSubtitles(open_subtitles_user_agent, open_subtitles_api_key)\n        subtitles.login(open_subtitles_username, open_subtitles_password)\n    except Exception as e:\n        logger.error(f\"Failed to log in to OpenSubtitles: {e}\")\n        return\n\n    for season in seasons:\n        episodes = fetch_season_details(show_id, season)\n        logger.info(f\"Found {episodes} episodes in Season {season}\")\n\n        for episode in range(1, episodes + 1):\n            logger.info(f\"Processing Season {season}, Episode {episode}...\")\n\n            series_cache_dir = config.cache_dir / \"data\" / series_name\n            os.makedirs(series_cache_dir, exist_ok=True)\n\n            # Check for existing subtitle in any supported format\n            existing_subtitle = find_existing_subtitle(\n                series_cache_dir, series_name, season, episode\n            )\n\n            if existing_subtitle:\n                logger.info(f\"Subtitle already exists: {Path(existing_subtitle).name}\")\n                continue\n\n            # Default to standard format for new downloads\n            srt_filepath = str(\n                series_cache_dir / f\"{series_name} - S{season:02d}E{episode:02d}.srt\"\n            )\n\n            # get the episode info from TMDB\n            url = f\"https://api.themoviedb.org/3/tv/{show_id}/season/{season}/episode/{episode}?api_key={tmdb_api_key}\"\n            response = requests.get(url)\n            response.raise_for_status()\n            episode_data = response.json()\n            episode_id = episode_data[\"id\"]\n\n            # search for the subtitle\n            response = subtitles.search(tmdb_id=episode_id, languages=\"en\")\n            if len(response.data) == 0:\n                logger.warning(\n                    f\"No subtitles found for {series_name} - S{season:02d}E{episode:02d}\"\n                )\n                continue\n\n            for subtitle in response.data:\n                subtitle_dict = subtitle.to_dict()\n                # Remove special characters and convert to uppercase\n                filename_clean = re.sub(\n                    r\"\\\\W+\", \" \", subtitle_dict[\"file_name\"]\n                ).upper()\n                if f\"E{episode:02d}\" in filename_clean:\n                    logger.info(f\"Original filename: {subtitle_dict['file_name']}\")\n                    retry_count = 0\n                    while retry_count &lt; max_retries:\n                        try:\n                            srt_file = subtitles.download_and_save(subtitle)\n                            shutil.move(srt_file, srt_filepath)\n                            logger.info(f\"Subtitle saved to {srt_filepath}\")\n                            break\n                        except OpenSubtitlesException as e:\n                            retry_count += 1\n                            logger.error(\n                                f\"OpenSubtitlesException (attempt {retry_count}): {e}\"\n                            )\n                            console.print(\n                                f\"[red]OpenSubtitlesException (attempt {retry_count}): {e}[/red]\"\n                            )\n                            if retry_count &gt;= max_retries:\n                                user_input = input(\n                                    \"Would you like to continue matching? (y/n): \"\n                                )\n                                if user_input.strip().lower() != \"y\":\n                                    logger.info(\n                                        \"User chose to stop matching due to the error.\"\n                                    )\n                                    return\n                                else:\n                                    logger.info(\n                                        \"User chose to continue matching despite the error.\"\n                                    )\n                                    break\n                        except Exception as e:\n                            logger.error(f\"Failed to download and save subtitle: {e}\")\n                            console.print(\n                                f\"[red]Failed to download and save subtitle: {e}[/red]\"\n                            )\n                            user_input = input(\n                                \"Would you like to continue matching despite the error? (y/n): \"\n                            )\n                            if user_input.strip().lower() != \"y\":\n                                logger.info(\n                                    \"User chose to stop matching due to the error.\"\n                                )\n                                return\n                            else:\n                                logger.info(\n                                    \"User chose to continue matching despite the error.\"\n                                )\n                                break\n                    else:\n                        continue\n                    break\n</code></pre>"},{"location":"api/#mkv_episode_matcher.utils.process_reference_srt_files","title":"process_reference_srt_files","text":"<pre><code>process_reference_srt_files(series_name)\n</code></pre> <p>Process reference SRT files for a given series.</p> PARAMETER DESCRIPTION <code>series_name</code> <p>The name of the series.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>dict</code> <p>A dictionary containing the reference files where the keys are the MKV filenames   and the values are the corresponding SRT texts.</p> Source code in <code>mkv_episode_matcher/utils.py</code> <pre><code>@logger.catch\ndef process_reference_srt_files(series_name):\n    \"\"\"\n    Process reference SRT files for a given series.\n\n    Args:\n        series_name (str): The name of the series.\n\n    Returns:\n        dict: A dictionary containing the reference files where the keys are the MKV filenames\n              and the values are the corresponding SRT texts.\n    \"\"\"\n    config = get_config_manager().load()\n\n    reference_files = {}\n    reference_dir = config.cache_dir / \"data\" / series_name\n\n    for dirpath, _, filenames in os.walk(reference_dir):\n        for filename in filenames:\n            if filename.lower().endswith(\".srt\"):\n                srt_file = Path(dirpath) / filename\n                logger.info(f\"Processing {srt_file}\")\n                srt_text = extract_srt_text(srt_file)\n                season, episode = extract_season_episode(filename)\n                mkv_filename = f\"{series_name} - S{season:02}E{episode:02}.mkv\"\n                reference_files[mkv_filename] = srt_text\n\n    return reference_files\n</code></pre>"},{"location":"api/#mkv_episode_matcher.utils.extract_srt_text","title":"extract_srt_text","text":"<pre><code>extract_srt_text(filepath)\n</code></pre> <p>Extracts text content from an SRT file.</p> PARAMETER DESCRIPTION <code>filepath</code> <p>Path to the SRT file.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>list</code> <p>List of text lines from the SRT file.</p> Source code in <code>mkv_episode_matcher/utils.py</code> <pre><code>def extract_srt_text(filepath):\n    \"\"\"\n    Extracts text content from an SRT file.\n\n    Args:\n        filepath (str): Path to the SRT file.\n\n    Returns:\n        list: List of text lines from the SRT file.\n    \"\"\"\n    # Read the file content\n    with open(filepath) as f:\n        content = f.read()\n\n    # Split into subtitle blocks\n    blocks = content.strip().split(\"\\n\\n\")\n\n    text_lines = []\n    for block in blocks:\n        lines = block.split(\"\\n\")\n        if len(lines) &lt; 3:\n            continue\n\n        # Skip index and timestamp, get all remaining lines as text\n        text = \" \".join(lines[2:])\n        # Remove stage directions and tags\n        text = re.sub(r\"\\[.*?\\]|\\&lt;.*?\\&gt;\", \"\", text)\n        if text:\n            text_lines.append(text)\n\n    return text_lines\n</code></pre>"},{"location":"api/#mkv_episode_matcher.utils.extract_season_episode","title":"extract_season_episode","text":"<pre><code>extract_season_episode(filename)\n</code></pre> <p>Extract season and episode numbers from filename with support for multiple formats.</p> PARAMETER DESCRIPTION <code>filename</code> <p>Filename to parse</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>tuple</code> <p>(season_number, episode_number)</p> Source code in <code>mkv_episode_matcher/utils.py</code> <pre><code>def extract_season_episode(filename):\n    \"\"\"\n    Extract season and episode numbers from filename with support for multiple formats.\n\n    Args:\n        filename (str): Filename to parse\n\n    Returns:\n        tuple: (season_number, episode_number)\n    \"\"\"\n    # List of patterns to try\n    patterns = [\n        r\"S(\\d+)E(\\d+)\",  # S01E01\n        r\"(\\d+)x(\\d+)\",  # 1x01 or 01x01\n        r\"Season\\s*(\\d+).*?(\\d+)\",  # Season 1 - 01\n    ]\n\n    for pattern in patterns:\n        match = re.search(pattern, filename, re.IGNORECASE)\n        if match:\n            return int(match.group(1)), int(match.group(2))\n\n    return None, None\n</code></pre>"},{"location":"api/#mkv_episode_matcher.utils.process_srt_files","title":"process_srt_files","text":"<pre><code>process_srt_files(show_dir)\n</code></pre> <p>Process all SRT files in the given directory and its subdirectories.</p> PARAMETER DESCRIPTION <code>show_dir</code> <p>The directory path where the SRT files are located.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>dict</code> <p>A dictionary containing the SRT file paths as keys and their corresponding text content as values.</p> Source code in <code>mkv_episode_matcher/utils.py</code> <pre><code>def process_srt_files(show_dir):\n    \"\"\"\n    Process all SRT files in the given directory and its subdirectories.\n\n    Args:\n        show_dir (str): The directory path where the SRT files are located.\n\n    Returns:\n        dict: A dictionary containing the SRT file paths as keys and their corresponding text content as values.\n    \"\"\"\n    srt_files = {}\n    for dirpath, _, filenames in os.walk(show_dir):\n        for filename in filenames:\n            if filename.lower().endswith(\".srt\"):\n                srt_file = Path(dirpath) / filename\n                logger.info(f\"Processing {srt_file}\")\n                srt_text = extract_srt_text(srt_file)\n                srt_files[srt_file] = srt_text\n    return srt_files\n</code></pre>"},{"location":"api/#mkv_episode_matcher.utils.compare_and_rename_files","title":"compare_and_rename_files","text":"<pre><code>compare_and_rename_files(\n    srt_files, reference_files, dry_run=False\n)\n</code></pre> <p>Compare the srt files with the reference files and rename the matching mkv files.</p> PARAMETER DESCRIPTION <code>srt_files</code> <p>A dictionary containing the srt files as keys and their contents as values.</p> <p> TYPE: <code>dict</code> </p> <code>reference_files</code> <p>A dictionary containing the reference files as keys and their contents as values.</p> <p> TYPE: <code>dict</code> </p> <code>dry_run</code> <p>If True, the function will only log the renaming actions without actually renaming the files. Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>mkv_episode_matcher/utils.py</code> <pre><code>def compare_and_rename_files(srt_files, reference_files, dry_run=False):\n    \"\"\"\n    Compare the srt files with the reference files and rename the matching mkv files.\n\n    Args:\n        srt_files (dict): A dictionary containing the srt files as keys and their contents as values.\n        reference_files (dict): A dictionary containing the reference files as keys and their contents as values.\n        dry_run (bool, optional): If True, the function will only log the renaming actions without actually renaming the files. Defaults to False.\n    \"\"\"\n    logger.info(\n        f\"Comparing {len(srt_files)} srt files with {len(reference_files)} reference files\"\n    )\n    for srt_text in srt_files.keys():\n        parent_dir = Path(srt_text).parent.parent\n        for reference in reference_files.keys():\n            _season, _episode = extract_season_episode(reference)\n            mkv_file = str(parent_dir / Path(srt_text).name.replace(\".srt\", \".mkv\"))\n            matching_lines = compare_text(\n                reference_files[reference], srt_files[srt_text]\n            )\n            if matching_lines &gt;= int(len(reference_files[reference]) * 0.1):\n                logger.info(f\"Matching lines: {matching_lines}\")\n                logger.info(f\"Found matching file: {mkv_file} -&gt;{reference}\")\n                new_filename = parent_dir / reference\n                if not dry_run:\n                    logger.info(f\"Renaming {mkv_file} to {str(new_filename)}\")\n                    rename_episode_file(mkv_file, reference)\n</code></pre>"},{"location":"api/#mkv_episode_matcher.utils.compare_text","title":"compare_text","text":"<pre><code>compare_text(text1, text2)\n</code></pre> <p>Compare two lists of text lines and return the number of matching lines.</p> PARAMETER DESCRIPTION <code>text1</code> <p>List of text lines from the first source.</p> <p> TYPE: <code>list</code> </p> <code>text2</code> <p>List of text lines from the second source.</p> <p> TYPE: <code>list</code> </p> RETURNS DESCRIPTION <code>int</code> <p>Number of matching lines between the two sources.</p> Source code in <code>mkv_episode_matcher/utils.py</code> <pre><code>def compare_text(text1, text2):\n    \"\"\"\n    Compare two lists of text lines and return the number of matching lines.\n\n    Args:\n        text1 (list): List of text lines from the first source.\n        text2 (list): List of text lines from the second source.\n\n    Returns:\n        int: Number of matching lines between the two sources.\n    \"\"\"\n    # Flatten the list of text lines\n    flat_text1 = [line for lines in text1 for line in lines]\n    flat_text2 = [line for lines in text2 for line in lines]\n\n    # Compare the two lists of text lines\n    matching_lines = set(flat_text1).intersection(flat_text2)\n    return len(matching_lines)\n</code></pre>"}]}
{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"MKV Episode Matcher","text":"<p>Automatically match and rename your MKV TV episodes using The Movie Database (TMDb).</p>"},{"location":"#features","title":"Features","text":"<ul> <li>\ud83c\udfaf Automatic Episode Matching: Uses TMDb to accurately identify episodes</li> <li>\ud83d\udcdd Subtitle Extraction: Extracts subtitles from MKV files</li> <li>\ud83d\udd0d OCR Support: Handles image-based subtitles</li> <li>\ud83d\ude80 Multi-threaded: Fast processing of multiple files</li> <li>\u2b07\ufe0f Subtitle Downloads: Integration with OpenSubtitles</li> <li>\u2728 Bulk Processing: Handle entire seasons at once</li> <li>\ud83e\uddea Dry Run Mode: Test changes before applying</li> </ul>"},{"location":"#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.9 or higher</li> <li>FFmpeg installed and available in system PATH</li> <li>Tesseract OCR installed (required for image-based subtitle processing)</li> <li>TMDb API key (optional, for subtitle downloads)</li> <li>OpenSubtitles account (optional, for subtitle downloads)</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":"<ol> <li>Install the package: <pre><code>pip install mkv-episode-matcher\n</code></pre></li> <li> <p>Download .srt subtitles files to ~/.mkv-episode-matcher/cache/data/Show Name/</p> </li> <li> <p>Run on your show directory: <pre><code>mkv-match --show-dir \"path/to/your/show\"\n</code></pre></p> </li> </ol>"},{"location":"#directory-structure","title":"Directory Structure","text":"<p>MKV Episode Matcher expects your TV shows to be organized as follows:</p> <pre><code>Show Name/\n\u251c\u2500\u2500 Season 1/\n\u2502   \u251c\u2500\u2500 episode1.mkv\n\u2502   \u251c\u2500\u2500 episode2.mkv\n\u251c\u2500\u2500 Season 2/\n\u2502   \u251c\u2500\u2500 episode1.mkv\n\u2502   \u2514\u2500\u2500 episode2.mkv\n</code></pre>"},{"location":"#reference-subtitle-file-structure","title":"Reference Subtitle File Structure","text":"<p>Subtitle files that are not automatically downloaded using the <code>--get-subs</code> flag should be named as follows:</p> <pre><code>~/.mkv-episode-matcher/cache/data/Show Name/\n\u251c\u2500\u2500 Show Name - S01E01.srt\n\u251c\u2500\u2500 Show Name - S01E02.srt\n\u2514\u2500\u2500 ...\n</code></pre> <p>On Windows, the cache directory is located at <code>C:\\Users\\{username}\\.mkv-episode-matcher\\cache\\data\\</code></p> <p>Reference subtitle files should follow this naming pattern: <code>{show_name} - S{season:02d}E{episode:02d}.srt</code></p>"},{"location":"#contributing","title":"Contributing","text":"<ol> <li>Fork the repository</li> <li>Create a feature branch (<code>git checkout -b feature/amazing-feature</code>)</li> <li>Commit your changes (<code>git commit -m 'Add amazing feature'</code>)</li> <li>Push to the branch (<code>git push origin feature/amazing-feature</code>)</li> <li>Open a Pull Request</li> </ol>"},{"location":"#license","title":"License","text":"<p>Distributed under the MIT License. See <code>LICENSE</code> for more information.</p>"},{"location":"#acknowledgments","title":"Acknowledgments","text":"<ul> <li>TMDb for their excellent API</li> <li>OpenSubtitles for subtitle integration</li> <li>All contributors who have helped improve this project</li> </ul>"},{"location":"#documentation","title":"Documentation","text":"<p>Full documentation is available at https://jsakkos.github.io/mkv-episode-matcher/</p>"},{"location":"cli/","title":"Command Line Interface","text":""},{"location":"cli/#basic-commands","title":"Basic Commands","text":""},{"location":"cli/#process-show","title":"Process Show","text":"<pre><code>mkv-match --show-dir \"/path/to/show\"\n</code></pre>"},{"location":"cli/#process-specific-season","title":"Process Specific Season","text":"<pre><code>mkv-match --show-dir \"/path/to/show\" --season 1\n</code></pre>"},{"location":"cli/#command-options","title":"Command Options","text":"Option Description Default <code>--show-dir</code> Show directory path None <code>--season</code> Season number to process None (all) <code>--dry-run</code> Test without making changes False <code>--get-subs</code> Download subtitles False <code>--tmdb-api-key</code> TMDb API key None <code>--tesseract-path</code> Path to Tesseract None"},{"location":"cli/#examples","title":"Examples","text":""},{"location":"cli/#dry-run-mode","title":"Dry Run Mode","text":"<pre><code>mkv-match --show-dir \"/path/to/show\" --dry-run true\n</code></pre>"},{"location":"cli/#download-subtitles","title":"Download Subtitles","text":"<pre><code>mkv-match --show-dir \"/path/to/show\" --get-subs true\n</code></pre>"},{"location":"cli/#set-api-key","title":"Set API Key","text":"<pre><code>mkv-match --show-dir \"/path/to/show\" --tmdb-api-key \"your_key\"\n</code></pre>"},{"location":"cli/#multiple-options","title":"Multiple Options","text":"<pre><code>mkv-match \\\n  --show-dir \"/path/to/show\" \\\n  --season 1 \\\n  --get-subs true \\\n  --dry-run true\n</code></pre>"},{"location":"cli/#logging","title":"Logging","text":"<p>Logs are stored in: <pre><code>~/.mkv-episode-matcher/logs/\n\u251c\u2500\u2500 stdout.log\n\u2514\u2500\u2500 stderr.log\n</code></pre></p>"},{"location":"cli/#tips","title":"Tips","text":"<ol> <li>Always use quotes around paths</li> <li>Use dry-run first to test</li> <li>Check logs for details</li> <li>Use full paths for reliability</li> <li>Avoid using a trailing slash in paths</li> </ol>"},{"location":"configuration/","title":"Configuration Guide","text":""},{"location":"configuration/#configuration-file","title":"Configuration File","text":"<p>MKV Episode Matcher uses a configuration file located at:</p> <ul> <li>Windows: <code>%USERPROFILE%\\.mkv-episode-matcher\\config.ini</code></li> <li>Linux/Mac: <code>~/.mkv-episode-matcher/config.ini</code></li> </ul>"},{"location":"configuration/#configuration-options","title":"Configuration Options","text":"<pre><code>[Config]\n# Required Settings\ntmdb_api_key = your_tmdb_api_key\nshow_dir = /path/to/shows\n\n# Optional Settings\nmax_threads = 4\nopen_subtitles_api_key = your_opensubs_key\nopen_subtitles_user_agent = your_user_agent\nopen_subtitles_username = your_username\nopen_subtitles_password = your_password\ntesseract_path = /path/to/tesseract\n</code></pre>"},{"location":"configuration/#command-line-configuration","title":"Command Line Configuration","text":"<p>All configuration options can be set via command line:</p> <pre><code>mkv-match \\\n  --tmdb-api-key \"your_key\" \\\n  --show-dir \"/path/to/shows\" \\\n  --season 1 \\\n  --dry-run true \\\n  --get-subs true \\\n  --tesseract-path \"/path/to/tesseract\"\n</code></pre>"},{"location":"configuration/#environment-variables","title":"Environment Variables","text":"<p>You can also use environment variables:</p> <pre><code>export TMDB_API_KEY=\"your_key\"\nexport SHOW_DIR=\"/path/to/shows\"\nexport OPEN_SUBTITLES_API_KEY=\"your_key\"\n</code></pre>"},{"location":"configuration/#configuration-priority","title":"Configuration Priority","text":"<p>Settings are loaded in the following order (later overrides earlier):</p> <ol> <li>Default values</li> <li>Configuration file</li> <li>Environment variables</li> <li>Command line arguments</li> </ol>"},{"location":"configuration/#detailed-options","title":"Detailed Options","text":""},{"location":"configuration/#tmdb-configuration","title":"TMDb Configuration","text":"<pre><code>[Config]\ntmdb_api_key = your_api_key\n</code></pre> <p>The TMDb API key is required for: - Show identification - Episode information - Season details</p>"},{"location":"configuration/#opensubtitles-configuration","title":"OpenSubtitles Configuration","text":"<pre><code>[Config]\nopen_subtitles_api_key = your_key\nopen_subtitles_user_agent = your_agent\nopen_subtitles_username = username\nopen_subtitles_password = password\n</code></pre> <p>Required only if using subtitle download functionality.</p>"},{"location":"configuration/#performance-settings","title":"Performance Settings","text":"<pre><code>[Config]\nmax_threads = 4\n</code></pre> <p>Adjust based on your system's capabilities: - Default: 4 threads - Minimum: 1 thread - Maximum: Number of CPU cores</p>"},{"location":"configuration/#ocr-configuration","title":"OCR Configuration","text":"<pre><code>[Config]\ntesseract_path = /path/to/tesseract\n</code></pre> <p>Required for processing image-based subtitles. Common paths: - Windows: <code>C:\\Program Files\\Tesseract-OCR\\tesseract.exe</code> - Linux/macOS: <code>/usr/bin/tesseract</code></p> <p>Make sure Tesseract OCR is properly installed before using this feature.</p>"},{"location":"installation/","title":"Installation Guide","text":""},{"location":"installation/#prerequisites","title":"Prerequisites","text":""},{"location":"installation/#required-system-dependencies","title":"Required System Dependencies","text":"<ol> <li>FFmpeg</li> <li>Windows: Download from FFmpeg website</li> <li>Linux: <code>sudo apt install ffmpeg</code> or equivalent</li> <li>macOS: <code>brew install ffmpeg</code></li> <li> <p>Verify installation: <code>ffmpeg -version</code></p> </li> <li> <p>Tesseract OCR</p> </li> <li>Windows: Install from UB-Mannheim</li> <li>Linux: <code>sudo apt install tesseract-ocr</code> or equivalent</li> <li>macOS: <code>brew install tesseract</code></li> <li>Verify installation: <code>tesseract --version</code></li> </ol> <p>Make sure both FFmpeg and Tesseract are added to your system PATH.</p>"},{"location":"installation/#basic-installation","title":"Basic Installation","text":"<p>Install MKV Episode Matcher using pip:</p> <pre><code>pip install mkv-episode-matcher\n</code></pre>"},{"location":"installation/#installation-options","title":"Installation Options","text":""},{"location":"installation/#gpu-support","title":"GPU Support","text":"<p>For GPU acceleration (recommended if you have a CUDA-capable GPU):</p> <p><pre><code>pip install \"mkv-episode-matcher\"\n</code></pre> Find the appropriate CUDA version and upgrade Torch (e.g., for CUDA 12.4) from the compatibility matrix: <pre><code>pip install -U torch torchvision torchaudio --index-url https://download.pytorch.org/whl/cu124\n\n# Verify GPU availability\nmkv-match --check-gpu true\n</code></pre></p>"},{"location":"installation/#development-installation","title":"Development Installation","text":"<p>For contributing or development:</p> <pre><code># Clone the repository\ngit clone https://github.com/Jsakkos/mkv-episode-matcher.git\ncd mkv-episode-matcher\n\n# Install UV\npip install uv\n\n# Install with development dependencies\nuv sync --dev\n</code></pre>"},{"location":"installation/#api-keys-setup","title":"API Keys Setup","text":"<ol> <li> <p>TMDb API Key (Optional)</p> <ul> <li>Create an account at TMDb</li> <li>Go to your account settings</li> <li>Request an API key</li> </ul> </li> <li> <p>OpenSubtitles (Optional)</p> <ul> <li>Register at OpenSubtitles</li> <li>Get your API key from the dashboard</li> </ul> </li> </ol>"},{"location":"installation/#system-requirements","title":"System Requirements","text":""},{"location":"installation/#for-gpu-support","title":"For GPU Support","text":"<ul> <li>CUDA-capable NVIDIA GPU</li> <li>CUDA Toolkit 12.1 or compatible version</li> <li>At least 4GB GPU memory recommended for Whisper speech recognition</li> </ul>"},{"location":"installation/#for-cpu-only","title":"For CPU-Only","text":"<ul> <li>No special requirements beyond Python 3.9+</li> </ul>"},{"location":"installation/#verification","title":"Verification","text":"<p>Verify your installation:</p> <pre><code>mkv-match --version\n\n# Check GPU availability (if installed with GPU support)\nmkv-match --check-gpu true\n</code></pre>"},{"location":"installation/#troubleshooting","title":"Troubleshooting","text":"<p>If you encounter any issues:</p> <ol> <li>Ensure you have the latest pip: <code>pip install --upgrade pip</code></li> <li>For GPU installations, verify CUDA is properly installed</li> <li>Check the compatibility matrix for PyTorch and CUDA versions</li> <li>If you encounter any other issues, please open an issue on GitHub</li> </ol>"},{"location":"quickstart/","title":"Quick Start Guide","text":"<p>Get started with MKV Episode Matcher in minutes.</p>"},{"location":"quickstart/#basic-usage","title":"Basic Usage","text":""},{"location":"quickstart/#1-process-a-single-season","title":"1. Process a Single Season","text":"<pre><code>mkv-match --show-dir \"/path/to/show\" --season 1\n</code></pre>"},{"location":"quickstart/#2-process-all-seasons","title":"2. Process All Seasons","text":"<pre><code>mkv-match --show-dir \"/path/to/show\"\n</code></pre>"},{"location":"quickstart/#3-test-run-no-changes","title":"3. Test Run (No Changes)","text":"<pre><code>mkv-match --show-dir \"/path/to/show\" --dry-run true\n</code></pre>"},{"location":"quickstart/#4-download-subtitles","title":"4. Download Subtitles","text":"<pre><code>mkv-match --show-dir \"/path/to/show\" --get-subs true\n</code></pre>"},{"location":"quickstart/#directory-structure","title":"Directory Structure","text":"<p>MKV Episode Matcher expects your TV shows to be organized as follows:</p> <pre><code>Show Name/\n\u251c\u2500\u2500 Season 1/\n\u2502   \u251c\u2500\u2500 episode1.mkv\n\u2502   \u251c\u2500\u2500 episode2.mkv\n\u251c\u2500\u2500 Season 2/\n\u2502   \u251c\u2500\u2500 episode1.mkv\n\u2502   \u2514\u2500\u2500 episode2.mkv\n</code></pre>"},{"location":"quickstart/#reference-subtitle-file-structure","title":"Reference Subtitle File Structure","text":"<p>Subtitle files that are not automatically downloaded using the <code>--get-subs</code> flag should be named as follows:</p> <pre><code>~/.mkv-episode-matcher/cache/data/Show Name/\n\u251c\u2500\u2500 Show Name - S01E01.srt\n\u251c\u2500\u2500 Show Name - S01E02.srt\n\u2514\u2500\u2500 ...\n</code></pre>"},{"location":"quickstart/#configuration","title":"Configuration","text":"<p>The configuration file is automatically generated at <code>~/.mkv-episode-matcher/config.ini</code>:</p> <pre><code>[Config]\ntmdb_api_key = your_tmdb_api_key\nshow_dir = /path/to/show\nmax_threads = 4\nopen_subtitles_api_key = your_opensubs_key\nopen_subtitles_user_agent = your_user_agent\nopen_subtitles_username = your_username\nopen_subtitles_password = your_password\ntesseract_path = C:\\Program Files\\Tesseract-OCR\\tesseract.exe\n</code></pre>"},{"location":"quickstart/#next-steps","title":"Next Steps","text":"<ul> <li>Check the Configuration Guide for detailed setup</li> <li>See Tips and Tricks for advanced usage</li> <li>Browse the API Reference for detailed documentation</li> </ul>"},{"location":"tips/","title":"Tips and Tricks","text":""},{"location":"tips/#best-practices","title":"Best Practices","text":""},{"location":"tips/#directory-organization","title":"Directory Organization","text":"<p>Organize your files consistently: <pre><code>TV Shows/\n\u251c\u2500\u2500 Show Name/\n\u2502   \u251c\u2500\u2500 Season 1/\n\u2502   \u2502   \u251c\u2500\u2500 episode1.mkv\n\u2502   \u2502   \u2514\u2500\u2500 episode2.mkv\n\u2502   \u2514\u2500\u2500 Season 2/\n\u2502       \u251c\u2500\u2500 episode1.mkv\n\u2502       \u2514\u2500\u2500 episode2.mkv\n</code></pre></p>"},{"location":"tips/#performance-optimization","title":"Performance Optimization","text":"<ol> <li> <p>Thread Configuration <pre><code>[Config]\nmax_threads = 4  # Adjust based on CPU cores\n</code></pre></p> </li> <li> <p>Batch Processing <pre><code># Process multiple seasons\nfor i in {1..5}; do\n  mkv-match --show-dir \"/path/to/show\" --season $i\ndone\n</code></pre></p> </li> </ol>"},{"location":"tips/#error-handling","title":"Error Handling","text":"<ol> <li> <p>Always use dry-run first:    <pre><code>mkv-match --show-dir \"/path/to/show\" --dry-run true\n</code></pre></p> </li> <li> <p>Check logs regularly:    <pre><code>tail -f ~/.mkv-episode-matcher/logs/stderr.log\n</code></pre></p> </li> </ol>"},{"location":"tips/#advanced-usage","title":"Advanced Usage","text":""},{"location":"tips/#custom-matching","title":"Custom Matching","text":"<pre><code>from mkv_episode_matcher import process_show\n\n# Custom matching with specific settings\nprocess_show(\n    season=1,\n    dry_run=True,\n    get_subs=True\n)\n</code></pre>"},{"location":"tips/#subtitle-processing","title":"Subtitle Processing","text":"<ol> <li> <p>Extract subtitles only:    <pre><code>from mkv_episode_matcher.mkv_to_srt import convert_mkv_to_srt\nconvert_mkv_to_srt(season_path, mkv_files)\n</code></pre></p> </li> <li> <p>Download specific subtitles:    <pre><code>from mkv_episode_matcher.utils import get_subtitles\nget_subtitles(show_id, {1, 2, 3})  # Seasons 1, 2, 3\n</code></pre></p> </li> </ol>"},{"location":"tips/#troubleshooting","title":"Troubleshooting","text":""},{"location":"tips/#common-issues","title":"Common Issues","text":"<ol> <li> <p>File Permission Errors <pre><code># Check file permissions\nchmod -R 644 \"/path/to/show\"\n</code></pre></p> </li> <li> <p>API Rate Limits</p> </li> <li>Use rate limiting in configuration</li> <li> <p>Implement exponential backoff</p> </li> <li> <p>Memory Usage</p> </li> <li>Reduce max_threads</li> <li>Process seasons separately</li> </ol>"},{"location":"tips/#maintenance","title":"Maintenance","text":""},{"location":"tips/#clean-up","title":"Clean Up","text":"<ol> <li> <p>Remove temporary files:    <pre><code>from mkv_episode_matcher.utils import cleanup_ocr_files\ncleanup_ocr_files(show_dir)\n</code></pre></p> </li> <li> <p>Clear cache:    <pre><code>rm -rf ~/.mkv-episode-matcher/cache/*\n</code></pre></p> </li> </ol>"},{"location":"tips/#backup-strategy","title":"Backup Strategy","text":"<ol> <li> <p>Create backups before processing:    <pre><code>cp -r \"/path/to/show\" \"/path/to/backup\"\n</code></pre></p> </li> <li> <p>Use dry-run to verify changes:    <pre><code>mkv-match --show-dir \"/path/to/show\" --dry-run true\n</code></pre></p> </li> </ol>"},{"location":"tips/#integration-tips","title":"Integration Tips","text":""},{"location":"tips/#automation","title":"Automation","text":"<ol> <li> <p>Cron Jobs <pre><code># Check for new episodes daily\n0 0 * * * mkv-match --show-dir \"/path/to/show\" --get-subs true\n</code></pre></p> </li> <li> <p>Watch Folders <pre><code># Monitor for new files\nfrom watchdog.observers import Observer\nfrom watchdog.events import FileSystemEventHandler\n</code></pre></p> </li> </ol>"},{"location":"tips/#api-usage","title":"API Usage","text":"<ol> <li> <p>Rate limiting:    <pre><code>from mkv_episode_matcher.tmdb_client import RateLimitedRequest\nrequest = RateLimitedRequest(rate_limit=30, period=1)\n</code></pre></p> </li> <li> <p>Cache management:    <pre><code># Cache API responses\nimport shelve\nwith shelve.open('cache') as db:\n    # Cache operations\n</code></pre></p> </li> </ol>"},{"location":"api/","title":"API Reference","text":"<p>This section contains the automatically generated API documentation for MKV Episode Matcher.</p>"},{"location":"api/#core-modules","title":"Core Modules","text":""},{"location":"api/#mkv_episode_matcher.episode_matcher","title":"mkv_episode_matcher.episode_matcher","text":""},{"location":"api/#mkv_episode_matcher.episode_matcher-classes","title":"Classes","text":""},{"location":"api/#mkv_episode_matcher.episode_matcher-functions","title":"Functions","text":""},{"location":"api/#mkv_episode_matcher.episode_matcher.process_show","title":"process_show","text":"<pre><code>process_show(season=None, dry_run=False, get_subs=False)\n</code></pre> <p>Process the show using streaming speech recognition with OCR fallback.</p> Source code in <code>mkv_episode_matcher/episode_matcher.py</code> <pre><code>def process_show(season=None, dry_run=False, get_subs=False):\n    \"\"\"Process the show using streaming speech recognition with OCR fallback.\"\"\"\n    config = get_config(CONFIG_FILE)\n    show_dir = config.get(\"show_dir\")\n    show_name = clean_text(os.path.basename(show_dir))\n    matcher = EpisodeMatcher(CACHE_DIR, show_name)\n\n    # Early check for reference files\n    reference_dir = Path(CACHE_DIR) / \"data\" / show_name\n    reference_files = list(reference_dir.glob(\"*.srt\"))\n    if (not get_subs) and (not reference_files):\n        logger.error(f\"No reference subtitle files found in {reference_dir}\")\n        logger.info(\"Please download reference subtitles first\")\n        return\n\n    season_paths = get_valid_seasons(show_dir)\n    if not season_paths:\n        logger.warning(f\"No seasons with .mkv files found\")\n        return\n\n    if season is not None:\n        season_path = os.path.join(show_dir, f\"Season {season}\")\n        if season_path not in season_paths:\n            logger.warning(f\"Season {season} has no .mkv files to process\")\n            return\n        season_paths = [season_path]\n\n    for season_path in season_paths:\n        mkv_files = [f for f in glob.glob(os.path.join(season_path, \"*.mkv\"))\n                    if not check_filename(f)]\n\n        if not mkv_files:\n            logger.info(f\"No new files to process in {season_path}\")\n            continue\n\n        season_num = int(re.search(r'Season (\\d+)', season_path).group(1))\n        temp_dir = Path(season_path) / \"temp\"\n        ocr_dir = Path(season_path) / \"ocr\"\n        temp_dir.mkdir(exist_ok=True)\n        ocr_dir.mkdir(exist_ok=True)\n\n        try:\n            if get_subs:\n                show_id = fetch_show_id(matcher.show_name)\n                if show_id:\n                    get_subtitles(show_id, seasons={season_num}, config=config)\n\n            unmatched_files = []\n            for mkv_file in mkv_files:\n                logger.info(f\"Attempting speech recognition match for {mkv_file}\")\n                match = matcher.identify_episode(mkv_file, temp_dir, season_num)\n\n                if match:\n                    new_name = f\"{matcher.show_name} - S{match['season']:02d}E{match['episode']:02d}.mkv\"\n                    logger.info(f\"Speech matched {os.path.basename(mkv_file)} to {new_name} \"\n                              f\"(confidence: {match['confidence']:.2f})\")\n\n                    if not dry_run:\n                        logger.info(f\"Renaming {mkv_file} to {new_name}\")\n                        rename_episode_file(mkv_file, new_name)\n                else:\n                    logger.info(f\"Speech recognition match failed for {mkv_file}, trying OCR\")\n                    unmatched_files.append(mkv_file)\n\n            # OCR fallback for unmatched files\n            if unmatched_files:\n                logger.info(f\"Attempting OCR matching for {len(unmatched_files)} unmatched files\")\n                convert_mkv_to_srt(season_path, unmatched_files)\n\n                reference_text_dict = process_reference_srt_files(matcher.show_name)\n                srt_text_dict = process_srt_files(str(ocr_dir))\n\n                compare_and_rename_files(\n                    srt_text_dict, \n                    reference_text_dict, \n                    dry_run=dry_run,\n                )\n\n        finally:\n            if not dry_run:\n                shutil.rmtree(temp_dir)\n                cleanup_ocr_files(show_dir)\n</code></pre>"},{"location":"api/#tmdb-client","title":"TMDB Client","text":""},{"location":"api/#mkv_episode_matcher.tmdb_client","title":"mkv_episode_matcher.tmdb_client","text":""},{"location":"api/#mkv_episode_matcher.tmdb_client-classes","title":"Classes","text":""},{"location":"api/#mkv_episode_matcher.tmdb_client.RateLimitedRequest","title":"RateLimitedRequest","text":"<pre><code>RateLimitedRequest(rate_limit=30, period=1)\n</code></pre> <p>A class that represents a rate-limited request object.</p> ATTRIBUTE DESCRIPTION <code>rate_limit</code> <p>Maximum number of requests allowed per period.</p> <p> TYPE: <code>int</code> </p> <code>period</code> <p>Period in seconds.</p> <p> TYPE: <code>int</code> </p> <code>requests_made</code> <p>Counter for requests made.</p> <p> TYPE: <code>int</code> </p> <code>start_time</code> <p>Start time of the current period.</p> <p> TYPE: <code>float</code> </p> <code>lock</code> <p>Lock for synchronization.</p> <p> TYPE: <code>Lock</code> </p> Source code in <code>mkv_episode_matcher/tmdb_client.py</code> <pre><code>def __init__(self, rate_limit=30, period=1):\n    self.rate_limit = rate_limit\n    self.period = period\n    self.requests_made = 0\n    self.start_time = time.time()\n    self.lock = Lock()\n</code></pre>"},{"location":"api/#mkv_episode_matcher.tmdb_client.RateLimitedRequest-functions","title":"Functions","text":""},{"location":"api/#mkv_episode_matcher.tmdb_client.RateLimitedRequest.get","title":"get","text":"<pre><code>get(url)\n</code></pre> <p>Sends a rate-limited GET request to the specified URL.</p> PARAMETER DESCRIPTION <code>url</code> <p>The URL to send the request to.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Response</code> <p>The response object returned by the request.</p> Source code in <code>mkv_episode_matcher/tmdb_client.py</code> <pre><code>def get(self, url):\n    \"\"\"\n    Sends a rate-limited GET request to the specified URL.\n\n    Args:\n        url (str): The URL to send the request to.\n\n    Returns:\n        Response: The response object returned by the request.\n    \"\"\"\n    with self.lock:\n        if self.requests_made &gt;= self.rate_limit:\n            sleep_time = self.period - (time.time() - self.start_time)\n            if sleep_time &gt; 0:\n                time.sleep(sleep_time)\n            self.requests_made = 0\n            self.start_time = time.time()\n\n        self.requests_made += 1\n\n    response = requests.get(url)\n    return response\n</code></pre>"},{"location":"api/#mkv_episode_matcher.tmdb_client-functions","title":"Functions","text":""},{"location":"api/#mkv_episode_matcher.tmdb_client.fetch_show_id","title":"fetch_show_id","text":"<pre><code>fetch_show_id(show_name)\n</code></pre> <p>Fetch the TMDb ID for a given show name.</p> PARAMETER DESCRIPTION <code>show_name</code> <p>The name of the show.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>str</code> <p>The TMDb ID of the show, or None if not found.</p> Source code in <code>mkv_episode_matcher/tmdb_client.py</code> <pre><code>def fetch_show_id(show_name):\n    \"\"\"\n    Fetch the TMDb ID for a given show name.\n\n    Args:\n        show_name (str): The name of the show.\n\n    Returns:\n        str: The TMDb ID of the show, or None if not found.\n    \"\"\"\n    config = get_config(CONFIG_FILE)\n    tmdb_api_key = config.get(\"tmdb_api_key\")\n    url = f\"https://api.themoviedb.org/3/search/tv?query={show_name}&amp;api_key={tmdb_api_key}\"\n    response = requests.get(url)\n    if response.status_code == 200:\n        results = response.json().get(\"results\", [])\n        if results:\n            return str(results[0][\"id\"])\n    return None\n</code></pre>"},{"location":"api/#mkv_episode_matcher.tmdb_client.fetch_season_details","title":"fetch_season_details","text":"<pre><code>fetch_season_details(show_id, season_number)\n</code></pre> <p>Fetch the total number of episodes for a given show and season from the TMDb API.</p> PARAMETER DESCRIPTION <code>show_id</code> <p>The ID of the show on TMDb.</p> <p> TYPE: <code>str</code> </p> <code>season_number</code> <p>The season number to fetch details for.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>int</code> <p>The total number of episodes in the season, or 0 if the API request failed.</p> Source code in <code>mkv_episode_matcher/tmdb_client.py</code> <pre><code>def fetch_season_details(show_id, season_number):\n    \"\"\"\n    Fetch the total number of episodes for a given show and season from the TMDb API.\n\n    Args:\n        show_id (str): The ID of the show on TMDb.\n        season_number (int): The season number to fetch details for.\n\n    Returns:\n        int: The total number of episodes in the season, or 0 if the API request failed.\n    \"\"\"\n    logger.info(f\"Fetching season details for Season {season_number}...\")\n    config = get_config(CONFIG_FILE)\n    tmdb_api_key = config.get(\"tmdb_api_key\")\n    url = f\"https://api.themoviedb.org/3/tv/{show_id}/season/{season_number}?api_key={tmdb_api_key}\"\n    try:\n        response = requests.get(url)\n        response.raise_for_status()\n        season_data = response.json()\n        total_episodes = len(season_data.get(\"episodes\", []))\n        return total_episodes\n    except requests.exceptions.RequestException as e:\n        logger.error(f\"Failed to fetch season details for Season {season_number}: {e}\")\n        return 0\n    except KeyError:\n        logger.error(\n            f\"Missing 'episodes' key in response JSON data for Season {season_number}\"\n        )\n        return 0\n</code></pre>"},{"location":"api/#mkv_episode_matcher.tmdb_client.get_number_of_seasons","title":"get_number_of_seasons","text":"<pre><code>get_number_of_seasons(show_id)\n</code></pre> <p>Retrieves the number of seasons for a given TV show from the TMDB API.</p> <p>Parameters: - show_id (int): The ID of the TV show.</p> <p>Returns: - num_seasons (int): The number of seasons for the TV show.</p> <p>Raises: - requests.HTTPError: If there is an error while making the API request.</p> Source code in <code>mkv_episode_matcher/tmdb_client.py</code> <pre><code>def get_number_of_seasons(show_id):\n    \"\"\"\n    Retrieves the number of seasons for a given TV show from the TMDB API.\n\n    Parameters:\n    - show_id (int): The ID of the TV show.\n\n    Returns:\n    - num_seasons (int): The number of seasons for the TV show.\n\n    Raises:\n    - requests.HTTPError: If there is an error while making the API request.\n    \"\"\"\n    config = get_config(CONFIG_FILE)\n    tmdb_api_key = config.get(\"tmdb_api_key\")\n    url = f\"https://api.themoviedb.org/3/tv/{show_id}?api_key={tmdb_api_key}\"\n    response = requests.get(url)\n    response.raise_for_status()\n    show_data = response.json()\n    num_seasons = show_data.get(\"number_of_seasons\", 0)\n    logger.info(f\"Found {num_seasons} seasons\")\n    return num_seasons\n</code></pre>"},{"location":"api/#mkv-converter","title":"MKV Converter","text":""},{"location":"api/#mkv_episode_matcher.mkv_to_srt","title":"mkv_episode_matcher.mkv_to_srt","text":""},{"location":"api/#mkv_episode_matcher.mkv_to_srt-functions","title":"Functions","text":""},{"location":"api/#mkv_episode_matcher.mkv_to_srt.check_if_processed","title":"check_if_processed","text":"<pre><code>check_if_processed(filename)\n</code></pre> <p>Check if the file has already been processed (has SxxExx format)</p> PARAMETER DESCRIPTION <code>filename</code> <p>Filename to check</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if file is already processed</p> <p> TYPE: <code>bool</code> </p> Source code in <code>mkv_episode_matcher/mkv_to_srt.py</code> <pre><code>def check_if_processed(filename: str) -&gt; bool:\n    \"\"\"\n    Check if the file has already been processed (has SxxExx format)\n\n    Args:\n        filename (str): Filename to check\n\n    Returns:\n        bool: True if file is already processed\n    \"\"\"\n    import re\n    match = re.search(r\"S\\d+E\\d+\", filename)\n    return bool(match)\n</code></pre>"},{"location":"api/#mkv_episode_matcher.mkv_to_srt.convert_mkv_to_sup","title":"convert_mkv_to_sup","text":"<pre><code>convert_mkv_to_sup(mkv_file, output_dir)\n</code></pre> <p>Convert an .mkv file to a .sup file using FFmpeg and pgs2srt.</p> PARAMETER DESCRIPTION <code>mkv_file</code> <p>Path to the .mkv file.</p> <p> TYPE: <code>str</code> </p> <code>output_dir</code> <p>Path to the directory where the .sup file will be saved.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>str</code> <p>Path to the converted .sup file.</p> Source code in <code>mkv_episode_matcher/mkv_to_srt.py</code> <pre><code>def convert_mkv_to_sup(mkv_file, output_dir):\n    \"\"\"\n    Convert an .mkv file to a .sup file using FFmpeg and pgs2srt.\n\n    Args:\n        mkv_file (str): Path to the .mkv file.\n        output_dir (str): Path to the directory where the .sup file will be saved.\n\n    Returns:\n        str: Path to the converted .sup file.\n    \"\"\"\n    # Get the base name of the .mkv file without the extension\n    base_name = os.path.splitext(os.path.basename(mkv_file))[0]\n\n    # Construct the output .sup file path\n    sup_file = os.path.join(output_dir, f\"{base_name}.sup\")\n    if not os.path.exists(sup_file):\n        logger.info(f\"Processing {mkv_file} to {sup_file}\")\n        # FFmpeg command to convert .mkv to .sup\n        ffmpeg_cmd = [\"ffmpeg\", \"-i\", mkv_file, \"-map\", \"0:s:0\", \"-c\", \"copy\", sup_file]\n        try:\n            subprocess.run(ffmpeg_cmd, check=True)\n            logger.info(f\"Converted {mkv_file} to {sup_file}\")\n        except subprocess.CalledProcessError as e:\n            logger.error(f\"Error converting {mkv_file}: {e}\")\n    else:\n        logger.info(f\"File {sup_file} already exists, skipping\")\n    return sup_file\n</code></pre>"},{"location":"api/#mkv_episode_matcher.mkv_to_srt.perform_ocr","title":"perform_ocr","text":"<pre><code>perform_ocr(sup_file_path)\n</code></pre> <p>Perform OCR on a .sup file and save the extracted text to a .srt file. Returns the path to the created SRT file.</p> Source code in <code>mkv_episode_matcher/mkv_to_srt.py</code> <pre><code>@logger.catch\ndef perform_ocr(sup_file_path: str) -&gt; Optional[str]:\n    \"\"\"\n    Perform OCR on a .sup file and save the extracted text to a .srt file.\n    Returns the path to the created SRT file.\n    \"\"\"\n    # Get the base name of the .sup file without the extension\n    base_name = os.path.splitext(os.path.basename(sup_file_path))[0]\n    output_dir = os.path.dirname(sup_file_path)\n    logger.info(f\"Performing OCR on {sup_file_path}\")\n\n    # Construct the output .srt file path\n    srt_file = os.path.join(output_dir, f\"{base_name}.srt\")\n\n    if os.path.exists(srt_file):\n        logger.info(f\"SRT file {srt_file} already exists, skipping OCR\")\n        return srt_file\n\n    # Load a PGS/SUP file.\n    pgs = PGSReader(sup_file_path)\n\n    # Set index\n    i = 0\n\n    # Complete subtitle track index\n    si = 0\n\n    tesseract_lang = \"eng\"\n    tesseract_config = f\"-c tessedit_char_blacklist=[] --psm 6 --oem {1}\"\n\n    config = get_config(CONFIG_FILE)\n    tesseract_path = config.get(\"tesseract_path\")\n    logger.debug(f\"Setting Teesseract Path to {tesseract_path}\")\n    pytesseract.pytesseract.tesseract_cmd = str(tesseract_path)\n\n    # SubRip output\n    output = \"\"\n\n    if not os.path.exists(srt_file):\n        # Iterate the pgs generator\n        for ds in pgs.iter_displaysets():\n            # If set has image, parse the image\n            if ds.has_image:\n                # Get Palette Display Segment\n                pds = ds.pds[0]\n                # Get Object Display Segment\n                ods = ds.ods[0]\n\n                if pds and ods:\n                    # Create and show the bitmap image and convert it to RGBA\n                    src = make_image(ods, pds).convert(\"RGBA\")\n\n                    # Create grayscale image with black background\n                    img = Image.new(\"L\", src.size, \"BLACK\")\n                    # Paste the subtitle bitmap\n                    img.paste(src, (0, 0), src)\n                    # Invert images so the text is readable by Tesseract\n                    img = ImageOps.invert(img)\n\n                    # Parse the image with tesesract\n                    text = pytesseract.image_to_string(\n                        img, lang=tesseract_lang, config=tesseract_config\n                    ).strip()\n\n                    # Replace \"|\" with \"I\"\n                    # Works better than blacklisting \"|\" in Tesseract,\n                    # which results in I becoming \"!\" \"i\" and \"1\"\n                    text = re.sub(r\"[|/\\\\]\", \"I\", text)\n                    text = re.sub(r\"[_]\", \"L\", text)\n                    start = datetime.fromtimestamp(ods.presentation_timestamp / 1000)\n                    start = start + timedelta(hours=-1)\n\n            else:\n                # Get Presentation Composition Segment\n                pcs = ds.pcs[0]\n\n                if pcs:\n                    end = datetime.fromtimestamp(pcs.presentation_timestamp / 1000)\n                    end = end + timedelta(hours=-1)\n\n                    if (\n                        isinstance(start, datetime)\n                        and isinstance(end, datetime)\n                        and len(text)\n                    ):\n                        si = si + 1\n                        sub_output = str(si) + \"\\n\"\n                        sub_output += (\n                            start.strftime(\"%H:%M:%S,%f\")[0:12]\n                            + \" --&gt; \"\n                            + end.strftime(\"%H:%M:%S,%f\")[0:12]\n                            + \"\\n\"\n                        )\n                        sub_output += text + \"\\n\\n\"\n\n                        output += sub_output\n                        start = end = text = None\n            i = i + 1\n        with open(srt_file, \"w\") as f:\n            f.write(output)\n        logger.info(f\"Saved to: {srt_file}\")\n</code></pre>"},{"location":"api/#mkv_episode_matcher.mkv_to_srt.extract_subtitles","title":"extract_subtitles","text":"<pre><code>extract_subtitles(mkv_file, output_dir)\n</code></pre> <p>Extract subtitles from MKV file based on detected subtitle type.</p> Source code in <code>mkv_episode_matcher/mkv_to_srt.py</code> <pre><code>def extract_subtitles(mkv_file: str, output_dir: str) -&gt; Optional[str]:\n    \"\"\"\n    Extract subtitles from MKV file based on detected subtitle type.\n    \"\"\"\n    subtitle_type, stream_index = detect_subtitle_type(mkv_file)\n    if not subtitle_type:\n        logger.error(f\"No supported subtitle streams found in {mkv_file}\")\n        return None\n\n    base_name = Path(mkv_file).stem\n\n    if subtitle_type == 'subrip':\n        # For SRT subtitles, extract directly to .srt\n        output_file = os.path.join(output_dir, f\"{base_name}.srt\")\n        if not os.path.exists(output_file):\n            cmd = [\n                \"ffmpeg\", \"-i\", mkv_file,\n                \"-map\", f\"0:{stream_index}\",\n                output_file\n            ]\n    else:\n        # For DVD or PGS subtitles, extract to SUP format first\n        output_file = os.path.join(output_dir, f\"{base_name}.sup\")\n        if not os.path.exists(output_file):\n            cmd = [\n                \"ffmpeg\", \"-i\", mkv_file,\n                \"-map\", f\"0:{stream_index}\",\n                \"-c\", \"copy\",\n                output_file\n            ]\n\n    if not os.path.exists(output_file):\n        try:\n            subprocess.run(cmd, check=True)\n            logger.info(f\"Extracted subtitles from {mkv_file} to {output_file}\")\n            return output_file\n        except subprocess.CalledProcessError as e:\n            logger.error(f\"Error extracting subtitles: {e}\")\n            return None\n    else:\n        logger.info(f\"Subtitle file {output_file} already exists, skipping extraction\")\n        return output_file\n</code></pre>"},{"location":"api/#mkv_episode_matcher.mkv_to_srt.convert_mkv_to_srt","title":"convert_mkv_to_srt","text":"<pre><code>convert_mkv_to_srt(season_path, mkv_files)\n</code></pre> <p>Convert subtitles from MKV files to SRT format.</p> Source code in <code>mkv_episode_matcher/mkv_to_srt.py</code> <pre><code>def convert_mkv_to_srt(season_path: str, mkv_files: list[str]) -&gt; None:\n    \"\"\"\n    Convert subtitles from MKV files to SRT format.\n    \"\"\"\n    logger.info(f\"Converting {len(mkv_files)} files to SRT\")\n\n    # Filter out already processed files\n    unprocessed_files = []\n    for mkv_file in mkv_files:\n        if check_if_processed(os.path.basename(mkv_file)):\n            logger.info(f\"Skipping {mkv_file} - already processed\")\n            continue\n        unprocessed_files.append(mkv_file)\n\n    if not unprocessed_files:\n        logger.info(\"No new files to process\")\n        return\n\n    # Create OCR directory\n    output_dir = os.path.join(season_path, \"ocr\")\n    os.makedirs(output_dir, exist_ok=True)\n\n    for mkv_file in unprocessed_files:\n        subtitle_file = extract_subtitles(mkv_file, output_dir)\n        if not subtitle_file:\n            continue\n\n        if subtitle_file.endswith('.srt'):\n            # Already have SRT, keep it in OCR directory\n            logger.info(f\"Extracted SRT subtitle to {subtitle_file}\")\n        else:\n            # For SUP files (DVD or PGS), perform OCR\n            srt_file = perform_ocr(subtitle_file)\n            if srt_file:\n                logger.info(f\"Created SRT from OCR: {srt_file}\")\n</code></pre>"},{"location":"api/#mkv_episode_matcher.mkv_to_srt.detect_subtitle_type","title":"detect_subtitle_type","text":"<pre><code>detect_subtitle_type(mkv_file)\n</code></pre> <p>Detect the type and index of subtitle streams in an MKV file.</p> Source code in <code>mkv_episode_matcher/mkv_to_srt.py</code> <pre><code>def detect_subtitle_type(mkv_file: str) -&gt; tuple[Optional[str], Optional[int]]:\n    \"\"\"\n    Detect the type and index of subtitle streams in an MKV file.\n    \"\"\"\n    cmd = [\"ffmpeg\", \"-i\", mkv_file]\n\n    try:\n        result = subprocess.run(cmd, capture_output=True, text=True)\n\n        subtitle_streams = []\n        for line in result.stderr.split('\\n'):\n            if 'Subtitle' in line:\n                stream_index = int(line.split('#0:')[1].split('(')[0])\n                if 'subrip' in line:\n                    subtitle_streams.append(('subrip', stream_index))\n                elif 'dvd_subtitle' in line:\n                    subtitle_streams.append(('dvd_subtitle', stream_index))\n                elif 'hdmv_pgs_subtitle' in line:\n                    subtitle_streams.append(('hdmv_pgs_subtitle', stream_index))\n\n        # Prioritize subtitle formats: SRT &gt; DVD &gt; PGS\n        for format_priority in ['subrip', 'dvd_subtitle', 'hdmv_pgs_subtitle']:\n            for format_type, index in subtitle_streams:\n                if format_type == format_priority:\n                    return format_type, index\n\n        return None, None\n\n    except subprocess.CalledProcessError as e:\n        logger.error(f\"Error detecting subtitle type: {e}\")\n        return None, None\n</code></pre>"},{"location":"api/#utilities","title":"Utilities","text":""},{"location":"api/#mkv_episode_matcher.utils","title":"mkv_episode_matcher.utils","text":""},{"location":"api/#mkv_episode_matcher.utils-functions","title":"Functions","text":""},{"location":"api/#mkv_episode_matcher.utils.get_valid_seasons","title":"get_valid_seasons","text":"<pre><code>get_valid_seasons(show_dir)\n</code></pre> <p>Get all season directories that contain MKV files.</p> PARAMETER DESCRIPTION <code>show_dir</code> <p>Base directory for the TV show</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>list</code> <p>List of paths to valid season directories</p> Source code in <code>mkv_episode_matcher/utils.py</code> <pre><code>def get_valid_seasons(show_dir):\n    \"\"\"\n    Get all season directories that contain MKV files.\n\n    Args:\n        show_dir (str): Base directory for the TV show\n\n    Returns:\n        list: List of paths to valid season directories\n    \"\"\"\n    # Get all season directories\n    season_paths = [\n        os.path.join(show_dir, d)\n        for d in os.listdir(show_dir)\n        if os.path.isdir(os.path.join(show_dir, d))\n    ]\n\n    # Filter seasons to only include those with .mkv files\n    valid_season_paths = []\n    for season_path in season_paths:\n        mkv_files = [f for f in os.listdir(season_path) if f.endswith(\".mkv\")]\n        if mkv_files:\n            valid_season_paths.append(season_path)\n\n    if not valid_season_paths:\n        logger.warning(f\"No seasons with .mkv files found in show '{os.path.basename(show_dir)}'\")\n    else:\n        logger.info(\n            f\"Found {len(valid_season_paths)} seasons with .mkv files in '{os.path.basename(show_dir)}'\"\n        )\n\n    return valid_season_paths\n</code></pre>"},{"location":"api/#mkv_episode_matcher.utils.check_filename","title":"check_filename","text":"<pre><code>check_filename(filename)\n</code></pre> <p>Check if the filename is in the correct format (S01E02).</p> PARAMETER DESCRIPTION <code>filename</code> <p>The filename to check.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if the filename matches the expected pattern.</p> Source code in <code>mkv_episode_matcher/utils.py</code> <pre><code>def check_filename(filename):\n    \"\"\"\n    Check if the filename is in the correct format (S01E02).\n\n    Args:\n        filename (str): The filename to check.\n\n    Returns:\n        bool: True if the filename matches the expected pattern.\n    \"\"\"\n    # Check if the filename matches the expected format\n    match = re.search(r'.*S\\d+E\\d+', filename)\n    return bool(match)\n</code></pre>"},{"location":"api/#mkv_episode_matcher.utils.scramble_filename","title":"scramble_filename","text":"<pre><code>scramble_filename(original_file_path, file_number)\n</code></pre> <p>Scrambles the filename of the given file path by adding the series title and file number.</p> PARAMETER DESCRIPTION <code>original_file_path</code> <p>The original file path.</p> <p> TYPE: <code>str</code> </p> <code>file_number</code> <p>The file number to be added to the filename.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <p>None</p> Source code in <code>mkv_episode_matcher/utils.py</code> <pre><code>def scramble_filename(original_file_path, file_number):\n    \"\"\"\n    Scrambles the filename of the given file path by adding the series title and file number.\n\n    Args:\n        original_file_path (str): The original file path.\n        file_number (int): The file number to be added to the filename.\n\n    Returns:\n        None\n    \"\"\"\n    logger.info(f\"Scrambling {original_file_path}\")\n    series_title = os.path.basename(\n        os.path.dirname(os.path.dirname(original_file_path))\n    )\n    original_file_name = os.path.basename(original_file_path)\n    extension = os.path.splitext(original_file_path)[-1]\n    new_file_name = f\"{series_title} - {file_number:03d}{extension}\"\n    new_file_path = os.path.join(os.path.dirname(original_file_path), new_file_name)\n    if not os.path.exists(new_file_path):\n        logger.info(f\"Renaming {original_file_name} -&gt; {new_file_name}\")\n        os.rename(original_file_path, new_file_path)\n</code></pre>"},{"location":"api/#mkv_episode_matcher.utils.rename_episode_file","title":"rename_episode_file","text":"<pre><code>rename_episode_file(original_file_path, new_filename)\n</code></pre> <p>Rename an episode file with a standardized naming convention.</p> PARAMETER DESCRIPTION <code>original_file_path</code> <p>The original file path of the episode.</p> <p> TYPE: <code>str</code> </p> <code>new_filename</code> <p>The new filename including season/episode info.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>str</code> <p>Path to the renamed file, or None if rename failed.</p> Source code in <code>mkv_episode_matcher/utils.py</code> <pre><code>def rename_episode_file(original_file_path, new_filename):\n    \"\"\"\n    Rename an episode file with a standardized naming convention.\n\n    Args:\n        original_file_path (str): The original file path of the episode.\n        new_filename (str): The new filename including season/episode info.\n\n    Returns:\n        str: Path to the renamed file, or None if rename failed.\n    \"\"\"\n    original_dir = os.path.dirname(original_file_path)\n    new_file_path = os.path.join(original_dir, new_filename)\n\n    # Check if new filepath already exists\n    if os.path.exists(new_file_path):\n        logger.warning(f\"File already exists: {new_filename}\")\n\n        # Add numeric suffix if file exists\n        base, ext = os.path.splitext(new_filename)\n        suffix = 2\n        while True:\n            new_filename = f\"{base}_{suffix}{ext}\"\n            new_file_path = os.path.join(original_dir, new_filename)\n            if not os.path.exists(new_file_path):\n                break\n            suffix += 1\n\n    try:\n        os.rename(original_file_path, new_file_path)\n        logger.info(f\"Renamed {os.path.basename(original_file_path)} -&gt; {new_filename}\")\n        return new_file_path\n    except OSError as e:\n        logger.error(f\"Failed to rename file: {e}\")\n        return None\n    except FileExistsError as e:\n        logger.error(f\"Failed to rename file: {e}\")\n        return None\n</code></pre>"},{"location":"api/#mkv_episode_matcher.utils.get_subtitles","title":"get_subtitles","text":"<pre><code>get_subtitles(show_id, seasons, config=None)\n</code></pre> <p>Retrieves and saves subtitles for a given TV show and seasons.</p> PARAMETER DESCRIPTION <code>show_id</code> <p>The ID of the TV show.</p> <p> TYPE: <code>int</code> </p> <code>seasons</code> <p>A set of season numbers for which subtitles should be retrieved.</p> <p> TYPE: <code>Set[int]</code> </p> <code>config</code> <p>Preloaded configuration.</p> <p> TYPE: <code>Config object</code> DEFAULT: <code>None</code> </p> Source code in <code>mkv_episode_matcher/utils.py</code> <pre><code>def get_subtitles(show_id, seasons: set[int], config=None):\n    \"\"\"\n    Retrieves and saves subtitles for a given TV show and seasons.\n\n    Args:\n        show_id (int): The ID of the TV show.\n        seasons (Set[int]): A set of season numbers for which subtitles should be retrieved.\n        config (Config object, optional): Preloaded configuration.\n    \"\"\"\n    if config is None:\n        config = get_config(CONFIG_FILE)\n    show_dir = config.get(\"show_dir\")\n    series_name = sanitize_filename(os.path.basename(show_dir))\n    tmdb_api_key = config.get(\"tmdb_api_key\")\n    open_subtitles_api_key = config.get(\"open_subtitles_api_key\")\n    open_subtitles_user_agent = config.get(\"open_subtitles_user_agent\")\n    open_subtitles_username = config.get(\"open_subtitles_username\")\n    open_subtitles_password = config.get(\"open_subtitles_password\")\n\n    if not all([\n        show_dir,\n        tmdb_api_key,\n        open_subtitles_api_key,\n        open_subtitles_user_agent,\n        open_subtitles_username,\n        open_subtitles_password,\n    ]):\n        logger.error(\"Missing configuration settings. Please run the setup script.\")\n        return\n\n    try:\n        subtitles = OpenSubtitles(open_subtitles_user_agent, open_subtitles_api_key)\n        subtitles.login(open_subtitles_username, open_subtitles_password)\n    except Exception as e:\n        logger.error(f\"Failed to log in to OpenSubtitles: {e}\")\n        return\n\n    for season in seasons:\n        episodes = fetch_season_details(show_id, season)\n        logger.info(f\"Found {episodes} episodes in Season {season}\")\n\n        for episode in range(1, episodes + 1):\n            logger.info(f\"Processing Season {season}, Episode {episode}...\")\n\n            series_cache_dir = os.path.join(CACHE_DIR, \"data\", series_name)\n            os.makedirs(series_cache_dir, exist_ok=True)\n\n            # Check for existing subtitle in any supported format\n            existing_subtitle = find_existing_subtitle(\n                series_cache_dir, series_name, season, episode\n            )\n\n            if existing_subtitle:\n                logger.info(f\"Subtitle already exists: {os.path.basename(existing_subtitle)}\")\n                continue\n\n            # Default to standard format for new downloads\n            srt_filepath = os.path.join(\n                series_cache_dir,\n                f\"{series_name} - S{season:02d}E{episode:02d}.srt\",\n            )\n\n            # get the episode info from TMDB\n            url = f\"https://api.themoviedb.org/3/tv/{show_id}/season/{season}/episode/{episode}?api_key={tmdb_api_key}\"\n            response = requests.get(url)\n            response.raise_for_status()\n            episode_data = response.json()\n            episode_id = episode_data[\"id\"]\n\n            # search for the subtitle\n            response = subtitles.search(tmdb_id=episode_id, languages=\"en\")\n            if len(response.data) == 0:\n                logger.warning(\n                    f\"No subtitles found for {series_name} - S{season:02d}E{episode:02d}\"\n                )\n                continue\n\n            for subtitle in response.data:\n                subtitle_dict = subtitle.to_dict()\n                # Remove special characters and convert to uppercase\n                filename_clean = re.sub(r\"\\W+\", \" \", subtitle_dict[\"file_name\"]).upper()\n                if f\"E{episode:02d}\" in filename_clean:\n                    logger.info(f\"Original filename: {subtitle_dict['file_name']}\")\n                    srt_file = subtitles.download_and_save(subtitle)\n                    shutil.move(srt_file, srt_filepath)\n                    logger.info(f\"Subtitle saved to {srt_filepath}\")\n                    break\n</code></pre>"},{"location":"api/#mkv_episode_matcher.utils.cleanup_ocr_files","title":"cleanup_ocr_files","text":"<pre><code>cleanup_ocr_files(show_dir)\n</code></pre> <p>Clean up OCR files generated during the episode matching process.</p> PARAMETER DESCRIPTION <code>show_dir</code> <p>The directory containing the show files.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <p>None</p> <p>This function cleans up the OCR files generated during the episode matching process. It deletes the 'ocr' directory and all its contents in each season directory of the show.</p> Source code in <code>mkv_episode_matcher/utils.py</code> <pre><code>def cleanup_ocr_files(show_dir):\n    \"\"\"\n    Clean up OCR files generated during the episode matching process.\n\n    Args:\n        show_dir (str): The directory containing the show files.\n\n    Returns:\n        None\n\n    This function cleans up the OCR files generated during the episode matching process.\n    It deletes the 'ocr' directory and all its contents in each season directory of the show.\n    \"\"\"\n    for season_dir in os.listdir(show_dir):\n        season_dir_path = os.path.join(show_dir, season_dir)\n        ocr_dir_path = os.path.join(season_dir_path, \"ocr\")\n        if os.path.exists(ocr_dir_path):\n            logger.info(f\"Cleaning up OCR files in {ocr_dir_path}\")\n            shutil.rmtree(ocr_dir_path)\n</code></pre>"},{"location":"api/#mkv_episode_matcher.utils.process_reference_srt_files","title":"process_reference_srt_files","text":"<pre><code>process_reference_srt_files(series_name)\n</code></pre> <p>Process reference SRT files for a given series.</p> PARAMETER DESCRIPTION <code>series_name</code> <p>The name of the series.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>dict</code> <p>A dictionary containing the reference files where the keys are the MKV filenames   and the values are the corresponding SRT texts.</p> Source code in <code>mkv_episode_matcher/utils.py</code> <pre><code>@logger.catch\ndef process_reference_srt_files(series_name):\n    \"\"\"\n    Process reference SRT files for a given series.\n\n    Args:\n        series_name (str): The name of the series.\n\n    Returns:\n        dict: A dictionary containing the reference files where the keys are the MKV filenames\n              and the values are the corresponding SRT texts.\n    \"\"\"\n    from mkv_episode_matcher.__main__ import CACHE_DIR\n    import os\n\n    reference_files = {}\n    reference_dir = os.path.join(CACHE_DIR, \"data\", series_name)\n\n    for dirpath, _, filenames in os.walk(reference_dir):\n        for filename in filenames:\n            if filename.lower().endswith(\".srt\"):\n                srt_file = os.path.join(dirpath, filename)\n                logger.info(f\"Processing {srt_file}\")\n                srt_text = extract_srt_text(srt_file)\n                season, episode = extract_season_episode(filename)\n                mkv_filename = f\"{series_name} - S{season:02}E{episode:02}.mkv\"\n                reference_files[mkv_filename] = srt_text\n\n    return reference_files\n</code></pre>"},{"location":"api/#mkv_episode_matcher.utils.extract_srt_text","title":"extract_srt_text","text":"<pre><code>extract_srt_text(filepath)\n</code></pre> <p>Extracts text content from an SRT file.</p> PARAMETER DESCRIPTION <code>filepath</code> <p>Path to the SRT file.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>list</code> <p>List of text lines from the SRT file.</p> Source code in <code>mkv_episode_matcher/utils.py</code> <pre><code>def extract_srt_text(filepath):\n    \"\"\"\n    Extracts text content from an SRT file.\n\n    Args:\n        filepath (str): Path to the SRT file.\n\n    Returns:\n        list: List of text lines from the SRT file.\n    \"\"\"\n    # Read the file content\n    with open(filepath) as f:\n        content = f.read()\n\n    # Split into subtitle blocks\n    blocks = content.strip().split('\\n\\n')\n\n    text_lines = []\n    for block in blocks:\n        lines = block.split('\\n')\n        if len(lines) &lt; 3:\n            continue\n\n        # Skip index and timestamp, get all remaining lines as text\n        text = ' '.join(lines[2:])\n        # Remove stage directions and tags\n        text = re.sub(r'\\[.*?\\]|\\&lt;.*?\\&gt;', '', text)\n        if text:\n            text_lines.append(text)\n\n    return text_lines\n</code></pre>"},{"location":"api/#mkv_episode_matcher.utils.extract_season_episode","title":"extract_season_episode","text":"<pre><code>extract_season_episode(filename)\n</code></pre> <p>Extract season and episode numbers from filename with support for multiple formats.</p> PARAMETER DESCRIPTION <code>filename</code> <p>Filename to parse</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>tuple</code> <p>(season_number, episode_number)</p> Source code in <code>mkv_episode_matcher/utils.py</code> <pre><code>def extract_season_episode(filename):\n    \"\"\"\n    Extract season and episode numbers from filename with support for multiple formats.\n\n    Args:\n        filename (str): Filename to parse\n\n    Returns:\n        tuple: (season_number, episode_number)\n    \"\"\"\n    # List of patterns to try\n    patterns = [\n        r'S(\\d+)E(\\d+)',          # S01E01\n        r'(\\d+)x(\\d+)',           # 1x01 or 01x01\n        r'Season\\s*(\\d+).*?(\\d+)' # Season 1 - 01\n    ]\n\n    for pattern in patterns:\n        match = re.search(pattern, filename, re.IGNORECASE)\n        if match:\n            return int(match.group(1)), int(match.group(2))\n\n    return None, None\n</code></pre>"},{"location":"api/#mkv_episode_matcher.utils.process_srt_files","title":"process_srt_files","text":"<pre><code>process_srt_files(show_dir)\n</code></pre> <p>Process all SRT files in the given directory and its subdirectories.</p> PARAMETER DESCRIPTION <code>show_dir</code> <p>The directory path where the SRT files are located.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>dict</code> <p>A dictionary containing the SRT file paths as keys and their corresponding text content as values.</p> Source code in <code>mkv_episode_matcher/utils.py</code> <pre><code>def process_srt_files(show_dir):\n    \"\"\"\n    Process all SRT files in the given directory and its subdirectories.\n\n    Args:\n        show_dir (str): The directory path where the SRT files are located.\n\n    Returns:\n        dict: A dictionary containing the SRT file paths as keys and their corresponding text content as values.\n    \"\"\"\n    srt_files = {}\n    for dirpath, _, filenames in os.walk(show_dir):\n        for filename in filenames:\n            if filename.lower().endswith(\".srt\"):\n                srt_file = os.path.join(dirpath, filename)\n                logger.info(f\"Processing {srt_file}\")\n                srt_text = extract_srt_text(srt_file)\n                srt_files[srt_file] = srt_text\n    return srt_files\n</code></pre>"},{"location":"api/#mkv_episode_matcher.utils.compare_and_rename_files","title":"compare_and_rename_files","text":"<pre><code>compare_and_rename_files(srt_files, reference_files, dry_run=False)\n</code></pre> <p>Compare the srt files with the reference files and rename the matching mkv files.</p> PARAMETER DESCRIPTION <code>srt_files</code> <p>A dictionary containing the srt files as keys and their contents as values.</p> <p> TYPE: <code>dict</code> </p> <code>reference_files</code> <p>A dictionary containing the reference files as keys and their contents as values.</p> <p> TYPE: <code>dict</code> </p> <code>dry_run</code> <p>If True, the function will only log the renaming actions without actually renaming the files. Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>mkv_episode_matcher/utils.py</code> <pre><code>def compare_and_rename_files(srt_files, reference_files, dry_run=False):\n    \"\"\"\n    Compare the srt files with the reference files and rename the matching mkv files.\n\n    Args:\n        srt_files (dict): A dictionary containing the srt files as keys and their contents as values.\n        reference_files (dict): A dictionary containing the reference files as keys and their contents as values.\n        dry_run (bool, optional): If True, the function will only log the renaming actions without actually renaming the files. Defaults to False.\n    \"\"\"\n    logger.info(\n        f\"Comparing {len(srt_files)} srt files with {len(reference_files)} reference files\"\n    )\n    for srt_text in srt_files.keys():\n        parent_dir = os.path.dirname(os.path.dirname(srt_text))\n        for reference in reference_files.keys():\n            _season, _episode = extract_season_episode(reference)\n            mkv_file = os.path.join(\n                parent_dir, os.path.basename(srt_text).replace(\".srt\", \".mkv\")\n            )\n            matching_lines = compare_text(\n                reference_files[reference], srt_files[srt_text]\n            )\n            if matching_lines &gt;= int(len(reference_files[reference]) * 0.1):\n                logger.info(f\"Matching lines: {matching_lines}\")\n                logger.info(f\"Found matching file: {mkv_file} -&gt;{reference}\")\n                new_filename = os.path.join(parent_dir, reference)\n                if not dry_run:\n                    logger.info(f\"Renaming {mkv_file} to {new_filename}\")\n                    rename_episode_file(mkv_file, new_filename)\n</code></pre>"},{"location":"api/#mkv_episode_matcher.utils.compare_text","title":"compare_text","text":"<pre><code>compare_text(text1, text2)\n</code></pre> <p>Compare two lists of text lines and return the number of matching lines.</p> PARAMETER DESCRIPTION <code>text1</code> <p>List of text lines from the first source.</p> <p> TYPE: <code>list</code> </p> <code>text2</code> <p>List of text lines from the second source.</p> <p> TYPE: <code>list</code> </p> RETURNS DESCRIPTION <code>int</code> <p>Number of matching lines between the two sources.</p> Source code in <code>mkv_episode_matcher/utils.py</code> <pre><code>def compare_text(text1, text2):\n    \"\"\"\n    Compare two lists of text lines and return the number of matching lines.\n\n    Args:\n        text1 (list): List of text lines from the first source.\n        text2 (list): List of text lines from the second source.\n\n    Returns:\n        int: Number of matching lines between the two sources.\n    \"\"\"\n    # Flatten the list of text lines\n    flat_text1 = [line for lines in text1 for line in lines]\n    flat_text2 = [line for lines in text2 for line in lines]\n\n    # Compare the two lists of text lines\n    matching_lines = set(flat_text1).intersection(flat_text2)\n    return len(matching_lines)\n</code></pre>"},{"location":"api/#configuration","title":"Configuration","text":""},{"location":"api/#mkv_episode_matcher.config","title":"mkv_episode_matcher.config","text":""},{"location":"api/#mkv_episode_matcher.config-functions","title":"Functions","text":""},{"location":"api/#mkv_episode_matcher.config.set_config","title":"set_config","text":"<pre><code>set_config(tmdb_api_key, open_subtitles_api_key, open_subtitles_user_agent, open_subtitles_username, open_subtitles_password, show_dir, file, tesseract_path=None)\n</code></pre> <p>Sets the configuration values and writes them to a file.</p> PARAMETER DESCRIPTION <code>tmdb_api_key</code> <p>The API key for TMDB (The Movie Database).</p> <p> TYPE: <code>str</code> </p> <code>open_subtitles_api_key</code> <p>The API key for OpenSubtitles.</p> <p> TYPE: <code>str</code> </p> <code>open_subtitles_user_agent</code> <p>The user agent for OpenSubtitles.</p> <p> TYPE: <code>str</code> </p> <code>open_subtitles_username</code> <p>The username for OpenSubtitles.</p> <p> TYPE: <code>str</code> </p> <code>open_subtitles_password</code> <p>The password for OpenSubtitles.</p> <p> TYPE: <code>str</code> </p> <code>show_dir</code> <p>The directory where the TV show episodes are located.</p> <p> TYPE: <code>str</code> </p> <code>file</code> <p>The path to the configuration file.</p> <p> TYPE: <code>str</code> </p> <code>tesseract_path</code> <p>The path to the Tesseract OCR executable.</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <p>None</p> Source code in <code>mkv_episode_matcher/config.py</code> <pre><code>def set_config(\n    tmdb_api_key,\n    open_subtitles_api_key,\n    open_subtitles_user_agent,\n    open_subtitles_username,\n    open_subtitles_password,\n    show_dir,\n    file,\n    tesseract_path=None,\n):\n    \"\"\"\n    Sets the configuration values and writes them to a file.\n\n    Args:\n        tmdb_api_key (str): The API key for TMDB (The Movie Database).\n        open_subtitles_api_key (str): The API key for OpenSubtitles.\n        open_subtitles_user_agent (str): The user agent for OpenSubtitles.\n        open_subtitles_username (str): The username for OpenSubtitles.\n        open_subtitles_password (str): The password for OpenSubtitles.\n        show_dir (str): The directory where the TV show episodes are located.\n        file (str): The path to the configuration file.\n        tesseract_path (str, optional): The path to the Tesseract OCR executable.\n\n    Returns:\n        None\n    \"\"\"\n    config = configparser.ConfigParser()\n    config[\"Config\"] = {\n        \"tmdb_api_key\": str(tmdb_api_key),\n        \"show_dir\": show_dir,\n        \"max_threads\": int(MAX_THREADS),\n        \"open_subtitles_api_key\": str(open_subtitles_api_key),\n        \"open_subtitles_user_agent\": str(open_subtitles_user_agent),\n        \"open_subtitles_username\": str(open_subtitles_username),\n        \"open_subtitles_password\": str(open_subtitles_password),\n        \"tesseract_path\": str(tesseract_path),\n    }\n    logger.info(\n        f\"Setting config with API:{tmdb_api_key}, show_dir: {show_dir}, and max_threads: {MAX_THREADS}\"\n    )\n    with open(file, \"w\") as configfile:\n        config.write(configfile)\n</code></pre>"},{"location":"api/#mkv_episode_matcher.config.get_config","title":"get_config","text":"<pre><code>get_config(file)\n</code></pre> <p>Read and return the configuration from the specified file.</p> PARAMETER DESCRIPTION <code>file</code> <p>The path to the configuration file.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>dict</code> <p>The configuration settings as a dictionary.</p> Source code in <code>mkv_episode_matcher/config.py</code> <pre><code>def get_config(file):\n    \"\"\"\n    Read and return the configuration from the specified file.\n\n    Args:\n        file (str): The path to the configuration file.\n\n    Returns:\n        dict: The configuration settings as a dictionary.\n\n    \"\"\"\n    logger.info(f\"Loading config from {file}\")\n    config = configparser.ConfigParser()\n    if os.path.exists(file):\n        config.read(file)\n        return config[\"Config\"] if \"Config\" in config else None\n    return {}\n</code></pre>"}]}
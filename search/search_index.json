{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"MKV Episode Matcher","text":"<p>Automatically match and rename your MKV TV episodes using The Movie Database (TMDb).</p>"},{"location":"#features","title":"Features","text":"<ul> <li>\ud83c\udfaf Automatic Episode Matching: Uses TMDb to accurately identify episodes</li> <li>\ud83c\udfa8 Rich User Interface: Color-coded output and progress indicators</li> <li>\ud83d\udcdd Subtitle Extraction: Extracts subtitles from MKV files</li> <li>\ud83d\udd0a Speech Recognition: Uses Whisper for accurate episode identification</li> <li>\ud83d\ude80 Multi-threaded: Fast processing of multiple files</li> <li>\u2b07\ufe0f Subtitle Downloads: Integration with OpenSubtitles</li> <li>\u2728 Bulk Processing: Handle entire seasons at once</li> <li>\ud83e\uddea Dry Run Mode: Test changes before applying</li> <li>\ud83c\udfae Interactive Mode: User-friendly season selection and configuration</li> </ul>"},{"location":"#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.9-3.12</li> <li>FFmpeg installed and available in system PATH</li> <li>TMDb API key (optional, for subtitle downloads)</li> <li>OpenSubtitles account (optional, for subtitle downloads)</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":"<ol> <li>Install the package: <pre><code>pip install mkv-episode-matcher\n</code></pre></li> <li> <p>Download .srt subtitles files to ~/.mkv-episode-matcher/cache/data/Show Name/</p> </li> <li> <p>Run on your show directory: <pre><code>mkv-match --show-dir \"path/to/your/show\"\n</code></pre></p> </li> </ol>"},{"location":"#directory-structure","title":"Directory Structure","text":"<p>MKV Episode Matcher expects your TV shows to be organized as follows:</p> <pre><code>Show Name/\n\u251c\u2500\u2500 Season 1/\n\u2502   \u251c\u2500\u2500 episode1.mkv\n\u2502   \u251c\u2500\u2500 episode2.mkv\n\u251c\u2500\u2500 Season 2/\n\u2502   \u251c\u2500\u2500 episode1.mkv\n\u2502   \u2514\u2500\u2500 episode2.mkv\n</code></pre>"},{"location":"#reference-subtitle-file-structure","title":"Reference Subtitle File Structure","text":"<p>Subtitle files that are not automatically downloaded using the <code>--get-subs</code> flag should be named as follows:</p> <pre><code>~/.mkv-episode-matcher/cache/data/Show Name/\n\u251c\u2500\u2500 Show Name - S01E01.srt\n\u251c\u2500\u2500 Show Name - S01E02.srt\n\u2514\u2500\u2500 ...\n</code></pre> <p>On Windows, the cache directory is located at <code>C:\\Users\\{username}\\.mkv-episode-matcher\\cache\\data\\</code></p> <p>Reference subtitle files should follow this naming pattern: <code>{show_name} - S{season:02d}E{episode:02d}.srt</code></p>"},{"location":"#contributing","title":"Contributing","text":"<ol> <li>Fork the repository</li> <li>Create a feature branch (<code>git checkout -b feature/amazing-feature</code>)</li> <li>Commit your changes (<code>git commit -m 'Add amazing feature'</code>)</li> <li>Push to the branch (<code>git push origin feature/amazing-feature</code>)</li> <li>Open a Pull Request</li> </ol>"},{"location":"#license","title":"License","text":"<p>Distributed under the MIT License. See <code>LICENSE</code> for more information.</p>"},{"location":"#acknowledgments","title":"Acknowledgments","text":"<ul> <li>TMDb for their excellent API</li> <li>OpenSubtitles for subtitle integration</li> <li>All contributors who have helped improve this project</li> </ul>"},{"location":"#documentation","title":"Documentation","text":"<p>Full documentation is available at https://jsakkos.github.io/mkv-episode-matcher/</p>"},{"location":"#changelog","title":"Changelog","text":"<p>See CHANGELOG.md for a detailed list of changes.</p>"},{"location":"changelog/","title":"Changelog","text":"<p>For a complete list of changes, see CHANGELOG.md in the repository root.</p>"},{"location":"changelog/#latest-changes","title":"Latest Changes","text":""},{"location":"changelog/#060-2025-02-24","title":"0.6.0 - 2025-02-24","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>Comprehensive documentation including installation, configuration, and CLI guides</li> <li>Quick start guide with common usage examples</li> <li>Tips and tricks documentation with best practices</li> <li>Detailed changelog structure</li> </ul>"},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li>Improved project metadata and description</li> <li>Updated version number in setup.cfg</li> </ul>"},{"location":"changelog/#removed","title":"Removed","text":"<ul> <li>Removed OCR support and Tesseract dependency</li> <li>Removed unused code</li> </ul>"},{"location":"changelog/#050-2025-02-23","title":"0.5.0 - 2025-02-23","text":""},{"location":"changelog/#changed_1","title":"Changed","text":"<ul> <li>Try to use tiny version of OpenAI Whisper for initial matching</li> <li>Fall back to base model if tiny model fails</li> <li>Progressive matching in 30s intervals (was 300s)</li> </ul>"},{"location":"changelog/#removed_1","title":"Removed","text":"<ul> <li>Removed unused code</li> </ul> <p>For older versions and complete changelog history, please visit our GitHub releases page.</p>"},{"location":"cli/","title":"Command Line Interface","text":"<p>The CLI features a rich, user-friendly interface with color-coded output and progress indicators.</p>"},{"location":"cli/#basic-commands","title":"Basic Commands","text":""},{"location":"cli/#process-show","title":"Process Show","text":"<pre><code>mkv-match --show-dir \"/path/to/show\"\n</code></pre>"},{"location":"cli/#process-specific-season","title":"Process Specific Season","text":"<pre><code>mkv-match --show-dir \"/path/to/show\" --season 1\n</code></pre>"},{"location":"cli/#command-options","title":"Command Options","text":"Option Description Default <code>--show-dir</code> Show directory path None <code>--season</code> Season number to process None (all) <code>--dry-run</code> Test without making changes False <code>--get-subs</code> Download subtitles False <code>--tmdb-api-key</code> TMDb API key None"},{"location":"cli/#examples","title":"Examples","text":""},{"location":"cli/#dry-run-mode","title":"Dry Run Mode","text":"<pre><code>mkv-match --show-dir \"/path/to/show\" --dry-run\n</code></pre>"},{"location":"cli/#download-subtitles","title":"Download Subtitles","text":"<pre><code>mkv-match --show-dir \"/path/to/show\" --get-subs\n</code></pre>"},{"location":"cli/#set-api-key","title":"Set API Key","text":"<pre><code>mkv-match --show-dir \"/path/to/show\" --tmdb-api-key \"your_key\"\n</code></pre>"},{"location":"cli/#multiple-options","title":"Multiple Options","text":"<pre><code>mkv-match \\\n  --show-dir \"/path/to/show\" \\\n  --season 1 \\\n  --get-subs \\\n  --dry-run\n</code></pre>"},{"location":"cli/#logging","title":"Logging","text":"<p>Logs are stored in: <pre><code>~/.mkv-episode-matcher/logs/\n\u251c\u2500\u2500 stdout.log\n\u2514\u2500\u2500 stderr.log\n</code></pre></p>"},{"location":"cli/#tips","title":"Tips","text":"<ol> <li>Always use quotes around paths</li> <li>Use dry-run first to test</li> <li>Check logs for details</li> <li>Use full paths for reliability</li> <li>Avoid using a trailing slash in paths</li> </ol>"},{"location":"configuration/","title":"Configuration Guide","text":""},{"location":"configuration/#configuration-file","title":"Configuration File","text":"<p>MKV Episode Matcher uses a configuration file located at:</p> <ul> <li>Windows: <code>%USERPROFILE%\\.mkv-episode-matcher\\config.ini</code></li> <li>Linux/Mac: <code>~/.mkv-episode-matcher/config.ini</code></li> </ul>"},{"location":"configuration/#configuration-options","title":"Configuration Options","text":"<pre><code>[Config]\n# Required Settings\ntmdb_api_key = your_tmdb_api_key\nshow_dir = /path/to/shows\n\n# Optional Settings\nmax_threads = 4\nopen_subtitles_api_key = your_opensubs_key\nopen_subtitles_user_agent = your_user_agent\nopen_subtitles_username = your_username\nopen_subtitles_password = your_password\n</code></pre>"},{"location":"configuration/#command-line-configuration","title":"Command Line Configuration","text":"<p>All configuration options can be set via command line:</p> <pre><code>mkv-match \\\n  --tmdb-api-key \"your_key\" \\\n  --show-dir \"/path/to/shows\" \\\n  --season 1 \\\n  --dry-run true \\\n  --get-subs true\n</code></pre>"},{"location":"configuration/#environment-variables","title":"Environment Variables","text":"<p>You can also use environment variables:</p> <pre><code>export TMDB_API_KEY=\"your_key\"\nexport SHOW_DIR=\"/path/to/shows\"\nexport OPEN_SUBTITLES_API_KEY=\"your_key\"\n</code></pre>"},{"location":"configuration/#configuration-priority","title":"Configuration Priority","text":"<p>Settings are loaded in the following order (later overrides earlier):</p> <ol> <li>Default values</li> <li>Configuration file</li> <li>Environment variables</li> <li>Command line arguments</li> </ol>"},{"location":"configuration/#detailed-options","title":"Detailed Options","text":""},{"location":"configuration/#tmdb-configuration","title":"TMDb Configuration","text":"<pre><code>[Config]\ntmdb_api_key = your_api_key\n</code></pre> <p>The TMDb API key is required for: - Show identification - Episode information - Season details</p>"},{"location":"configuration/#opensubtitles-configuration","title":"OpenSubtitles Configuration","text":"<pre><code>[Config]\nopen_subtitles_api_key = your_key\nopen_subtitles_user_agent = your_agent\nopen_subtitles_username = username\nopen_subtitles_password = password\n</code></pre> <p>Required only if using subtitle download functionality.</p>"},{"location":"configuration/#performance-settings","title":"Performance Settings","text":"<pre><code>[Config]\nmax_threads = 4\n</code></pre> <p>Adjust based on your system's capabilities: - Default: 4 threads - Minimum: 1 thread - Maximum: Number of CPU cores</p>"},{"location":"installation/","title":"Installation Guide","text":""},{"location":"installation/#prerequisites","title":"Prerequisites","text":""},{"location":"installation/#required-system-dependencies","title":"Required System Dependencies","text":"<ol> <li>FFmpeg</li> <li>Windows: Download from FFmpeg website</li> <li>Linux: <code>sudo apt install ffmpeg</code> or equivalent</li> <li>macOS: <code>brew install ffmpeg</code></li> <li>Verify installation: <code>ffmpeg -version</code></li> </ol> <p>Make sure FFmpeg is added to your system PATH.</p>"},{"location":"installation/#basic-installation","title":"Basic Installation","text":"<p>Install MKV Episode Matcher using pip:</p> <pre><code>pip install mkv-episode-matcher\n</code></pre>"},{"location":"installation/#installation-options","title":"Installation Options","text":""},{"location":"installation/#gpu-support","title":"GPU Support","text":"<p>For GPU acceleration (recommended if you have a CUDA-capable GPU):</p> <p><pre><code>pip install \"mkv-episode-matcher\"\n</code></pre> Find the appropriate CUDA version and upgrade Torch (e.g., for CUDA 12.4) from the compatibility matrix: <pre><code>pip install -U torch torchvision torchaudio --index-url https://download.pytorch.org/whl/cu124\n\n# Verify GPU availability\nmkv-match --check-gpu\n</code></pre></p>"},{"location":"installation/#development-installation","title":"Development Installation","text":"<p>For contributing or development:</p> <pre><code># Clone the repository\ngit clone https://github.com/Jsakkos/mkv-episode-matcher.git\ncd mkv-episode-matcher\n\n# Install UV\npip install uv\n\n# Install with development dependencies\nuv sync --dev\n</code></pre>"},{"location":"installation/#api-keys-setup","title":"API Keys Setup","text":"<ol> <li> <p>TMDb API Key (Optional)</p> <ul> <li>Create an account at TMDb</li> <li>Go to your account settings</li> <li>Request an API key</li> </ul> </li> <li> <p>OpenSubtitles (Optional)</p> <ul> <li>Register at OpenSubtitles</li> <li>Get your API key from the dashboard</li> </ul> </li> </ol>"},{"location":"installation/#system-requirements","title":"System Requirements","text":""},{"location":"installation/#for-gpu-support","title":"For GPU Support","text":"<ul> <li>CUDA-capable NVIDIA GPU</li> <li>CUDA Toolkit 12.1 or compatible version</li> <li>At least 4GB GPU memory recommended for Whisper speech recognition</li> </ul>"},{"location":"installation/#for-cpu-only","title":"For CPU-Only","text":"<ul> <li>No special requirements beyond Python 3.9+</li> <li>Note: Speech recognition will be slower on CPU</li> </ul>"},{"location":"installation/#verification","title":"Verification","text":"<p>Verify your installation:</p> <pre><code>mkv-match --version\n\n# Check GPU availability (if installed with GPU support)\nmkv-match --check-gpu\n</code></pre>"},{"location":"installation/#troubleshooting","title":"Troubleshooting","text":"<p>If you encounter any issues:</p> <ol> <li>Ensure you have the latest pip: <code>pip install --upgrade pip</code></li> <li>For GPU installations, verify CUDA is properly installed</li> <li>Check the compatibility matrix for PyTorch and CUDA versions</li> <li>If you encounter any other issues, please open an issue on GitHub</li> </ol>"},{"location":"quickstart/","title":"Quick Start Guide","text":"<p>Get started with MKV Episode Matcher quickly and efficiently.</p>"},{"location":"quickstart/#basic-usage","title":"Basic Usage","text":""},{"location":"quickstart/#1-interactive-mode","title":"1. Interactive Mode","text":"<p>Simply run: <pre><code>mkv-match\n</code></pre> The program will guide you through the setup interactively.</p>"},{"location":"quickstart/#2-command-line-options","title":"2. Command Line Options","text":"<p>Process a specific season: <pre><code>mkv-match --show-dir \"/path/to/show\" --season 1\n</code></pre></p> <p>Process all seasons with subtitles: <pre><code>mkv-match --show-dir \"/path/to/show\" --get-subs\n</code></pre></p> <p>Test run with detailed output: <pre><code>mkv-match --show-dir \"/path/to/show\" --dry-run --verbose\n</code></pre></p>"},{"location":"quickstart/#key-features","title":"Key Features","text":"<ul> <li>Interactive setup</li> <li>Progress bars with ETA</li> <li>Detailed matching information</li> <li>Confidence-based matching</li> <li>Automatic subtitle downloads</li> <li>GPU acceleration support</li> </ul>"},{"location":"quickstart/#directory-structure","title":"Directory Structure","text":"<p>Expected TV show organization: <pre><code>Show Name/\n\u251c\u2500\u2500 Season 1/\n\u2502   \u251c\u2500\u2500 episode1.mkv\n\u2502   \u251c\u2500\u2500 episode2.mkv\n\u251c\u2500\u2500 Season 2/\n\u2502   \u251c\u2500\u2500 episode1.mkv\n\u2502   \u2514\u2500\u2500 episode2.mkv\n</code></pre></p>"},{"location":"quickstart/#configuration","title":"Configuration","text":"<p>Configuration is stored at <code>~/.mkv-episode-matcher/config.ini</code>: <pre><code>[Config]\ntmdb_api_key = your_tmdb_api_key\nshow_dir = /path/to/show\nopen_subtitles_api_key = your_opensubs_key\nopen_subtitles_user_agent = your_user_agent\nopen_subtitles_username = your_username\nopen_subtitles_password = your_password\n</code></pre></p>"},{"location":"quickstart/#common-commands","title":"Common Commands","text":""},{"location":"quickstart/#check-gpu-support","title":"Check GPU Support","text":"<pre><code>mkv-match --check-gpu true\n</code></pre>"},{"location":"quickstart/#set-confidence-level","title":"Set Confidence Level","text":"<pre><code>mkv-match --show-dir \"/path/to/show\" --confidence 0.8\n</code></pre>"},{"location":"quickstart/#enable-verbose-output","title":"Enable Verbose Output","text":"<pre><code>mkv-match --show-dir \"/path/to/show\" --verbose true\n</code></pre>"},{"location":"quickstart/#next-steps","title":"Next Steps","text":"<ul> <li>Read Installation Guide for setup details</li> <li>Check Tips and Tricks for advanced usage</li> <li>See API Reference for development</li> </ul>"},{"location":"tips/","title":"Tips and Tricks","text":""},{"location":"tips/#best-practices","title":"Best Practices","text":""},{"location":"tips/#directory-organization","title":"Directory Organization","text":"<p>Organize your files consistently: <pre><code>TV Shows/\n\u251c\u2500\u2500 Show Name/\n\u2502   \u251c\u2500\u2500 Season 1/\n\u2502   \u2502   \u251c\u2500\u2500 episode1.mkv\n\u2502   \u2502   \u2514\u2500\u2500 episode2.mkv\n\u2502   \u2514\u2500\u2500 Season 2/\n\u2502       \u251c\u2500\u2500 episode1.mkv\n\u2502       \u2514\u2500\u2500 episode2.mkv\n</code></pre></p>"},{"location":"tips/#performance-accuracy","title":"Performance &amp; Accuracy","text":"<ol> <li> <p>Confidence Threshold <pre><code># Increase matching accuracy (default: 0.7)\nmkv-match --show-dir \"/path/to/show\" --confidence 0.8\n</code></pre>    Start with a higher value and decrease if needed. Lower values may result in false positives.</p> </li> <li> <p>Batch Processing with Progress    The tool now shows detailed progress for each season:    <pre><code>mkv-match --show-dir \"/path/to/show\"\n</code></pre></p> </li> <li> <p>Speech Recognition</p> </li> <li>Uses Whisper for audio analysis</li> <li>Processes files in parallel for speed</li> <li>Shows real-time progress with completion estimates</li> </ol>"},{"location":"tips/#advanced-usage","title":"Advanced Usage","text":""},{"location":"tips/#testing-changes","title":"Testing Changes","text":"<p>Always use dry-run first: <pre><code>mkv-match --show-dir \"/path/to/show\" --dry-run true\n</code></pre></p>"},{"location":"tips/#debug-output","title":"Debug Output","text":"<p>Enable verbose logging: <pre><code>mkv-match --show-dir \"/path/to/show\" -v\n</code></pre></p>"},{"location":"tips/#log-files","title":"Log Files","text":"<p>Check the logs at: <pre><code>~/.mkv-episode-matcher/logs/\n\u251c\u2500\u2500 stdout.log  # General operation logs\n\u2514\u2500\u2500 stderr.log  # Error and warning logs\n</code></pre></p>"},{"location":"tips/#troubleshooting","title":"Troubleshooting","text":""},{"location":"tips/#common-issues","title":"Common Issues","text":"<ol> <li> <p>File Permission Errors <pre><code># Check file permissions\nchmod -R 644 \"/path/to/show\"\n</code></pre></p> </li> <li> <p>API Rate Limits</p> </li> <li>Use rate limiting in configuration</li> <li> <p>Implement exponential backoff</p> </li> <li> <p>Speech Recognition</p> </li> <li>GPU recommended for faster processing</li> <li>Processing happens in 30s intervals</li> <li> <p>More accurate than OCR-based methods</p> </li> <li> <p>Low Confidence Matches</p> </li> <li>Increase confidence threshold</li> <li> <p>Check reference subtitles for accuracy</p> </li> <li> <p>No Matches Found</p> </li> <li>Verify file organization</li> <li>Check reference subtitles</li> <li> <p>Enable verbose output</p> </li> <li> <p>Performance Issues</p> </li> <li>Process one season at a time</li> <li>Check available disk space</li> <li>Monitor system resources</li> </ol>"},{"location":"api/","title":"API Reference","text":"<p>This section contains the automatically generated API documentation for MKV Episode Matcher.</p>"},{"location":"api/#core-modules","title":"Core Modules","text":""},{"location":"api/#mkv_episode_matcher.__main__","title":"mkv_episode_matcher.__main__","text":""},{"location":"api/#mkv_episode_matcher.__main__-functions","title":"Functions","text":""},{"location":"api/#mkv_episode_matcher.__main__.print_welcome_message","title":"print_welcome_message","text":"<pre><code>print_welcome_message()\n</code></pre> <p>Print a stylized welcome message.</p> Source code in <code>mkv_episode_matcher/__main__.py</code> <pre><code>def print_welcome_message():\n    \"\"\"Print a stylized welcome message.\"\"\"\n    console.print(\n        Panel.fit(\n            f\"[bold blue]MKV Episode Matcher v{__version__}[/bold blue]\\n\"\n            \"[cyan]Automatically match and rename your MKV TV episodes[/cyan]\",\n            border_style=\"blue\",\n            padding=(1, 4),\n        )\n    )\n    console.print()\n</code></pre>"},{"location":"api/#mkv_episode_matcher.__main__.confirm_api_key","title":"confirm_api_key","text":"<pre><code>confirm_api_key(config_value, key_name, description)\n</code></pre> <p>Confirm if the user wants to use an existing API key or enter a new one.</p> PARAMETER DESCRIPTION <code>config_value</code> <p>The current value from the config</p> <p> TYPE: <code>Optional[str]</code> </p> <code>key_name</code> <p>The name of the key</p> <p> TYPE: <code>str</code> </p> <code>description</code> <p>Description of the key for user information</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>str</code> <p>The API key to use</p> Source code in <code>mkv_episode_matcher/__main__.py</code> <pre><code>def confirm_api_key(config_value: Optional[str], key_name: str, description: str) -&gt; str:\n    \"\"\"\n    Confirm if the user wants to use an existing API key or enter a new one.\n\n    Args:\n        config_value: The current value from the config\n        key_name: The name of the key\n        description: Description of the key for user information\n\n    Returns:\n        The API key to use\n    \"\"\"\n    if config_value:\n        console.print(f\"[cyan]{key_name}:[/cyan] {description}\")\n        console.print(f\"Current value: [green]{mask_api_key(config_value)}[/green]\")\n        if Confirm.ask(\"Use existing key?\", default=True):\n            return config_value\n\n    return Prompt.ask(f\"Enter your {key_name}\")\n</code></pre>"},{"location":"api/#mkv_episode_matcher.__main__.mask_api_key","title":"mask_api_key","text":"<pre><code>mask_api_key(key)\n</code></pre> <p>Mask the API key for display purposes.</p> Source code in <code>mkv_episode_matcher/__main__.py</code> <pre><code>def mask_api_key(key: str) -&gt; str:\n    \"\"\"Mask the API key for display purposes.\"\"\"\n    if not key:\n        return \"\"\n    if len(key) &lt;= 8:\n        return \"*\" * len(key)\n    return key[:4] + \"*\" * (len(key) - 8) + key[-4:]\n</code></pre>"},{"location":"api/#mkv_episode_matcher.__main__.select_season","title":"select_season","text":"<pre><code>select_season(seasons)\n</code></pre> <p>Allow user to select a season from a list.</p> PARAMETER DESCRIPTION <code>seasons</code> <p>List of available seasons</p> <p> </p> RETURNS DESCRIPTION <p>Selected season number or None for all seasons</p> Source code in <code>mkv_episode_matcher/__main__.py</code> <pre><code>def select_season(seasons):\n    \"\"\"\n    Allow user to select a season from a list.\n\n    Args:\n        seasons: List of available seasons\n\n    Returns:\n        Selected season number or None for all seasons\n    \"\"\"\n    console.print(\"[bold cyan]Available Seasons:[/bold cyan]\")\n    for i, season in enumerate(seasons, 1):\n        season_num = Path(season).name.replace(\"Season \", \"\")\n        console.print(f\"  {i}. Season {season_num}\")\n\n    console.print(f\"  0. All Seasons\")\n\n    choice = Prompt.ask(\n        \"Select a season number (0 for all)\",\n        choices=[str(i) for i in range(len(seasons) + 1)],\n        default=\"0\"\n    )\n\n    if int(choice) == 0:\n        return None\n\n    selected_season = seasons[int(choice) - 1]\n    return int(Path(selected_season).name.replace(\"Season \", \"\"))\n</code></pre>"},{"location":"api/#mkv_episode_matcher.__main__.main","title":"main","text":"<pre><code>main()\n</code></pre> <p>Entry point of the application with enhanced user interface.</p> Source code in <code>mkv_episode_matcher/__main__.py</code> <pre><code>@logger.catch\ndef main():\n    \"\"\"\n    Entry point of the application with enhanced user interface.\n    \"\"\"\n    print_welcome_message()\n\n    # Parse command-line arguments\n    parser = argparse.ArgumentParser(\n        description=\"Automatically match and rename your MKV TV episodes\",\n        formatter_class=argparse.ArgumentDefaultsHelpFormatter,\n    )\n    parser.add_argument(\n        \"--version\",\n        action=\"version\",\n        version=f\"%(prog)s {__version__}\",\n        help=\"Show the version number and exit\",\n    )\n    parser.add_argument(\"--tmdb-api-key\", help=\"TMDb API key\")\n    parser.add_argument(\"--show-dir\", help=\"Main directory of the show\")\n    parser.add_argument(\n        \"--season\",\n        type=int,\n        default=None,\n        nargs=\"?\",\n        help=\"Specify the season number to be processed (default: all seasons)\",\n    )\n    parser.add_argument(\n        \"--dry-run\",\n        action=\"store_true\",\n        help=\"Don't rename any files, just show what would happen\",\n    )\n    parser.add_argument(\n        \"--get-subs\",\n        action=\"store_true\",\n        help=\"Download subtitles for the show\",\n    )\n    parser.add_argument(\n        \"--check-gpu\",\n        action=\"store_true\",\n        help=\"Check if GPU is available for faster processing\",\n    )\n    parser.add_argument(\n        \"--verbose\", \"-v\",\n        action=\"store_true\",\n        help=\"Enable verbose output\",\n    )\n    parser.add_argument(\n        \"--confidence\",\n        type=float,\n        default=0.7,\n        help=\"Set confidence threshold for episode matching (0.0-1.0)\",\n    )\n\n    args = parser.parse_args()\n    if args.verbose:\n        console.print(\"[bold cyan]Command-line Arguments[/bold cyan]\")\n        console.print(args)\n    if args.check_gpu:\n        from mkv_episode_matcher.utils import check_gpu_support\n        with console.status(\"[bold green]Checking GPU support...\"):\n            check_gpu_support()\n        return\n\n\n    logger.debug(f\"Command-line arguments: {args}\")\n\n    # Load configuration once\n    config = get_config(CONFIG_FILE)\n\n    # Get TMDb API key\n    tmdb_api_key = args.tmdb_api_key or config.get(\"tmdb_api_key\")\n\n    open_subtitles_api_key = config.get(\"open_subtitles_api_key\")\n    open_subtitles_user_agent = config.get(\"open_subtitles_user_agent\")\n    open_subtitles_username = config.get(\"open_subtitles_username\")\n    open_subtitles_password = config.get(\"open_subtitles_password\")\n\n    if args.get_subs:\n        console.print(\"[bold cyan]Subtitle Download Configuration[/bold cyan]\")\n\n        tmdb_api_key = confirm_api_key(\n            tmdb_api_key, \n            \"TMDb API key\", \n            \"Used to lookup show and episode information\"\n        )\n\n        open_subtitles_api_key = confirm_api_key(\n            open_subtitles_api_key,\n            \"OpenSubtitles API key\",\n            \"Required for subtitle downloads\"\n        )\n\n        open_subtitles_user_agent = confirm_api_key(\n            open_subtitles_user_agent,\n            \"OpenSubtitles User Agent\",\n            \"Required for subtitle downloads\"\n        )\n\n        open_subtitles_username = confirm_api_key(\n            open_subtitles_username,\n            \"OpenSubtitles Username\",\n            \"Account username for OpenSubtitles\"\n        )\n\n        open_subtitles_password = confirm_api_key(\n            open_subtitles_password,\n            \"OpenSubtitles Password\",\n            \"Account password for OpenSubtitles\"\n        )\n\n    # Use config for show directory\n    show_dir = args.show_dir or config.get(\"show_dir\")\n    if not show_dir:\n        show_dir = Prompt.ask(\"Enter the main directory of the show\")\n\n    logger.info(f\"Show Directory: {show_dir}\")\n    if not Path(show_dir).exists():\n        console.print(f\"[bold red]Error:[/bold red] Show directory '{show_dir}' does not exist.\")\n        return\n\n    if not show_dir:\n        show_dir = os.getcwd()\n        console.print(f\"Using current directory: [cyan]{show_dir}[/cyan]\")\n\n    logger.debug(f\"Show Directory: {show_dir}\")\n\n    # Set the configuration\n    set_config(\n        tmdb_api_key,\n        open_subtitles_api_key,\n        open_subtitles_user_agent,\n        open_subtitles_username,\n        open_subtitles_password,\n        show_dir,\n        CONFIG_FILE,\n    )\n    logger.info(\"Configuration set\")\n\n    # Process the show\n    from mkv_episode_matcher.episode_matcher import process_show\n    from mkv_episode_matcher.utils import get_valid_seasons\n\n    console.print()\n    if args.dry_run:\n        console.print(\n            Panel.fit(\n                \"[bold yellow]DRY RUN MODE[/bold yellow]\\n\"\n                \"Files will not be renamed, only showing what would happen.\",\n                border_style=\"yellow\",\n            )\n        )\n\n    seasons = get_valid_seasons(show_dir)\n    if not seasons:\n        console.print(\"[bold red]Error:[/bold red] No seasons with .mkv files found in the show directory.\")\n        return\n\n    # If season wasn't specified and there are multiple seasons, let user choose\n    selected_season = args.season\n    if selected_season is None and len(seasons) &gt; 1:\n        selected_season = select_season(seasons)\n\n    # Show what's going to happen\n    show_name = Path(show_dir).name\n    season_text = f\"Season {selected_season}\" if selected_season else \"all seasons\"\n\n    console.print(\n        f\"[bold green]Processing[/bold green] [cyan]{show_name}[/cyan], {season_text}\"\n    )\n\n    # # Setup progress spinner\n    # with Progress(\n    #     TextColumn(\"[bold green]Processing...[/bold green]\"),\n    #     console=console,\n    # ) as progress:\n    #     task = progress.add_task(\"\", total=None)\n    process_show(\n        selected_season, \n        dry_run=args.dry_run, \n        get_subs=args.get_subs, \n        verbose=args.verbose,\n        confidence=args.confidence\n    )\n\n    console.print(\"[bold green]\u2713[/bold green] Processing completed successfully!\")\n\n    # Show where logs are stored\n    console.print(f\"\\n[dim]Logs available at: {log_dir}[/dim]\")\n</code></pre>"},{"location":"api/#mkv_episode_matcher.episode_matcher","title":"mkv_episode_matcher.episode_matcher","text":""},{"location":"api/#mkv_episode_matcher.episode_matcher-classes","title":"Classes","text":""},{"location":"api/#mkv_episode_matcher.episode_matcher-functions","title":"Functions","text":""},{"location":"api/#mkv_episode_matcher.episode_matcher.process_show","title":"process_show","text":"<pre><code>process_show(season=None, dry_run=False, get_subs=False, verbose=False, confidence=0.6)\n</code></pre> <p>Process the show using streaming speech recognition with improved UI feedback.</p> PARAMETER DESCRIPTION <code>season</code> <p>Season number to process. Defaults to None (all seasons).</p> <p> TYPE: <code>int</code> DEFAULT: <code>None</code> </p> <code>dry_run</code> <p>If True, only simulate actions without making changes.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>get_subs</code> <p>If True, download subtitles for the show.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>verbose</code> <p>If True, display more detailed progress information.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>confidence</code> <p>Confidence threshold for episode matching (0.0-1.0).</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.6</code> </p> Source code in <code>mkv_episode_matcher/episode_matcher.py</code> <pre><code>def process_show(season=None, dry_run=False, get_subs=False, verbose=False, confidence=0.6):\n    \"\"\"\n    Process the show using streaming speech recognition with improved UI feedback.\n\n    Args:\n        season (int, optional): Season number to process. Defaults to None (all seasons).\n        dry_run (bool): If True, only simulate actions without making changes.\n        get_subs (bool): If True, download subtitles for the show.\n        verbose (bool): If True, display more detailed progress information.\n        confidence (float): Confidence threshold for episode matching (0.0-1.0).\n    \"\"\"\n    config = get_config(CONFIG_FILE)\n    show_dir = config.get(\"show_dir\")\n    show_name = clean_text(normalize_path(show_dir).name)\n    matcher = EpisodeMatcher(CACHE_DIR, show_name, min_confidence=confidence)\n\n    # Early check for reference files\n    reference_dir = Path(CACHE_DIR) / \"data\" / show_name\n    reference_files = list(reference_dir.glob(\"*.srt\"))\n    if (not get_subs) and (not reference_files):\n        console.print(\n            f\"[bold yellow]Warning:[/bold yellow] No reference subtitle files found in {reference_dir}\"\n        )\n        console.print(\"[cyan]Tip:[/cyan] Use --get-subs to download reference subtitles\")\n        return\n\n    season_paths = get_valid_seasons(show_dir)\n    if not season_paths:\n        console.print(\"[bold red]Error:[/bold red] No seasons with .mkv files found\")\n        return\n\n    if season is not None:\n        season_path = str(Path(show_dir) / f\"Season {season}\")\n        if season_path not in season_paths:\n            console.print(f\"[bold red]Error:[/bold red] Season {season} has no .mkv files to process\")\n            return\n        season_paths = [season_path]\n\n    total_processed = 0\n    total_matched = 0\n\n    for season_path in season_paths:\n        mkv_files = [\n            f for f in Path(season_path).glob(\"*.mkv\")\n            if not check_filename(f)\n        ]\n\n        if not mkv_files:\n            season_num = Path(season_path).name.replace(\"Season \", \"\")\n            console.print(f\"[dim]No new files to process in Season {season_num}[/dim]\")\n            continue\n\n        season_num = int(re.search(r'Season (\\d+)', season_path).group(1))\n        temp_dir = Path(season_path) / \"temp\"\n        temp_dir.mkdir(exist_ok=True)\n\n        try:\n            if get_subs:\n                show_id = fetch_show_id(matcher.show_name)\n                if show_id:\n                    console.print(f\"[bold cyan]Downloading subtitles for Season {season_num}...[/bold cyan]\")\n                    get_subtitles(show_id, seasons={season_num}, config=config)\n                else:\n                    console.print(\"[bold red]Error:[/bold red] Could not find show ID. Skipping subtitle download.\")\n\n            console.print(f\"[bold cyan]Processing {len(mkv_files)} files in Season {season_num}...[/bold cyan]\")\n\n            # Process files with a progress bar\n            with Progress(\n                TextColumn(\"[progress.description]{task.description}\"),\n                BarColumn(),\n                TextColumn(\"[progress.percentage]{task.percentage:&gt;3.0f}%\"),\n                TimeElapsedColumn(),\n                console=console,\n            ) as progress:\n                task = progress.add_task(f\"[cyan]Matching Season {season_num}[/cyan]\", total=len(mkv_files))\n\n                for mkv_file in mkv_files:\n                    file_basename = Path(mkv_file).name\n                    progress.update(task, description=f\"[cyan]Processing[/cyan] {file_basename}\")\n\n                    if verbose:\n                        console.print(f\"  Analyzing {file_basename}...\")\n\n                    total_processed += 1\n                    match = matcher.identify_episode(mkv_file, temp_dir, season_num)\n\n                    if match:\n                        total_matched += 1\n                        new_name = f\"{matcher.show_name} - S{match['season']:02d}E{match['episode']:02d}.mkv\"\n\n                        confidence_color = \"green\" if match['confidence'] &gt; 0.8 else \"yellow\"\n\n                        if verbose or dry_run:\n                            console.print(\n                                f\"  Match: [bold]{file_basename}[/bold] \u2192 [bold cyan]{new_name}[/bold cyan] \"\n                                f\"(confidence: [{confidence_color}]{match['confidence']:.2f}[/{confidence_color}])\"\n                            )\n\n                        if not dry_run:\n                            rename_episode_file(mkv_file, new_name)\n                    else:\n                        if verbose:\n                            console.print(f\"  [yellow]No match found for {file_basename}[/yellow]\")\n\n                    progress.advance(task)\n        finally:\n            if not dry_run and temp_dir.exists():\n                shutil.rmtree(temp_dir)\n\n    # Summary\n    console.print()\n    if total_processed == 0:\n        console.print(\"[yellow]No files needed processing[/yellow]\")\n    else:\n        console.print(f\"[bold]Summary:[/bold] Processed {total_processed} files\")\n        console.print(f\"[bold green]Successfully matched:[/bold green] {total_matched} files\")\n\n        if total_matched &lt; total_processed:\n            console.print(f\"[bold yellow]Unmatched:[/bold yellow] {total_processed - total_matched} files\")\n            console.print(\n                \"[cyan]Tip:[/cyan] Try downloading subtitles with --get-subs or \"\n                \"check that your files are named consistently\"\n            )\n</code></pre>"},{"location":"api/#mkv_episode_matcher.episode_identification","title":"mkv_episode_matcher.episode_identification","text":""},{"location":"api/#mkv_episode_matcher.episode_identification-classes","title":"Classes","text":""},{"location":"api/#mkv_episode_matcher.episode_identification.SubtitleCache","title":"SubtitleCache","text":"<pre><code>SubtitleCache()\n</code></pre> <p>Cache for storing parsed subtitle data to avoid repeated loading and parsing.</p> Source code in <code>mkv_episode_matcher/episode_identification.py</code> <pre><code>def __init__(self):\n    self.subtitles = {}  # {file_path: parsed_content}\n    self.chunk_cache = {}  # {(file_path, chunk_idx): text}\n</code></pre>"},{"location":"api/#mkv_episode_matcher.episode_identification.SubtitleCache-functions","title":"Functions","text":""},{"location":"api/#mkv_episode_matcher.episode_identification.SubtitleCache.get_subtitle_content","title":"get_subtitle_content","text":"<pre><code>get_subtitle_content(srt_file)\n</code></pre> <p>Get the full content of a subtitle file, loading it only once.</p> Source code in <code>mkv_episode_matcher/episode_identification.py</code> <pre><code>def get_subtitle_content(self, srt_file):\n    \"\"\"Get the full content of a subtitle file, loading it only once.\"\"\"\n    srt_file = str(srt_file)\n    if srt_file not in self.subtitles:\n        reader = SubtitleReader()\n        self.subtitles[srt_file] = reader.read_srt_file(srt_file)\n    return self.subtitles[srt_file]\n</code></pre>"},{"location":"api/#mkv_episode_matcher.episode_identification.SubtitleCache.get_chunk","title":"get_chunk","text":"<pre><code>get_chunk(srt_file, chunk_idx, chunk_start, chunk_end)\n</code></pre> <p>Get a specific time chunk from a subtitle file, with caching.</p> Source code in <code>mkv_episode_matcher/episode_identification.py</code> <pre><code>def get_chunk(self, srt_file, chunk_idx, chunk_start, chunk_end):\n    \"\"\"Get a specific time chunk from a subtitle file, with caching.\"\"\"\n    srt_file = str(srt_file)\n    cache_key = (srt_file, chunk_idx)\n\n    if cache_key not in self.chunk_cache:\n        content = self.get_subtitle_content(srt_file)\n        reader = SubtitleReader()\n        text_lines = reader.extract_subtitle_chunk(content, chunk_start, chunk_end)\n        self.chunk_cache[cache_key] = \" \".join(text_lines)\n\n    return self.chunk_cache[cache_key]\n</code></pre>"},{"location":"api/#mkv_episode_matcher.episode_identification.EpisodeMatcher","title":"EpisodeMatcher","text":"<pre><code>EpisodeMatcher(cache_dir, show_name, min_confidence=0.6)\n</code></pre> Source code in <code>mkv_episode_matcher/episode_identification.py</code> <pre><code>def __init__(self, cache_dir, show_name, min_confidence=0.6):\n    self.cache_dir = Path(cache_dir)\n    self.min_confidence = min_confidence\n    self.show_name = show_name\n    self.chunk_duration = 30\n    self.skip_initial_duration = 300\n    self.device = \"cuda\" if torch.cuda.is_available() else \"cpu\"\n    self.temp_dir = Path(tempfile.gettempdir()) / \"whisper_chunks\"\n    self.temp_dir.mkdir(exist_ok=True)\n    # Initialize subtitle cache\n    self.subtitle_cache = SubtitleCache()\n    # Cache for extracted audio chunks\n    self.audio_chunks = {}\n    # Store reference files to avoid repeated glob operations\n    self.reference_files_cache = {}\n</code></pre>"},{"location":"api/#mkv_episode_matcher.episode_identification.EpisodeMatcher-functions","title":"Functions","text":""},{"location":"api/#mkv_episode_matcher.episode_identification.EpisodeMatcher.extract_audio_chunk","title":"extract_audio_chunk","text":"<pre><code>extract_audio_chunk(mkv_file, start_time)\n</code></pre> <p>Extract a chunk of audio from MKV file with caching.</p> Source code in <code>mkv_episode_matcher/episode_identification.py</code> <pre><code>def extract_audio_chunk(self, mkv_file, start_time):\n    \"\"\"Extract a chunk of audio from MKV file with caching.\"\"\"\n    cache_key = (str(mkv_file), start_time)\n\n    if cache_key in self.audio_chunks:\n        return self.audio_chunks[cache_key]\n\n    chunk_path = self.temp_dir / f\"chunk_{start_time}.wav\"\n    if not chunk_path.exists():\n        cmd = [\n            \"ffmpeg\",\n            \"-ss\",\n            str(start_time),\n            \"-t\",\n            str(self.chunk_duration),\n            \"-i\",\n            mkv_file,\n            \"-vn\",  # Disable video\n            \"-sn\",  # Disable subtitles\n            \"-dn\",  # Disable data streams\n            \"-acodec\",\n            \"pcm_s16le\",\n            \"-ar\",\n            \"16000\",\n            \"-ac\",\n            \"1\",\n            \"-y\",  # Overwrite output files without asking\n            str(chunk_path),\n        ]\n        subprocess.run(cmd, capture_output=True)\n\n    chunk_path_str = str(chunk_path)\n    self.audio_chunks[cache_key] = chunk_path_str\n    return chunk_path_str\n</code></pre>"},{"location":"api/#mkv_episode_matcher.episode_identification.EpisodeMatcher.load_reference_chunk","title":"load_reference_chunk","text":"<pre><code>load_reference_chunk(srt_file, chunk_idx)\n</code></pre> <p>Load reference subtitles for a specific time chunk with caching.</p> PARAMETER DESCRIPTION <code>srt_file</code> <p>Path to the SRT file</p> <p> TYPE: <code>str or Path</code> </p> <code>chunk_idx</code> <p>Index of the chunk to load</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>str</code> <p>Combined text from the subtitle chunk</p> Source code in <code>mkv_episode_matcher/episode_identification.py</code> <pre><code>def load_reference_chunk(self, srt_file, chunk_idx):\n    \"\"\"\n    Load reference subtitles for a specific time chunk with caching.\n\n    Args:\n        srt_file (str or Path): Path to the SRT file\n        chunk_idx (int): Index of the chunk to load\n\n    Returns:\n        str: Combined text from the subtitle chunk\n    \"\"\"\n    try:\n        # Apply the same offset as in _try_match_with_model\n        chunk_start = self.skip_initial_duration + (chunk_idx * self.chunk_duration)\n        chunk_end = chunk_start + self.chunk_duration\n\n        return self.subtitle_cache.get_chunk(srt_file, chunk_idx, chunk_start, chunk_end)\n\n    except Exception as e:\n        logger.error(f\"Error loading reference chunk from {srt_file}: {e}\")\n        return \"\"\n</code></pre>"},{"location":"api/#mkv_episode_matcher.episode_identification.EpisodeMatcher.get_reference_files","title":"get_reference_files","text":"<pre><code>get_reference_files(season_number)\n</code></pre> <p>Get reference subtitle files with caching.</p> Source code in <code>mkv_episode_matcher/episode_identification.py</code> <pre><code>def get_reference_files(self, season_number):\n    \"\"\"Get reference subtitle files with caching.\"\"\"\n    cache_key = (self.show_name, season_number)\n    logger.debug(f\"Reference cache key: {cache_key}\")\n\n    if cache_key in self.reference_files_cache:\n        logger.debug(\"Returning cached reference files\")\n        return self.reference_files_cache[cache_key]\n\n    reference_dir = self.cache_dir / \"data\" / self.show_name\n    patterns = [\n        f\"S{season_number:02d}E\",\n        f\"S{season_number}E\",\n        f\"{season_number:02d}x\",\n        f\"{season_number}x\",\n    ]\n\n    reference_files = []\n    for _pattern in patterns:\n        files = [\n            f\n            for f in reference_dir.glob(\"*.srt\")\n            if any(\n                re.search(f\"{p}\\\\d+\", f.name, re.IGNORECASE) for p in patterns\n            )\n        ]\n        reference_files.extend(files)\n\n    # Remove duplicates while preserving order\n    reference_files = list(dict.fromkeys(reference_files))\n    logger.debug(f\"Found {len(reference_files)} reference files for season {season_number}\")\n    self.reference_files_cache[cache_key] = reference_files\n    return reference_files\n</code></pre>"},{"location":"api/#mkv_episode_matcher.episode_identification.EpisodeMatcher.identify_episode","title":"identify_episode","text":"<pre><code>identify_episode(video_file, temp_dir, season_number)\n</code></pre> <p>Progressive episode identification with faster initial attempt.</p> Source code in <code>mkv_episode_matcher/episode_identification.py</code> <pre><code>def identify_episode(self, video_file, temp_dir, season_number):\n    \"\"\"Progressive episode identification with faster initial attempt.\"\"\"\n    try:\n        # Get reference files first with caching\n        reference_files = self.get_reference_files(season_number)\n\n        if not reference_files:\n            logger.error(f\"No reference files found for season {season_number}\")\n            return None\n\n        # Cache video duration\n        duration = get_video_duration(video_file)\n\n        # Try with tiny model first (fastest)\n        logger.info(\"Attempting match with tiny model...\")\n        match = self._try_match_with_model(\n            video_file, \"tiny.en\", min(duration, 300), reference_files  # Limit to first 5 minutes\n        )\n        if match and match[\"confidence\"] &gt; 0.65:  # Slightly lower threshold for tiny\n            logger.info(\n                f\"Successfully matched with tiny model at {match['matched_at']}s (confidence: {match['confidence']:.2f})\"\n            )\n            return match\n\n        # If no match, try base model\n        logger.info(\n            \"No match with tiny model, extending base model search to 5 minutes...\"\n        )\n        match = self._try_match_with_model(\n            video_file, \"base.en\", min(duration, 300), reference_files  # Limit to first 5 minutes\n        )\n        if match:\n            logger.info(\n                f\"Successfully matched with base model at {match['matched_at']}s (confidence: {match['confidence']:.2f})\"\n            )\n            return match\n\n        logger.info(\"Speech recognition match failed\")\n        return None\n\n    finally:\n        # Cleanup temp files - keep this limited to only files we know we created\n        for chunk_info in self.audio_chunks.values():\n            try:\n                Path(chunk_info).unlink(missing_ok=True)\n            except Exception as e:\n                logger.warning(f\"Failed to delete temp file {chunk_info}: {e}\")\n</code></pre>"},{"location":"api/#mkv_episode_matcher.episode_identification.SubtitleReader","title":"SubtitleReader","text":"<p>Helper class for reading and parsing subtitle files.</p>"},{"location":"api/#mkv_episode_matcher.episode_identification.SubtitleReader-functions","title":"Functions","text":""},{"location":"api/#mkv_episode_matcher.episode_identification.SubtitleReader.parse_timestamp","title":"parse_timestamp  <code>staticmethod</code>","text":"<pre><code>parse_timestamp(timestamp)\n</code></pre> <p>Parse SRT timestamp into seconds.</p> Source code in <code>mkv_episode_matcher/episode_identification.py</code> <pre><code>@staticmethod\ndef parse_timestamp(timestamp):\n    \"\"\"Parse SRT timestamp into seconds.\"\"\"\n    hours, minutes, seconds = timestamp.replace(\",\", \".\").split(\":\")\n    return float(hours) * 3600 + float(minutes) * 60 + float(seconds)\n</code></pre>"},{"location":"api/#mkv_episode_matcher.episode_identification.SubtitleReader.read_srt_file","title":"read_srt_file  <code>staticmethod</code>","text":"<pre><code>read_srt_file(file_path)\n</code></pre> <p>Read an SRT file and return its contents with robust encoding handling.</p> PARAMETER DESCRIPTION <code>file_path</code> <p>Path to the SRT file</p> <p> TYPE: <code>str or Path</code> </p> RETURNS DESCRIPTION <code>str</code> <p>Contents of the SRT file</p> Source code in <code>mkv_episode_matcher/episode_identification.py</code> <pre><code>@staticmethod\ndef read_srt_file(file_path):\n    \"\"\"\n    Read an SRT file and return its contents with robust encoding handling.\n\n    Args:\n        file_path (str or Path): Path to the SRT file\n\n    Returns:\n        str: Contents of the SRT file\n    \"\"\"\n    return read_file_with_fallback(file_path)\n</code></pre>"},{"location":"api/#mkv_episode_matcher.episode_identification.SubtitleReader.extract_subtitle_chunk","title":"extract_subtitle_chunk  <code>staticmethod</code>","text":"<pre><code>extract_subtitle_chunk(content, start_time, end_time)\n</code></pre> <p>Extract subtitle text for a specific time window.</p> PARAMETER DESCRIPTION <code>content</code> <p>Full SRT file content</p> <p> TYPE: <code>str</code> </p> <code>start_time</code> <p>Chunk start time in seconds</p> <p> TYPE: <code>float</code> </p> <code>end_time</code> <p>Chunk end time in seconds</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>list</code> <p>List of subtitle texts within the time window</p> Source code in <code>mkv_episode_matcher/episode_identification.py</code> <pre><code>@staticmethod\ndef extract_subtitle_chunk(content, start_time, end_time):\n    \"\"\"\n    Extract subtitle text for a specific time window.\n\n    Args:\n        content (str): Full SRT file content\n        start_time (float): Chunk start time in seconds\n        end_time (float): Chunk end time in seconds\n\n    Returns:\n        list: List of subtitle texts within the time window\n    \"\"\"\n    text_lines = []\n\n    for block in content.strip().split(\"\\n\\n\"):\n        lines = block.split(\"\\n\")\n        if len(lines) &lt; 3 or \"--&gt;\" not in lines[1]:\n            continue\n\n        try:\n            timestamp = lines[1]\n            time_parts = timestamp.split(\" --&gt; \")\n            start_stamp = time_parts[0].strip()\n            end_stamp = time_parts[1].strip()\n\n            subtitle_start = SubtitleReader.parse_timestamp(start_stamp)\n            subtitle_end = SubtitleReader.parse_timestamp(end_stamp)\n\n            # Check if this subtitle overlaps with our chunk\n            if subtitle_end &gt;= start_time and subtitle_start &lt;= end_time:\n                text = \" \".join(lines[2:])\n                text_lines.append(text)\n\n        except (IndexError, ValueError) as e:\n            logger.warning(f\"Error parsing subtitle block: {e}\")\n            continue\n\n    return text_lines\n</code></pre>"},{"location":"api/#mkv_episode_matcher.episode_identification-functions","title":"Functions","text":""},{"location":"api/#mkv_episode_matcher.episode_identification.get_video_duration","title":"get_video_duration  <code>cached</code>","text":"<pre><code>get_video_duration(video_file)\n</code></pre> <p>Get video duration with caching.</p> Source code in <code>mkv_episode_matcher/episode_identification.py</code> <pre><code>@lru_cache(maxsize=100)\ndef get_video_duration(video_file):\n    \"\"\"Get video duration with caching.\"\"\"\n    duration = float(\n        subprocess.check_output([\n            \"ffprobe\",\n            \"-v\",\n            \"error\",\n            \"-show_entries\",\n            \"format=duration\",\n            \"-of\",\n            \"default=noprint_wrappers=1:nokey=1\",\n            video_file,\n        ]).decode()\n    )\n    return int(np.ceil(duration))\n</code></pre>"},{"location":"api/#mkv_episode_matcher.episode_identification.detect_file_encoding","title":"detect_file_encoding","text":"<pre><code>detect_file_encoding(file_path)\n</code></pre> <p>Detect the encoding of a file using chardet.</p> PARAMETER DESCRIPTION <code>file_path</code> <p>Path to the file</p> <p> TYPE: <code>str or Path</code> </p> RETURNS DESCRIPTION <code>str</code> <p>Detected encoding, defaults to 'utf-8' if detection fails</p> Source code in <code>mkv_episode_matcher/episode_identification.py</code> <pre><code>def detect_file_encoding(file_path):\n    \"\"\"\n    Detect the encoding of a file using chardet.\n\n    Args:\n        file_path (str or Path): Path to the file\n\n    Returns:\n        str: Detected encoding, defaults to 'utf-8' if detection fails\n    \"\"\"\n    try:\n        with open(file_path, \"rb\") as f:\n            raw_data = f.read(min(1024 * 1024, Path(file_path).stat().st_size))  # Read up to 1MB\n        result = chardet.detect(raw_data)\n        encoding = result[\"encoding\"]\n        confidence = result[\"confidence\"]\n\n        logger.debug(\n            f\"Detected encoding {encoding} with {confidence:.2%} confidence for {file_path}\"\n        )\n        return encoding if encoding else \"utf-8\"\n    except Exception as e:\n        logger.warning(f\"Error detecting encoding for {file_path}: {e}\")\n        return \"utf-8\"\n</code></pre>"},{"location":"api/#mkv_episode_matcher.episode_identification.read_file_with_fallback","title":"read_file_with_fallback  <code>cached</code>","text":"<pre><code>read_file_with_fallback(file_path, encodings=None)\n</code></pre> <p>Read a file trying multiple encodings in order of preference.</p> PARAMETER DESCRIPTION <code>file_path</code> <p>Path to the file</p> <p> TYPE: <code>str or Path</code> </p> <code>encodings</code> <p>List of encodings to try, defaults to common subtitle encodings</p> <p> TYPE: <code>list</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>str</code> <p>File contents</p> RAISES DESCRIPTION <code>ValueError</code> <p>If file cannot be read with any encoding</p> Source code in <code>mkv_episode_matcher/episode_identification.py</code> <pre><code>@lru_cache(maxsize=100)\ndef read_file_with_fallback(file_path, encodings=None):\n    \"\"\"\n    Read a file trying multiple encodings in order of preference.\n\n    Args:\n        file_path (str or Path): Path to the file\n        encodings (list): List of encodings to try, defaults to common subtitle encodings\n\n    Returns:\n        str: File contents\n\n    Raises:\n        ValueError: If file cannot be read with any encoding\n    \"\"\"\n    if encodings is None:\n        # First try detected encoding, then fallback to common subtitle encodings\n        detected = detect_file_encoding(file_path)\n        encodings = [detected, \"utf-8\", \"latin-1\", \"cp1252\", \"iso-8859-1\"]\n\n    file_path = Path(file_path)\n    errors = []\n\n    for encoding in encodings:\n        try:\n            with open(file_path, encoding=encoding) as f:\n                content = f.read()\n            logger.debug(f\"Successfully read {file_path} using {encoding} encoding\")\n            return content\n        except UnicodeDecodeError as e:\n            errors.append(f\"{encoding}: {str(e)}\")\n            continue\n\n    error_msg = f\"Failed to read {file_path} with any encoding. Errors:\\n\" + \"\\n\".join(\n        errors\n    )\n    logger.error(error_msg)\n    raise ValueError(error_msg)\n</code></pre>"},{"location":"api/#mkv_episode_matcher.episode_identification.get_whisper_model","title":"get_whisper_model","text":"<pre><code>get_whisper_model(model_name='tiny', device=None)\n</code></pre> <p>Cache whisper models to avoid reloading.</p> Source code in <code>mkv_episode_matcher/episode_identification.py</code> <pre><code>def get_whisper_model(model_name=\"tiny\", device=None):\n    \"\"\"Cache whisper models to avoid reloading.\"\"\"\n    global _whisper_models\n    if device is None:\n        device = \"cuda\" if torch.cuda.is_available() else \"cpu\"\n\n    key = f\"{model_name}_{device}\"\n    if key not in _whisper_models:\n        _whisper_models[key] = whisper.load_model(model_name, device=device)\n        logger.info(f\"Loaded {model_name} model on {device}\")\n\n    return _whisper_models[key]\n</code></pre>"},{"location":"api/#tmdb-client","title":"TMDB Client","text":""},{"location":"api/#mkv_episode_matcher.tmdb_client","title":"mkv_episode_matcher.tmdb_client","text":""},{"location":"api/#mkv_episode_matcher.tmdb_client-classes","title":"Classes","text":""},{"location":"api/#mkv_episode_matcher.tmdb_client.RateLimitedRequest","title":"RateLimitedRequest","text":"<pre><code>RateLimitedRequest(rate_limit=30, period=1)\n</code></pre> <p>A class that represents a rate-limited request object.</p> ATTRIBUTE DESCRIPTION <code>rate_limit</code> <p>Maximum number of requests allowed per period.</p> <p> TYPE: <code>int</code> </p> <code>period</code> <p>Period in seconds.</p> <p> TYPE: <code>int</code> </p> <code>requests_made</code> <p>Counter for requests made.</p> <p> TYPE: <code>int</code> </p> <code>start_time</code> <p>Start time of the current period.</p> <p> TYPE: <code>float</code> </p> <code>lock</code> <p>Lock for synchronization.</p> <p> TYPE: <code>Lock</code> </p> Source code in <code>mkv_episode_matcher/tmdb_client.py</code> <pre><code>def __init__(self, rate_limit=30, period=1):\n    self.rate_limit = rate_limit\n    self.period = period\n    self.requests_made = 0\n    self.start_time = time.time()\n    self.lock = Lock()\n</code></pre>"},{"location":"api/#mkv_episode_matcher.tmdb_client.RateLimitedRequest-functions","title":"Functions","text":""},{"location":"api/#mkv_episode_matcher.tmdb_client.RateLimitedRequest.get","title":"get","text":"<pre><code>get(url)\n</code></pre> <p>Sends a rate-limited GET request to the specified URL.</p> PARAMETER DESCRIPTION <code>url</code> <p>The URL to send the request to.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Response</code> <p>The response object returned by the request.</p> Source code in <code>mkv_episode_matcher/tmdb_client.py</code> <pre><code>def get(self, url):\n    \"\"\"\n    Sends a rate-limited GET request to the specified URL.\n\n    Args:\n        url (str): The URL to send the request to.\n\n    Returns:\n        Response: The response object returned by the request.\n    \"\"\"\n    with self.lock:\n        if self.requests_made &gt;= self.rate_limit:\n            sleep_time = self.period - (time.time() - self.start_time)\n            if sleep_time &gt; 0:\n                time.sleep(sleep_time)\n            self.requests_made = 0\n            self.start_time = time.time()\n\n        self.requests_made += 1\n\n    response = requests.get(url)\n    return response\n</code></pre>"},{"location":"api/#mkv_episode_matcher.tmdb_client-functions","title":"Functions","text":""},{"location":"api/#mkv_episode_matcher.tmdb_client.fetch_show_id","title":"fetch_show_id","text":"<pre><code>fetch_show_id(show_name)\n</code></pre> <p>Fetch the TMDb ID for a given show name.</p> PARAMETER DESCRIPTION <code>show_name</code> <p>The name of the show.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>str</code> <p>The TMDb ID of the show, or None if not found.</p> Source code in <code>mkv_episode_matcher/tmdb_client.py</code> <pre><code>def fetch_show_id(show_name):\n    \"\"\"\n    Fetch the TMDb ID for a given show name.\n\n    Args:\n        show_name (str): The name of the show.\n\n    Returns:\n        str: The TMDb ID of the show, or None if not found.\n    \"\"\"\n    config = get_config(CONFIG_FILE)\n    tmdb_api_key = config.get(\"tmdb_api_key\")\n    url = f\"https://api.themoviedb.org/3/search/tv?query={show_name}&amp;api_key={tmdb_api_key}\"\n    response = requests.get(url)\n    if response.status_code == 200:\n        results = response.json().get(\"results\", [])\n        if results:\n            return str(results[0][\"id\"])\n    return None\n</code></pre>"},{"location":"api/#mkv_episode_matcher.tmdb_client.fetch_season_details","title":"fetch_season_details","text":"<pre><code>fetch_season_details(show_id, season_number)\n</code></pre> <p>Fetch the total number of episodes for a given show and season from the TMDb API.</p> PARAMETER DESCRIPTION <code>show_id</code> <p>The ID of the show on TMDb.</p> <p> TYPE: <code>str</code> </p> <code>season_number</code> <p>The season number to fetch details for.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>int</code> <p>The total number of episodes in the season, or 0 if the API request failed.</p> Source code in <code>mkv_episode_matcher/tmdb_client.py</code> <pre><code>def fetch_season_details(show_id, season_number):\n    \"\"\"\n    Fetch the total number of episodes for a given show and season from the TMDb API.\n\n    Args:\n        show_id (str): The ID of the show on TMDb.\n        season_number (int): The season number to fetch details for.\n\n    Returns:\n        int: The total number of episodes in the season, or 0 if the API request failed.\n    \"\"\"\n    logger.info(f\"Fetching season details for Season {season_number}...\")\n    config = get_config(CONFIG_FILE)\n    tmdb_api_key = config.get(\"tmdb_api_key\")\n    url = f\"https://api.themoviedb.org/3/tv/{show_id}/season/{season_number}?api_key={tmdb_api_key}\"\n    try:\n        response = requests.get(url)\n        response.raise_for_status()\n        season_data = response.json()\n        total_episodes = len(season_data.get(\"episodes\", []))\n        return total_episodes\n    except requests.exceptions.RequestException as e:\n        logger.error(f\"Failed to fetch season details for Season {season_number}: {e}\")\n        return 0\n    except KeyError:\n        logger.error(\n            f\"Missing 'episodes' key in response JSON data for Season {season_number}\"\n        )\n        return 0\n</code></pre>"},{"location":"api/#mkv_episode_matcher.tmdb_client.get_number_of_seasons","title":"get_number_of_seasons","text":"<pre><code>get_number_of_seasons(show_id)\n</code></pre> <p>Retrieves the number of seasons for a given TV show from the TMDB API.</p> <p>Parameters: - show_id (int): The ID of the TV show.</p> <p>Returns: - num_seasons (int): The number of seasons for the TV show.</p> <p>Raises: - requests.HTTPError: If there is an error while making the API request.</p> Source code in <code>mkv_episode_matcher/tmdb_client.py</code> <pre><code>def get_number_of_seasons(show_id):\n    \"\"\"\n    Retrieves the number of seasons for a given TV show from the TMDB API.\n\n    Parameters:\n    - show_id (int): The ID of the TV show.\n\n    Returns:\n    - num_seasons (int): The number of seasons for the TV show.\n\n    Raises:\n    - requests.HTTPError: If there is an error while making the API request.\n    \"\"\"\n    config = get_config(CONFIG_FILE)\n    tmdb_api_key = config.get(\"tmdb_api_key\")\n    url = f\"https://api.themoviedb.org/3/tv/{show_id}?api_key={tmdb_api_key}\"\n    response = requests.get(url)\n    response.raise_for_status()\n    show_data = response.json()\n    num_seasons = show_data.get(\"number_of_seasons\", 0)\n    logger.info(f\"Found {num_seasons} seasons\")\n    return num_seasons\n</code></pre>"},{"location":"api/#utilities","title":"Utilities","text":""},{"location":"api/#mkv_episode_matcher.utils","title":"mkv_episode_matcher.utils","text":""},{"location":"api/#mkv_episode_matcher.utils-functions","title":"Functions","text":""},{"location":"api/#mkv_episode_matcher.utils.normalize_path","title":"normalize_path","text":"<pre><code>normalize_path(path_str)\n</code></pre> <p>Normalize a path string to handle cross-platform path issues. Properly handles trailing slashes and backslashes in both Windows and Unix paths.</p> PARAMETER DESCRIPTION <code>path_str</code> <p>The path string to normalize</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <p>pathlib.Path: A normalized Path object</p> Source code in <code>mkv_episode_matcher/utils.py</code> <pre><code>def normalize_path(path_str):\n    \"\"\"\n    Normalize a path string to handle cross-platform path issues.\n    Properly handles trailing slashes and backslashes in both Windows and Unix paths.\n\n    Args:\n        path_str (str): The path string to normalize\n\n    Returns:\n        pathlib.Path: A normalized Path object\n    \"\"\"\n    # Convert to string if it's a Path object\n    if isinstance(path_str, Path):\n        path_str = str(path_str)\n\n    # Remove trailing slashes or backslashes\n    path_str = path_str.rstrip('/').rstrip('\\\\')\n\n    # Handle Windows paths on non-Windows platforms\n    if os.name != 'nt' and '\\\\' in path_str and ':' in path_str[:2]:\n        # This looks like a Windows path on a non-Windows system\n        # Extract the last component which should be the directory/file name\n        components = path_str.split('\\\\')\n        return Path(components[-1])\n\n    return Path(path_str)\n</code></pre>"},{"location":"api/#mkv_episode_matcher.utils.get_valid_seasons","title":"get_valid_seasons","text":"<pre><code>get_valid_seasons(show_dir)\n</code></pre> <p>Get all season directories that contain MKV files.</p> PARAMETER DESCRIPTION <code>show_dir</code> <p>Base directory for the TV show</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>list</code> <p>List of paths to valid season directories</p> Source code in <code>mkv_episode_matcher/utils.py</code> <pre><code>def get_valid_seasons(show_dir):\n    \"\"\"\n    Get all season directories that contain MKV files.\n\n    Args:\n        show_dir (str): Base directory for the TV show\n\n    Returns:\n        list: List of paths to valid season directories\n    \"\"\"\n    # Get all season directories\n    show_path = normalize_path(show_dir)\n    season_paths = [\n        str(show_path / d.name)\n        for d in show_path.iterdir()\n        if d.is_dir()\n    ]\n\n    # Filter seasons to only include those with .mkv files\n    valid_season_paths = []\n    for season_path in season_paths:\n        season_path_obj = Path(season_path)\n        mkv_files = [f for f in season_path_obj.iterdir() if f.name.endswith(\".mkv\")]\n        if mkv_files:\n            valid_season_paths.append(season_path)\n\n    if not valid_season_paths:\n        logger.warning(\n            f\"No seasons with .mkv files found in show '{normalize_path(show_dir).name}'\"\n        )\n    else:\n        logger.info(\n            f\"Found {len(valid_season_paths)} seasons with .mkv files in '{normalize_path(show_dir).name}'\"\n        )\n\n    return valid_season_paths\n</code></pre>"},{"location":"api/#mkv_episode_matcher.utils.check_filename","title":"check_filename","text":"<pre><code>check_filename(filename)\n</code></pre> <p>Check if the filename is in the correct format (S01E02).</p> PARAMETER DESCRIPTION <code>filename</code> <p>The filename to check.</p> <p> TYPE: <code>str or Path</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if the filename matches the expected pattern.</p> Source code in <code>mkv_episode_matcher/utils.py</code> <pre><code>def check_filename(filename):\n    \"\"\"\n    Check if the filename is in the correct format (S01E02).\n\n    Args:\n        filename (str or Path): The filename to check.\n\n    Returns:\n        bool: True if the filename matches the expected pattern.\n    \"\"\"\n    # Convert Path object to string if needed\n    if isinstance(filename, Path):\n        filename = str(filename)\n    # Check if the filename matches the expected format\n    match = re.search(r\".*S\\d+E\\d+\", filename)\n    return bool(match)\n</code></pre>"},{"location":"api/#mkv_episode_matcher.utils.scramble_filename","title":"scramble_filename","text":"<pre><code>scramble_filename(original_file_path, file_number)\n</code></pre> <p>Scrambles the filename of the given file path by adding the series title and file number.</p> PARAMETER DESCRIPTION <code>original_file_path</code> <p>The original file path.</p> <p> TYPE: <code>str</code> </p> <code>file_number</code> <p>The file number to be added to the filename.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <p>None</p> Source code in <code>mkv_episode_matcher/utils.py</code> <pre><code>def scramble_filename(original_file_path, file_number):\n    \"\"\"\n    Scrambles the filename of the given file path by adding the series title and file number.\n\n    Args:\n        original_file_path (str): The original file path.\n        file_number (int): The file number to be added to the filename.\n\n    Returns:\n        None\n    \"\"\"\n    logger.info(f\"Scrambling {original_file_path}\")\n    series_title = normalize_path(original_file_path).parent.parent.name\n    original_file_name = Path(original_file_path).name\n    extension = Path(original_file_path).suffix\n    new_file_name = f\"{series_title} - {file_number:03d}{extension}\"\n    new_file_path = Path(original_file_path).parent / new_file_name\n    if not new_file_path.exists():\n        logger.info(f\"Renaming {original_file_name} -&gt; {new_file_name}\")\n        Path(original_file_path).rename(new_file_path)\n</code></pre>"},{"location":"api/#mkv_episode_matcher.utils.rename_episode_file","title":"rename_episode_file","text":"<pre><code>rename_episode_file(original_file_path, new_filename)\n</code></pre> <p>Rename an episode file with a standardized naming convention.</p> PARAMETER DESCRIPTION <code>original_file_path</code> <p>The original file path of the episode.</p> <p> TYPE: <code>str or Path</code> </p> <code>new_filename</code> <p>The new filename including season/episode info.</p> <p> TYPE: <code>str or Path</code> </p> RETURNS DESCRIPTION <code>Path</code> <p>Path to the renamed file, or None if rename failed.</p> Source code in <code>mkv_episode_matcher/utils.py</code> <pre><code>def rename_episode_file(original_file_path, new_filename):\n    \"\"\"\n    Rename an episode file with a standardized naming convention.\n\n    Args:\n        original_file_path (str or Path): The original file path of the episode.\n        new_filename (str or Path): The new filename including season/episode info.\n\n    Returns:\n        Path: Path to the renamed file, or None if rename failed.\n    \"\"\"\n    original_dir = Path(original_file_path).parent\n    new_file_path = original_dir / new_filename\n\n    # Check if new filepath already exists\n    if new_file_path.exists():\n        logger.warning(f\"File already exists: {new_filename}\")\n\n        # Add numeric suffix if file exists\n        base, ext = Path(new_filename).stem, Path(new_filename).suffix\n        suffix = 2\n        while True:\n            new_filename = f\"{base}_{suffix}{ext}\"\n            new_file_path = original_dir / new_filename\n            if not new_file_path.exists():\n                break\n            suffix += 1\n\n    try:\n        Path(original_file_path).rename(new_file_path)\n        logger.info(f\"Renamed {Path(original_file_path).name} -&gt; {new_filename}\")\n        return new_file_path\n    except OSError as e:\n        logger.error(f\"Failed to rename file: {e}\")\n        return None\n    except FileExistsError as e:\n        logger.error(f\"Failed to rename file: {e}\")\n        return None\n</code></pre>"},{"location":"api/#mkv_episode_matcher.utils.get_subtitles","title":"get_subtitles","text":"<pre><code>get_subtitles(show_id, seasons, config=None, max_retries=3)\n</code></pre> <p>Retrieves and saves subtitles for a given TV show and seasons.</p> PARAMETER DESCRIPTION <code>show_id</code> <p>The ID of the TV show.</p> <p> TYPE: <code>int</code> </p> <code>seasons</code> <p>A set of season numbers for which subtitles should be retrieved.</p> <p> TYPE: <code>Set[int]</code> </p> <code>config</code> <p>Preloaded configuration.</p> <p> TYPE: <code>Config object</code> DEFAULT: <code>None</code> </p> <code>max_retries</code> <p>Number of times to retry subtitle download on OpenSubtitlesException. Defaults to 3.</p> <p> TYPE: <code>int</code> DEFAULT: <code>3</code> </p> Source code in <code>mkv_episode_matcher/utils.py</code> <pre><code>def get_subtitles(show_id, seasons: set[int], config=None, max_retries=3):\n    \"\"\"\n    Retrieves and saves subtitles for a given TV show and seasons.\n\n    Args:\n        show_id (int): The ID of the TV show.\n        seasons (Set[int]): A set of season numbers for which subtitles should be retrieved.\n        config (Config object, optional): Preloaded configuration.\n        max_retries (int, optional): Number of times to retry subtitle download on OpenSubtitlesException. Defaults to 3.\n    \"\"\"\n    if config is None:\n        config = get_config(CONFIG_FILE)\n    show_dir = config.get(\"show_dir\")\n    series_name = sanitize_filename(normalize_path(show_dir).name)\n    tmdb_api_key = config.get(\"tmdb_api_key\")\n    open_subtitles_api_key = config.get(\"open_subtitles_api_key\")\n    open_subtitles_user_agent = config.get(\"open_subtitles_user_agent\")\n    open_subtitles_username = config.get(\"open_subtitles_username\")\n    open_subtitles_password = config.get(\"open_subtitles_password\")\n\n    if not all([\n        show_dir,\n        tmdb_api_key,\n        open_subtitles_api_key,\n        open_subtitles_user_agent,\n        open_subtitles_username,\n        open_subtitles_password,\n    ]):\n        logger.error(\"Missing configuration settings. Please run the setup script.\")\n        return\n\n    try:\n        subtitles = OpenSubtitles(open_subtitles_user_agent, open_subtitles_api_key)\n        subtitles.login(open_subtitles_username, open_subtitles_password)\n    except Exception as e:\n        logger.error(f\"Failed to log in to OpenSubtitles: {e}\")\n        return\n\n    for season in seasons:\n        episodes = fetch_season_details(show_id, season)\n        logger.info(f\"Found {episodes} episodes in Season {season}\")\n\n        for episode in range(1, episodes + 1):\n            logger.info(f\"Processing Season {season}, Episode {episode}...\")\n\n            series_cache_dir = Path(CACHE_DIR) / \"data\" / series_name\n            os.makedirs(series_cache_dir, exist_ok=True)\n\n            # Check for existing subtitle in any supported format\n            existing_subtitle = find_existing_subtitle(\n                series_cache_dir, series_name, season, episode\n            )\n\n            if existing_subtitle:\n                logger.info(\n                    f\"Subtitle already exists: {Path(existing_subtitle).name}\"\n                )\n                continue\n\n            # Default to standard format for new downloads\n            srt_filepath = str(series_cache_dir / f\"{series_name} - S{season:02d}E{episode:02d}.srt\")\n\n            # get the episode info from TMDB\n            url = f\"https://api.themoviedb.org/3/tv/{show_id}/season/{season}/episode/{episode}?api_key={tmdb_api_key}\"\n            response = requests.get(url)\n            response.raise_for_status()\n            episode_data = response.json()\n            episode_id = episode_data[\"id\"]\n\n            # search for the subtitle\n            response = subtitles.search(tmdb_id=episode_id, languages=\"en\")\n            if len(response.data) == 0:\n                logger.warning(\n                    f\"No subtitles found for {series_name} - S{season:02d}E{episode:02d}\"\n                )\n                continue\n\n            for subtitle in response.data:\n                subtitle_dict = subtitle.to_dict()\n                # Remove special characters and convert to uppercase\n                filename_clean = re.sub(r\"\\\\W+\", \" \", subtitle_dict[\"file_name\"]).upper()\n                if f\"E{episode:02d}\" in filename_clean:\n                    logger.info(f\"Original filename: {subtitle_dict['file_name']}\")\n                    retry_count = 0\n                    while retry_count &lt; max_retries:\n                        try:\n                            srt_file = subtitles.download_and_save(subtitle)\n                            shutil.move(srt_file, srt_filepath)\n                            logger.info(f\"Subtitle saved to {srt_filepath}\")\n                            break\n                        except OpenSubtitlesException as e:\n                            retry_count += 1\n                            logger.error(f\"OpenSubtitlesException (attempt {retry_count}): {e}\")\n                            console.print(f\"[red]OpenSubtitlesException (attempt {retry_count}): {e}[/red]\")\n                            if retry_count &gt;= max_retries:\n                                user_input = input(\"Would you like to continue matching? (y/n): \")\n                                if user_input.strip().lower() != 'y':\n                                    logger.info(\"User chose to stop matching due to the error.\")\n                                    return\n                                else:\n                                    logger.info(\"User chose to continue matching despite the error.\")\n                                    break\n                        except Exception as e:\n                            logger.error(f\"Failed to download and save subtitle: {e}\")\n                            console.print(f\"[red]Failed to download and save subtitle: {e}[/red]\")\n                            user_input = input(\"Would you like to continue matching despite the error? (y/n): \")\n                            if user_input.strip().lower() != 'y':\n                                logger.info(\"User chose to stop matching due to the error.\")\n                                return\n                            else:\n                                logger.info(\"User chose to continue matching despite the error.\")\n                                break\n                    else:\n                        continue\n                    break\n</code></pre>"},{"location":"api/#mkv_episode_matcher.utils.process_reference_srt_files","title":"process_reference_srt_files","text":"<pre><code>process_reference_srt_files(series_name)\n</code></pre> <p>Process reference SRT files for a given series.</p> PARAMETER DESCRIPTION <code>series_name</code> <p>The name of the series.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>dict</code> <p>A dictionary containing the reference files where the keys are the MKV filenames   and the values are the corresponding SRT texts.</p> Source code in <code>mkv_episode_matcher/utils.py</code> <pre><code>@logger.catch\ndef process_reference_srt_files(series_name):\n    \"\"\"\n    Process reference SRT files for a given series.\n\n    Args:\n        series_name (str): The name of the series.\n\n    Returns:\n        dict: A dictionary containing the reference files where the keys are the MKV filenames\n              and the values are the corresponding SRT texts.\n    \"\"\"\n    from mkv_episode_matcher.__main__ import CACHE_DIR\n\n    reference_files = {}\n    reference_dir = Path(CACHE_DIR) / \"data\" / series_name\n\n    for dirpath, _, filenames in os.walk(reference_dir):\n        for filename in filenames:\n            if filename.lower().endswith(\".srt\"):\n                srt_file = Path(dirpath) / filename\n                logger.info(f\"Processing {srt_file}\")\n                srt_text = extract_srt_text(srt_file)\n                season, episode = extract_season_episode(filename)\n                mkv_filename = f\"{series_name} - S{season:02}E{episode:02}.mkv\"\n                reference_files[mkv_filename] = srt_text\n\n    return reference_files\n</code></pre>"},{"location":"api/#mkv_episode_matcher.utils.extract_srt_text","title":"extract_srt_text","text":"<pre><code>extract_srt_text(filepath)\n</code></pre> <p>Extracts text content from an SRT file.</p> PARAMETER DESCRIPTION <code>filepath</code> <p>Path to the SRT file.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>list</code> <p>List of text lines from the SRT file.</p> Source code in <code>mkv_episode_matcher/utils.py</code> <pre><code>def extract_srt_text(filepath):\n    \"\"\"\n    Extracts text content from an SRT file.\n\n    Args:\n        filepath (str): Path to the SRT file.\n\n    Returns:\n        list: List of text lines from the SRT file.\n    \"\"\"\n    # Read the file content\n    with open(filepath) as f:\n        content = f.read()\n\n    # Split into subtitle blocks\n    blocks = content.strip().split(\"\\n\\n\")\n\n    text_lines = []\n    for block in blocks:\n        lines = block.split(\"\\n\")\n        if len(lines) &lt; 3:\n            continue\n\n        # Skip index and timestamp, get all remaining lines as text\n        text = \" \".join(lines[2:])\n        # Remove stage directions and tags\n        text = re.sub(r\"\\[.*?\\]|\\&lt;.*?\\&gt;\", \"\", text)\n        if text:\n            text_lines.append(text)\n\n    return text_lines\n</code></pre>"},{"location":"api/#mkv_episode_matcher.utils.extract_season_episode","title":"extract_season_episode","text":"<pre><code>extract_season_episode(filename)\n</code></pre> <p>Extract season and episode numbers from filename with support for multiple formats.</p> PARAMETER DESCRIPTION <code>filename</code> <p>Filename to parse</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>tuple</code> <p>(season_number, episode_number)</p> Source code in <code>mkv_episode_matcher/utils.py</code> <pre><code>def extract_season_episode(filename):\n    \"\"\"\n    Extract season and episode numbers from filename with support for multiple formats.\n\n    Args:\n        filename (str): Filename to parse\n\n    Returns:\n        tuple: (season_number, episode_number)\n    \"\"\"\n    # List of patterns to try\n    patterns = [\n        r\"S(\\d+)E(\\d+)\",  # S01E01\n        r\"(\\d+)x(\\d+)\",  # 1x01 or 01x01\n        r\"Season\\s*(\\d+).*?(\\d+)\",  # Season 1 - 01\n    ]\n\n    for pattern in patterns:\n        match = re.search(pattern, filename, re.IGNORECASE)\n        if match:\n            return int(match.group(1)), int(match.group(2))\n\n    return None, None\n</code></pre>"},{"location":"api/#mkv_episode_matcher.utils.process_srt_files","title":"process_srt_files","text":"<pre><code>process_srt_files(show_dir)\n</code></pre> <p>Process all SRT files in the given directory and its subdirectories.</p> PARAMETER DESCRIPTION <code>show_dir</code> <p>The directory path where the SRT files are located.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>dict</code> <p>A dictionary containing the SRT file paths as keys and their corresponding text content as values.</p> Source code in <code>mkv_episode_matcher/utils.py</code> <pre><code>def process_srt_files(show_dir):\n    \"\"\"\n    Process all SRT files in the given directory and its subdirectories.\n\n    Args:\n        show_dir (str): The directory path where the SRT files are located.\n\n    Returns:\n        dict: A dictionary containing the SRT file paths as keys and their corresponding text content as values.\n    \"\"\"\n    srt_files = {}\n    for dirpath, _, filenames in os.walk(show_dir):\n        for filename in filenames:\n            if filename.lower().endswith(\".srt\"):\n                srt_file = Path(dirpath) / filename\n                logger.info(f\"Processing {srt_file}\")\n                srt_text = extract_srt_text(srt_file)\n                srt_files[srt_file] = srt_text\n    return srt_files\n</code></pre>"},{"location":"api/#mkv_episode_matcher.utils.compare_and_rename_files","title":"compare_and_rename_files","text":"<pre><code>compare_and_rename_files(srt_files, reference_files, dry_run=False)\n</code></pre> <p>Compare the srt files with the reference files and rename the matching mkv files.</p> PARAMETER DESCRIPTION <code>srt_files</code> <p>A dictionary containing the srt files as keys and their contents as values.</p> <p> TYPE: <code>dict</code> </p> <code>reference_files</code> <p>A dictionary containing the reference files as keys and their contents as values.</p> <p> TYPE: <code>dict</code> </p> <code>dry_run</code> <p>If True, the function will only log the renaming actions without actually renaming the files. Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>mkv_episode_matcher/utils.py</code> <pre><code>def compare_and_rename_files(srt_files, reference_files, dry_run=False):\n    \"\"\"\n    Compare the srt files with the reference files and rename the matching mkv files.\n\n    Args:\n        srt_files (dict): A dictionary containing the srt files as keys and their contents as values.\n        reference_files (dict): A dictionary containing the reference files as keys and their contents as values.\n        dry_run (bool, optional): If True, the function will only log the renaming actions without actually renaming the files. Defaults to False.\n    \"\"\"\n    logger.info(\n        f\"Comparing {len(srt_files)} srt files with {len(reference_files)} reference files\"\n    )\n    for srt_text in srt_files.keys():\n        parent_dir = Path(srt_text).parent.parent\n        for reference in reference_files.keys():\n            _season, _episode = extract_season_episode(reference)\n            mkv_file = str(parent_dir / Path(srt_text).name.replace(\".srt\", \".mkv\"))\n            matching_lines = compare_text(\n                reference_files[reference], srt_files[srt_text]\n            )\n            if matching_lines &gt;= int(len(reference_files[reference]) * 0.1):\n                logger.info(f\"Matching lines: {matching_lines}\")\n                logger.info(f\"Found matching file: {mkv_file} -&gt;{reference}\")\n                new_filename = parent_dir / reference\n                if not dry_run:\n                    logger.info(f\"Renaming {mkv_file} to {str(new_filename)}\")\n                    rename_episode_file(mkv_file, reference)\n</code></pre>"},{"location":"api/#mkv_episode_matcher.utils.compare_text","title":"compare_text","text":"<pre><code>compare_text(text1, text2)\n</code></pre> <p>Compare two lists of text lines and return the number of matching lines.</p> PARAMETER DESCRIPTION <code>text1</code> <p>List of text lines from the first source.</p> <p> TYPE: <code>list</code> </p> <code>text2</code> <p>List of text lines from the second source.</p> <p> TYPE: <code>list</code> </p> RETURNS DESCRIPTION <code>int</code> <p>Number of matching lines between the two sources.</p> Source code in <code>mkv_episode_matcher/utils.py</code> <pre><code>def compare_text(text1, text2):\n    \"\"\"\n    Compare two lists of text lines and return the number of matching lines.\n\n    Args:\n        text1 (list): List of text lines from the first source.\n        text2 (list): List of text lines from the second source.\n\n    Returns:\n        int: Number of matching lines between the two sources.\n    \"\"\"\n    # Flatten the list of text lines\n    flat_text1 = [line for lines in text1 for line in lines]\n    flat_text2 = [line for lines in text2 for line in lines]\n\n    # Compare the two lists of text lines\n    matching_lines = set(flat_text1).intersection(flat_text2)\n    return len(matching_lines)\n</code></pre>"},{"location":"api/#configuration","title":"Configuration","text":""},{"location":"api/#mkv_episode_matcher.config","title":"mkv_episode_matcher.config","text":""},{"location":"api/#mkv_episode_matcher.config-functions","title":"Functions","text":""},{"location":"api/#mkv_episode_matcher.config.set_config","title":"set_config","text":"<pre><code>set_config(tmdb_api_key, open_subtitles_api_key, open_subtitles_user_agent, open_subtitles_username, open_subtitles_password, show_dir, file)\n</code></pre> <p>Sets the configuration values and writes them to a file.</p> PARAMETER DESCRIPTION <code>tmdb_api_key</code> <p>The API key for TMDB (The Movie Database).</p> <p> TYPE: <code>str</code> </p> <code>open_subtitles_api_key</code> <p>The API key for OpenSubtitles.</p> <p> TYPE: <code>str</code> </p> <code>open_subtitles_user_agent</code> <p>The user agent for OpenSubtitles.</p> <p> TYPE: <code>str</code> </p> <code>open_subtitles_username</code> <p>The username for OpenSubtitles.</p> <p> TYPE: <code>str</code> </p> <code>open_subtitles_password</code> <p>The password for OpenSubtitles.</p> <p> TYPE: <code>str</code> </p> <code>show_dir</code> <p>The directory where the TV show episodes are located.</p> <p> TYPE: <code>str</code> </p> <code>file</code> <p>The path to the configuration file.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <p>None</p> Source code in <code>mkv_episode_matcher/config.py</code> <pre><code>def set_config(\n    tmdb_api_key,\n    open_subtitles_api_key,\n    open_subtitles_user_agent,\n    open_subtitles_username,\n    open_subtitles_password,\n    show_dir,\n    file,\n):\n    \"\"\"\n    Sets the configuration values and writes them to a file.\n\n    Args:\n        tmdb_api_key (str): The API key for TMDB (The Movie Database).\n        open_subtitles_api_key (str): The API key for OpenSubtitles.\n        open_subtitles_user_agent (str): The user agent for OpenSubtitles.\n        open_subtitles_username (str): The username for OpenSubtitles.\n        open_subtitles_password (str): The password for OpenSubtitles.\n        show_dir (str): The directory where the TV show episodes are located.\n        file (str): The path to the configuration file.\n\n    Returns:\n        None\n    \"\"\"\n    config = configparser.ConfigParser()\n    config[\"Config\"] = {\n        \"tmdb_api_key\": str(tmdb_api_key),\n        \"show_dir\": show_dir,\n        \"max_threads\": int(MAX_THREADS),\n        \"open_subtitles_api_key\": str(open_subtitles_api_key),\n        \"open_subtitles_user_agent\": str(open_subtitles_user_agent),\n        \"open_subtitles_username\": str(open_subtitles_username),\n        \"open_subtitles_password\": str(open_subtitles_password),\n    }\n    logger.info(\n        f\"Setting config with API:{tmdb_api_key}, show_dir: {show_dir}, and max_threads: {MAX_THREADS}\"\n    )\n    with open(file, \"w\") as configfile:\n        config.write(configfile)\n</code></pre>"},{"location":"api/#mkv_episode_matcher.config.get_config","title":"get_config","text":"<pre><code>get_config(file)\n</code></pre> <p>Read and return the configuration from the specified file.</p> PARAMETER DESCRIPTION <code>file</code> <p>The path to the configuration file.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>dict</code> <p>The configuration settings as a dictionary.</p> Source code in <code>mkv_episode_matcher/config.py</code> <pre><code>def get_config(file):\n    \"\"\"\n    Read and return the configuration from the specified file.\n\n    Args:\n        file (str): The path to the configuration file.\n\n    Returns:\n        dict: The configuration settings as a dictionary.\n\n    \"\"\"\n    logger.info(f\"Loading config from {file}\")\n    config = configparser.ConfigParser()\n    if Path(file).exists():\n        config.read(file)\n        return config[\"Config\"] if \"Config\" in config else None\n    return {}\n</code></pre>"}]}